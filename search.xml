<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo个人博客搭建</title>
    <url>/2025/04/05/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<ol>
<li><p>安装 Node.js</p>
</li>
<li><p>配置镜像源</p>
</li>
</ol>
<p><code>npm install -g cnpm --registry=https://registry.npmmirror.com</code></p>
<ol start="3">
<li>安装 Hexo</li>
</ol>
<p><code>cnpm install -g hexo-cli</code>  </p>
<ol start="4">
<li>新建个文件夹，在命令行中执行</li>
</ol>
<p><code>hexo init</code></p>
<ol start="5">
<li>命令</li>
</ol>
<p><code>hexo s（start）</code>：启动hexo，在浏览器预览一下</p>
<p><code>hexo n（new） &quot;xx&quot;</code>： 新建一个名子为xx帖子 </p>
<p>在 <code>D:\MyBlog\source\_posts</code> 中用Vscode打开，并编辑内容</p>
<p><code>hexo clean</code>：清理</p>
<p><code>hexo g (generate)</code>：生成  </p>
<hr>
<h1 id="将博客部署到Github上"><a href="#将博客部署到Github上" class="headerlink" title="将博客部署到Github上"></a>将博客部署到Github上</h1><ol>
<li>在<code>Github</code>中创建一个新仓库</li>
</ol>
<blockquote>
<p>仓库名字有要求：<code>yanwuuu.github.io</code>  仓库名需要<strong>全小写</strong></p>
<p>以后访问博客即可通过这个名字访问</p>
</blockquote>
<hr>
<ol start="2">
<li>在创建的文件夹的命令行中，安装<code>hexo-deployer-git</code></li>
</ol>
<p><code>cnpm install --save hexo-deployer-git</code></p>
<hr>
<ol start="3">
<li>修改<code>_config.yml</code>文件</li>
</ol>
<blockquote>
<p>文件底部</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/YanWuuu/YanWuuu.github.io.git  // Github仓库的地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></blockquote>
</blockquote>
<hr>
<ol start="4">
<li><code>hexo d</code>：部署到远端（不能使用加速器）</li>
</ol>
<hr>
<h1 id="更换Hexo主题"><a href="#更换Hexo主题" class="headerlink" title="更换Hexo主题"></a>更换Hexo主题</h1><p>博主地址：github.com&#x2F;litten&#x2F;hexo-theme-yilia </p>
<p>有些文件要以管理员身份才可以修改，所以需要以管理员方式打开记事本</p>
<blockquote>
<ol>
<li><p>先以管理员方式打开命令行</p>
</li>
<li><p>notepad C:\Windows\System32\drivers\etc\hosts</p>
</li>
</ol>
</blockquote>
<p>克隆代码</p>
<p><code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia(克隆到的本地位置)</code></p>
<p>修改_config.yml文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: yilia //改动的地方</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>安装 Node.js</tag>
        <tag>配置镜像源</tag>
        <tag>安装 Hexo</tag>
        <tag>启动 Hexo</tag>
        <tag>部署到 Github</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序项目</title>
    <url>/2025/04/07/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="小程序项目"><a href="#小程序项目" class="headerlink" title="小程序项目"></a>小程序项目</h1><h3 id="1-近期目标"><a href="#1-近期目标" class="headerlink" title="1. 近期目标"></a>1. 近期目标</h3><p>微信小程序上传照片，包括微信开发者工具和后端</p>
<p>看明哥学 Vue，多思考，碰到哪里不清楚，去看 Vue 开发者文档，弄懂</p>
<p>前端的处理逻辑，有技术含量的东西</p>
<p>后端的细节，经验  </p>
<p>学习C++·，编程四大件（有技术含量的）</p>
<p>更改 hexo 博客的样式</p>
<hr>
<h3 id="2-目前完成的工作"><a href="#2-目前完成的工作" class="headerlink" title="2. 目前完成的工作"></a>2. 目前完成的工作</h3><ol>
<li>售后服务的上传表单功能(没有上传照片)   </li>
<li>保养功能的上传照片功能，保存在云服务器的 <code>/var/www/html/images</code> 中, <code>url</code>也已经保存在数据库中</li>
</ol>
<hr>
<h3 id="3-注意"><a href="#3-注意" class="headerlink" title="3. 注意"></a>3. 注意</h3><ol>
<li>IDEA中删除东西时，小心<strong>默认点击</strong>的文件也被删除了</li>
</ol>
<hr>
<h3 id="4-后端（Backend）"><a href="#4-后端（Backend）" class="headerlink" title="4. 后端（Backend）"></a>4. 后端（Backend）</h3><h4 id="4-0-什么是后端？"><a href="#4-0-什么是后端？" class="headerlink" title="4.0 什么是后端？"></a>4.0 什么是后端？</h4><p><em><strong>用户请求处理、逻辑处理、数据处理</strong></em></p>
<h4 id="4-1-打包相关命令"><a href="#4-1-打包相关命令" class="headerlink" title="4.1  打包相关命令"></a>4.1  打包相关命令</h4><p>打 jar 包命令 <code>mvn package</code>  </p>
<p>我的 jar 包放在 <code>/home</code>中  </p>
<p>运行 jar 包命令 <code>java -jar 包名</code>  </p>
<h4 id="4-2-创建后端项目"><a href="#4-2-创建后端项目" class="headerlink" title="4.2 创建后端项目"></a>4.2 创建后端项目</h4><ol>
<li>创建新文件夹并在IDEA中打开</li>
<li><code>New module</code></li>
<li><code>Spring Initiallizr</code></li>
</ol>
<blockquote>
<p>取项目名 选择JDK版本 更改 Group </p>
<p>勾选依赖：Lombok、Spring Web、MySQL Driver  </p>
</blockquote>
<ol start="4">
<li>删掉项目里一些自动生成且不需要的文件  </li>
<li>加入<code>mybatis-plus</code>支持</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;  // 也可以去官网寻找,这个是springboot2版本</span><br></pre></td></tr></table></figure>

<p><a href="https://baomidou.com/">MyBatis-plus官网</a>  </p>
<ol start="6">
<li>新建一个 HelloController 测试一下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController  // 标识这个类是一个REST控制器，控制器返回的对象会自动化序列化为JSON格式</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @GetMapping // 处理客户端发送来的GET请求</span><br><span class="line">    public String hello()&#123;</span><br><span class="line">        return &quot;hello wms&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>REST控制器：用于处理和响应RESTful Web服务请求的组件，允许客户端通过HTTP协议与服务器进行通信</p>
</blockquote>
<ol start="7">
<li>创建数据库实例</li>
</ol>
<blockquote>
<p>数据库在很多情况下需要<em><strong>刷新</strong></em>才能显示</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE USER（表名）</span><br><span class="line">(</span><br><span class="line">    id INT AUTO_INCREMENT COMMENT &#x27;主键&#x27; </span><br><span class="line">    PRIMARY KEY,</span><br><span class="line">    NO VARCHAR(20) NULL COMMENT &#x27;账号&#x27;,</span><br><span class="line">    NAME VARCHAR(100) NOT NULL COMMENT &#x27;名字&#x27;,</span><br><span class="line">    PASSWORD VARCHAR(20) NOT NULL COMMENT &#x27;密码&#x27;,</span><br><span class="line">    age INT NULL,</span><br><span class="line">    sex INT NULL COMMENT &#x27;性别&#x27;,</span><br><span class="line">    phone VARCHAR(20) NULL COMMENT &#x27;电话&#x27;,</span><br><span class="line">    role_id INT NULL COMMENT &#x27;角色 0超级管理员, 1管理员，2普通账号&#x27;,</span><br><span class="line">    isValid VARCHAR(4) DEFAULT &#x27;Y&#x27; NULL COMMENT &#x27;是否有效，Y有效，其他无效&#x27;</span><br><span class="line">)</span><br><span class="line">    CHARSET = utf8;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：（）中的最后一行不要有逗号，这是语法错误</p>
</blockquote>
<ol start="8">
<li>配置 <code>yml</code>文件，将自带的 <code>properties</code> 配置文件改为 <code>yml</code></li>
</ol>
<blockquote>
<p>作用：连接数据库</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080  // 这个后端应用程序将运行在本地的 8080 端口上</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/wms02(数据库名)?serverTimezone=Asia/Shanghai</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3306 是 Mysql 数据库的默认端口</p>
</blockquote>
<ol start="9">
<li>编写测试代码</li>
</ol>
<ul>
<li>创建实体类</li>
</ul>
<blockquote>
<p>注意要对应数据库中的字段 </p>
<p>数据库和 JAVA 对应字段规则：JAVA中的大写对应数据库中的_</p>
<blockquote>
<p>数据库中有下划线，JAVA中用大写</p>
<p>数据库中是大写，JAVA中用小写</p>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Entity  // 表示其是JPA的实体类，会被映射到数据库中的一张表</span><br><span class="line">@Table(name = &quot;xxx&quot;) // 选择表的名字，没有这个的话，会自动根据类名要求你有这个表。标记了name也可能报错，最好的办法就是听它的（创建一个它要的表名）</span><br><span class="line">@Data  // 是 Lombok 提供的一个注解，自动生成getter、setter、toString()等方法</span><br><span class="line">public class User &#123;</span><br><span class="line">	@Id  // 标记实体的主键</span><br><span class="line">    private int id;</span><br><span class="line">    private String no;</span><br><span class="line">    private String name;</span><br><span class="line">    private String password;</span><br><span class="line">    private int sex;</span><br><span class="line">    private int roleId;</span><br><span class="line">    private String isvalid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@Entity和Table需要新增 pom 依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></blockquote>
<ul>
<li>创建mapper接口</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>控制反转和依赖注入是什么？</p>
<blockquote>
<p>控制反转（IoC）：把对象的创建交给Spring容器来控制，称为Bean</p>
</blockquote>
<blockquote>
<p>依赖注入：将一个类依赖的对象（Bean）注入进去，而不是自己创建</p>
</blockquote>
<p>@Mapper：将这个接口注册为<strong>Bean</strong>，后续就可以在Service层中<strong>依赖注入</strong>这个Mapper接口</p>
<p>BaseMapper<User>：Mybatis-plus提供的一个通用Mapper接口，提供了许多常用的CRUD操作，作用：UserMapper可以直接使用与User实体相关的CRUD操作</p>
</blockquote>
<ul>
<li><p>创建service接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface UserService extends IService&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Iservice<User>：Mybatis-plus提供的通用接口，提供了一系列数据库的CRUD操作方法</p>
<p><strong>为什么需要接口和实现类？</strong></p>
<blockquote>
<p>接口定义了类所必须实现的一组方法，但不关心这些方法是如何具体实现的</p>
</blockquote>
<blockquote>
<p>实现类具体实现了接口中的方法，<strong>实现了特定业务</strong></p>
</blockquote>
<blockquote>
<p>好处：解耦</p>
</blockquote>
</blockquote>
</li>
<li><p>创建service实现类</p>
</li>
</ul>
<p>新建一个impl文件夹，创建UserServiceImpl</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@Service：将这个类注册为Spring容器中的一个Bean，之后可以依赖注入</p>
<p>ServiceImpl&lt;UserMapper,User&gt;：Mybatis-Plus提供的通用服务实现类，作用：UserServiceImpl（继承它的类）可以直接使用CRUD操作。</p>
<p>ServiceImpl通过UserMapper，提供对数据库的访问（特定业务）</p>
</blockquote>
<ul>
<li>在HelloCroller中测试</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @GetMapping</span><br><span class="line">    public String hello()&#123;</span><br><span class="line">        return &quot;hello wms&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	//新增测试代码</span><br><span class="line">    @Autowired  // 自动装配，自动注入UserService实例</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public List&lt;User&gt; list()&#123;</span><br><span class="line">        return userService.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以自己去创建一个UserService</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// HelloCtroller中</span><br><span class="line">@GetMapping(&quot;/list&quot;)</span><br><span class="line">    public List&lt;User&gt; list()&#123;</span><br><span class="line">        return userService.listAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">// UserService中去声明</span><br><span class="line">public interface UserService extends IService&lt;User&gt; &#123;</span><br><span class="line">    List&lt;User&gt; listAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UserServiceImpl 中去实现</span><br><span class="line">@Service</span><br><span class="line">public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;</span><br><span class="line">    @Resource  // 也是用于依赖注入</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line">    @Override  // 表示其是对接口方法的重写</span><br><span class="line">    public List&lt;User&gt; listAll() &#123;</span><br><span class="line">        return userMapper.listAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//UserMapper 中</span><br><span class="line">@Mapper</span><br><span class="line">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line">    List&lt;User&gt; listAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步，去resource中新建文件夹Mapper并在其中新建文件UserMapper.xml  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.wms.mapper.UserMapper&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;listAll&quot; parameterType=&quot;com.wms.entity.User&quot;&gt;</span><br><span class="line">        select * from  user</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作用：为UserMapper接口提供了一个SQL查询操作 listAll</p>
<p>listAll 会执行 select * from  user 语句，从 user表中查询数据</p>
<p>查询结果会自动映射到 com.wms.entity.User 类型的对象并返回调用方</p>
<blockquote>
<p>映射：在Mybatis中，映射指的是将SQL查询的结果集转换成 Java 对象的过程</p>
</blockquote>
<p>namespace：作用：将 XML 中定义的 SQL 语句和 Java 接口中的方法绑定</p>
<p>parameterType：作用：制定了 SQL 操作所接收的参数类型</p>
</blockquote>
<p>运行测试。。。</p>
<h4 id="4-3-实现增删改查"><a href="#4-3-实现增删改查" class="headerlink" title="4.3 实现增删改查"></a>4.3 实现增删改查</h4><ol>
<li>新增</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/save&quot;)</span><br><span class="line">    public boolean save(@RequestBody User user)&#123;</span><br><span class="line">        return userService.save(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@RequestBody：将HTTP请求的主体（body）映射到方法的参数上，在这里是将去请求的的 JSON 数据转换为 User 类型的对象</p>
<p>GET：请求的数据通过 URL 传递</p>
<p>POST：请求的数据通过请求体（body）发送，而不是通过 URL ，请求体中可以包含表单数据、JSON数据等</p>
</blockquote>
<ol start="2">
<li>修改</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/mod&quot;)</span><br><span class="line">    public boolean mod(@RequestBody User user)&#123;</span><br><span class="line">        return userService.updateById(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>新增或修改</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/saveOrMod&quot;)</span><br><span class="line">   public boolean saveOrMod(@RequestBody User user)&#123;</span><br><span class="line">       return userService.saveOrUpdate(user);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>删除</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/delete&quot;)</span><br><span class="line">    public boolean delete(Integer id)&#123;</span><br><span class="line">        return userService.removeById(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>查询（模糊、匹配）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/listP&quot;)</span><br><span class="line">   public List&lt;User&gt; listP(@RequestBody User user)&#123;</span><br><span class="line">       LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper();</span><br><span class="line">       lambdaQueryWrapper.like(User::getName,user.getName());</span><br><span class="line">       return userService.list(lambdaQueryWrapper);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作用：查询数据库中与请求体的 User 对象的 name 属性匹配的所有对象</p>
<p>LambdaQueryWrapper是 Mybatis-Plus 提供的一个工具类，用于构建数据库查询条件，作用：就像是写了SQL查询语句一样</p>
<p>lambdaQueryWrapper.like：模糊匹配，.equal就是完全匹配</p>
</blockquote>
<ol start="6">
<li>使用Postman时注意</li>
</ol>
<p><img src="D:\xmind\Typora\image\postman.png"></p>
<h4 id="4-4-分页的实现"><a href="#4-4-分页的实现" class="headerlink" title="4.4 分页的实现"></a>4.4 分页的实现</h4><ol>
<li>封装分页请求的参数：新建和 controller 平级的文件夹 common ，并创建 QueryPageParam 文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class QueryPageParam &#123;</span><br><span class="line">    private static int PAGE_SIZE = 20;</span><br><span class="line">    private static int PAGE_NUM = 1;</span><br><span class="line"></span><br><span class="line">    private int pageSize=PAGE_SIZE;</span><br><span class="line">    private int pageNum=PAGE_NUM;</span><br><span class="line"></span><br><span class="line">    private HashMap param;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>静态方法（static）：不依赖于对象进行访问，方便在没有创建对象的情况下进行调用  </p>
<p>pageNum：页数</p>
<p>pafeSize：每页的数据量  </p>
<p><code>offset = (pageNum - 1) * pageSize</code>：表示从数据源中查询结果时，跳过了多少条数据</p>
</blockquote>
<p>再在 HelloController 中新增  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/listPage&quot;)</span><br><span class="line">public List&lt;User&gt; listPage(@RequestBody QueryPageParam query)&#123;</span><br><span class="line">    System.out.println(query);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;num===&quot; + query.getPageNum());</span><br><span class="line">    System.out.println(&quot;size===&quot; + query.getPageSize());</span><br><span class="line"></span><br><span class="line">    HashMap param = query.getParam();</span><br><span class="line">    System.out.println(&quot;name===&quot; + param.get(&quot;name&quot;));</span><br><span class="line">    System.out.println(&quot;no===&quot; + param.get(&quot;no&quot;));</span><br><span class="line"></span><br><span class="line">    return null;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>添加分页拦截器</li>
</ol>
<p>在 common 中创建 MybatisPlusConfig 文件  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MybatisPlusConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;</span><br><span class="line">        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</span><br><span class="line">        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));</span><br><span class="line">        return interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@Configuration：MybatisPlusConfig 是一个配置类，里面定义的 Bean 可以被 Spring 管理</p>
<p>作用：只需传入当前页码和每页显示的数量，MyBatis Plus 会<strong>自动生成</strong>适当的 SQL 查询来获取相应的数据。</p>
</blockquote>
<ol start="3">
<li>在HelloController中利用 MybatisPlus 提供的封装对象 <strong>Page</strong> 去分页</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> @PostMapping(&quot;/listPage&quot;)</span><br><span class="line">    public List&lt;User&gt; listPage(@RequestBody QueryPageParam query)&#123;</span><br><span class="line"></span><br><span class="line">        HashMap param = query.getParam();</span><br><span class="line">        String name = (String)param.get(&quot;name&quot;);</span><br><span class="line"></span><br><span class="line">        Page&lt;User&gt; page = new Page();  // Page&lt;User&gt;：MybatisPlus 提供的分页对象</span><br><span class="line">        page.setPages(query.getPageNum());</span><br><span class="line">        page.setSize(query.getPageSize());</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper();</span><br><span class="line">        lambdaQueryWrapper.like(User::getName,name);</span><br><span class="line"></span><br><span class="line">        IPage result = userService.page(page,lambdaQueryWrapper);  // MybatisPlus提供的接口，用于封装分页查询的结果</span><br><span class="line">        System.out.println(&quot;total===&quot; + result.getTotal());  // 打印总记录数</span><br><span class="line">        return result.getRecords();  // 返回当前页的用户记录</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>也可以自己在 HelloController中去定义一个userService的方法，然后去UserService声明方法，UserServiceImpl去实现，再在UserMapper中声明方法，最后在xml中写SQL语句</li>
</ol>
<blockquote>
<p>注意： UserServiceImpl 中需要依赖注入UserMapper，使用它的方法</p>
</blockquote>
<h4 id="4-5-返给前端数据的封装"><a href="#4-5-返给前端数据的封装" class="headerlink" title="4.5 返给前端数据的封装"></a>4.5 返给前端数据的封装</h4><ol>
<li>在 common 中新建 Result 类</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Result &#123;</span><br><span class="line">    private int code;  // 编码200/400</span><br><span class="line">    private String msg;  // 成功/失败</span><br><span class="line">    private Long total;  // 总记录数</span><br><span class="line">    private Object data;  // 数据</span><br><span class="line"></span><br><span class="line">    public static Result fail()&#123;</span><br><span class="line">        return result(400, &quot;失败&quot;, 0L, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Result suc()&#123;</span><br><span class="line">        return result(200, &quot;成功&quot;, 0L, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Result suc(Object data)&#123;</span><br><span class="line">        return result(200, &quot;成功&quot;, 0L, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Result suc(Object data, Long total)&#123;</span><br><span class="line">        return result(200, &quot;成功&quot;, total, data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static Result result(int code,String msg,Long total,Object data)&#123;</span><br><span class="line">        Result res = new Result();</span><br><span class="line">        res.setCode(code);</span><br><span class="line">        res.setMsg(msg);</span><br><span class="line">        res.setTotal(total);</span><br><span class="line">        res.setData(data);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将 HelloController 中的返回值类型改为我自己创建的 Result 类</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/listPageC1&quot;)</span><br><span class="line">    public Result listPageC1(@RequestBody QueryPageParam query) &#123;</span><br><span class="line"></span><br><span class="line">        HashMap param = query.getParam();</span><br><span class="line">        String name = (String) param.get(&quot;name&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Page&lt;User&gt; page = new Page();  // Page&lt;User&gt;：MybatisPlus 提供的分页对象</span><br><span class="line">        page.setPages(query.getPageNum());</span><br><span class="line">        page.setSize(query.getPageSize());</span><br><span class="line"></span><br><span class="line">/*        LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper();</span><br><span class="line">        lambdaQueryWrapper.like(User::getName,name);*/</span><br><span class="line"></span><br><span class="line">        IPage result = userService.pageC(page);</span><br><span class="line">        System.out.println(&quot;total===&quot; + result.getTotal());  // 打印总记录数</span><br><span class="line">        return Result.suc(result.getRecords(),result.getTotal());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>利用框架提供的方法：<code>ResponseEntity </code>类</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/afterSale&quot;)</span><br><span class="line">public ResponseEntity&lt;Void&gt; save(@RequestBody AfterSale afterSale)&#123;</span><br><span class="line">    afterSaleService.save(afterSale);</span><br><span class="line">    return ResponseEntity.ok().build();  // 生成一个状态码 200 的响应，没有响应体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ResponseEntity：Spring Web中的一个类，处理 HTTP 响应的一个重要类</p>
</blockquote>
<hr>
<h3 id="5-微信开发者工具"><a href="#5-微信开发者工具" class="headerlink" title="5. 微信开发者工具"></a>5. 微信开发者工具</h3><blockquote>
<p>此节目的：知道这些配置在哪，然后去<a href="https://developers.weixin.qq.com/doc/">微信开发者文档</a>查看细节  </p>
<blockquote>
<p>前端<strong>界面设计</strong>方法论：要有<strong>块</strong>的概念，每一块都用 view <strong>包裹</strong>起来，作用：更好布局</p>
<blockquote>
<p>父组件看自己里面包含的东西就是看作一个块</p>
</blockquote>
<p>微信小程序的调试器的Wxml左边的按钮可以看到界面上<strong>DOM的布局</strong>，方便进行<strong>调试</strong>（网页上也可以通过这个按钮去看布局）</p>
</blockquote>
</blockquote>
<h4 id="5-1-全局配置"><a href="#5-1-全局配置" class="headerlink" title="5.1 全局配置"></a>5.1 <strong>全局配置</strong></h4><p><code>tabBar</code>：底部栏</p>
<blockquote>
<p>照片的路径 syntax</p>
<p>本地：&#x2F;images（自己创建的文件夹）&#x2F;xxx</p>
<p>远程服务器： <a href="http://47.109.96.127/images/hanji1.png">http://47.109.96.127/images/hanji1.png</a></p>
</blockquote>
<h4 id="5-2-页面配置"><a href="#5-2-页面配置" class="headerlink" title="5.2 页面配置"></a>5.2 <strong>页面配置</strong></h4><blockquote>
<p>在<strong>window</strong>属性里配置</p>
</blockquote>
<p><code>navigationBarTitleText</code>：页标题  </p>
<p><code>navigationBarBackgroundColor</code>：导航栏背景颜色</p>
<h4 id="5-3-组件"><a href="#5-3-组件" class="headerlink" title="5.3 组件"></a>5.3 组件</h4><p><code>swiper</code>：滑块视图容器  </p>
<p><code>image</code>：图片 </p>
<blockquote>
<p>mode：防止图片变形</p>
</blockquote>
<p><code>button</code>：按钮  </p>
<p><code>input</code>：输入框</p>
<blockquote>
<p>bindinput&#96;&#x3D;“xxx（自定义函数）”：作用：键盘输入时或内容改变时触发这个函数</p>
</blockquote>
<h4 id="5-4-重要属性"><a href="#5-4-重要属性" class="headerlink" title="5.4 重要属性"></a>5.4 重要属性</h4><p><code>width：100%  </code></p>
<p><code>height：100vh</code>：设置元素高度，1vh等于视口高度的1%   </p>
<p><code>text-align：center</code>：水平居中对齐文本  </p>
<p><code>border-bottom: darkgrey solid 1px</code>：边框颜色和厚度</p>
<h4 id="5-5-API"><a href="#5-5-API" class="headerlink" title="5.5 API"></a>5.5 API</h4><p><code>wx.navigateTo</code>：保存当前界面，跳转到应用内的某个界面，但是不能跳转到<code>tabbar</code>页面</p>
<blockquote>
<p>可以通过将父包裹元素设置上事件，来实现<strong>被包裹的元素的点击事件都为它</strong> </p>
</blockquote>
<p><code>wx.showToast</code>：在页面上显示一个提示框  </p>
<p><code>wx.request</code>：发送 HTTPS 网络请求</p>
<h4 id="5-6-使用-iconfont-的步骤"><a href="#5-6-使用-iconfont-的步骤" class="headerlink" title="5.6 使用 iconfont 的步骤"></a>5.6 使用 iconfont 的步骤</h4><ol>
<li>去官网选择图标加入项目</li>
<li>复制代码去浏览器打开  </li>
<li>创建一个和 page <strong>平级</strong>的文件夹 styles  </li>
<li>在 styles 里创建 iconfont.wxss 文件，将第二步复制的代码粘贴进去  </li>
<li>在 app.wxss 里导入</li>
</ol>
<p><code>@import &quot;/styles/iconfont.wxss&quot;;</code></p>
<h4 id="5-7-框架接口"><a href="#5-7-框架接口" class="headerlink" title="5.7 框架接口"></a>5.7 框架接口</h4><p><code>App</code>：在<code>app.js</code>中，作用：注册小程序，指定小程序的生命周期回调等  </p>
<p><code>Page</code>：在<code>页面.js</code>中，作用：注册页面，指定页面的初始数据、生周期回调、事件处理函数等  </p>
<blockquote>
<p><code>data</code>：是响应式的，作用：存储和管理数据 </p>
<blockquote>
<p>使用 <strong><code>setData</code></strong> 方法，可以将变化的数据自动渲染到前端页面</p>
</blockquote>
</blockquote>
<h4 id="5-8-实现上传表单功能"><a href="#5-8-实现上传表单功能" class="headerlink" title="5.8 实现上传表单功能"></a>5.8 实现上传表单功能</h4><ol>
<li>在<code>data</code>中定义变量</li>
<li>在<code>input</code>组件的属性<code>bindinput</code>绑定函数，在函数中编写<strong>更新页面数据的方法</strong>（<code>setData</code>），完成响应式</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onModelInput(event) &#123;</span><br><span class="line">  this.setData(&#123;</span><br><span class="line">    model: event.detail.value</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在<code>button</code>组件绑定的方法中实现<code>request</code></li>
</ol>
<blockquote>
<p>预处理：通过解构赋值取出变量，并检查是否表单都有输入，没有的话进行提示</p>
<blockquote>
<p>解构赋值：直接对多个变量同时赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">submitForm()&#123;</span><br><span class="line"> const &#123;model, serial,fault&#125; = this.data;</span><br><span class="line"> if(!model || !serial || !fault)&#123;</span><br><span class="line">   wx.showToast(&#123;</span><br><span class="line">     title: &#x27;请填写完整信息&#x27;,</span><br><span class="line">     icon: &#x27;none&#x27;</span><br><span class="line">   &#125;)</span><br><span class="line">   return;  // 如果满足条件，则退出，不执行后面的 request</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">      url:&#x27;http://localhost:8080/user/afterSale&#x27;,</span><br><span class="line">      method:&#x27;POST&#x27;,</span><br><span class="line">      header:&#123;</span><br><span class="line">        &#x27;Content-Type&#x27;:&#x27;application/json&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      data:&#123;</span><br><span class="line">        model:model,</span><br><span class="line">        serial:serial,</span><br><span class="line">        fault:fault</span><br><span class="line">      &#125;,</span><br><span class="line">      success:(res) =&gt;&#123;  // 这是一个成功回调函数</span><br><span class="line">        if(res.statusCode === 200)&#123;</span><br><span class="line">          wx.showToast(&#123;</span><br><span class="line">            title:&#x27;提交成功&#x27;,</span><br><span class="line">            icon:&#x27;success&#x27;  // 显示的图标</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          wx.showToast(&#123;</span><br><span class="line">            title:&#x27;提交失败&#x27;,</span><br><span class="line">            icon:&#x27;none&#x27;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-后台管理系统（Vue）"><a href="#6-后台管理系统（Vue）" class="headerlink" title="6. 后台管理系统（Vue）"></a>6. 后台管理系统（Vue）</h3><h4 id="6-1-页面布局的搭建"><a href="#6-1-页面布局的搭建" class="headerlink" title="6.1 页面布局的搭建"></a>6.1 页面布局的搭建</h4><ol>
<li>在<code>components</code>里创建新的<code>.vue</code>文件，加入element-plus 提供的布局代码</li>
<li>在<code>App.vue</code>中导入，在<code>template</code>中使用这个标签</li>
</ol>
<h4 id="6-2-页面布局的拆分"><a href="#6-2-页面布局的拆分" class="headerlink" title="6.2 页面布局的拆分"></a>6.2 页面布局的拆分</h4><ul>
<li>将<code>elment-plus</code>给的代码分块，分别放进不同的<code>.vue</code>文件，再在剪切的地方引入（6.1中的两步）组件</li>
</ul>
<blockquote>
<p><code>element-plus</code>中的<strong>图标需要再次引入</strong></p>
</blockquote>
<h4 id="6-3-编写头部页面"><a href="#6-3-编写头部页面" class="headerlink" title="6.3 编写头部页面"></a>6.3 编写头部页面</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;  // 有 setup 表示这是组合式 API，相比选项式 API 有区别</span><br><span class="line"> const toUser = () =&gt; &#123;</span><br><span class="line">     console.log(&quot;sss&quot;); // 使用 console.log</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote>
<h4 id="6-4-导航栏菜单的伸缩"><a href="#6-4-导航栏菜单的伸缩" class="headerlink" title="6.4 导航栏菜单的伸缩"></a>6.4 导航栏菜单的伸缩</h4><p>目标：一个子组件事件传到另外一个子组件，<strong>通过父组件去传递</strong></p>
<ol>
<li>$emit 触发自定义事件，作用：子组件事件传递到父组件事件</li>
</ol>
<blockquote>
<p>子组件：&lt;button @click&#x3D;”$emit(‘someEvent’)”&gt;Click Me</button></p>
<p>父组件：定义名为 someEvent 的事件</p>
</blockquote>
<ol start="2">
<li><p>父组件传递给子组件用<code>props</code></p>
</li>
<li><p>在父组件中，将从子组件传来的事件和传到另一个子组件属性关联起来，再在事件中做逻辑处理</p>
</li>
</ol>
<h4 id="6-5-安装axios与跨域处理"><a href="#6-5-安装axios与跨域处理" class="headerlink" title="6.5 安装axios与跨域处理"></a>6.5 安装axios与跨域处理</h4><ol>
<li>安装 <code>axios</code></li>
</ol>
<p><code>npm install axios --save</code></p>
<ol start="2">
<li><code>main.ts</code> 中引入</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">app.config.globalProperties.$axios = axios;  // (Vue2和Vue3有区别)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在<code>Main.vue</code>中使用<code>axios</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">    import &#123; onMounted, ref &#125; from &#x27;vue&#x27;</span><br><span class="line">    import axios from &#x27;axios&#x27;</span><br><span class="line">    const item = &#123;</span><br><span class="line">    date: &#x27;2016-05-02&#x27;,</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    address: &#x27;No. 189, Grove St, Los Angeles&#x27;,</span><br><span class="line">  &#125;</span><br><span class="line">    const tableData = ref(Array.from(&#123; length: 10 &#125;).fill(item))</span><br><span class="line">    const loadGet = () =&gt; &#123;</span><br><span class="line">        axios.get(&#x27;http://localhost:8080/user/list&#x27;).then(res =&gt; res.data).then(res=&gt;&#123;</span><br><span class="line">            console.log(res);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    const loadPost = () =&gt; &#123;</span><br><span class="line">        axios.post(&#x27;http://localhost:8080/user/listP&#x27;,&#123;&#125;).then(res =&gt; res.data).then(res=&gt;&#123;</span><br><span class="line">            console.log(res);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    onMounted(() =&gt; &#123;</span><br><span class="line">        //loadGet();</span><br><span class="line">        loadPost();</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>挂载：Vue将一个组件连接到DOM上的过程，从创建到显示在页面的过程</p>
<p>.then是请求成功时的回调函数</p>
</blockquote>
<ol start="4">
<li>在Common中新建一个跨域类</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.wms.common;</span><br><span class="line"> import org.springframework.context.annotation.Configuration;</span><br><span class="line"> import org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"> import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"> @Configuration</span><br><span class="line"> public class CorsConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class="line">         registry.addMapping(&quot;/**&quot;)</span><br><span class="line">                 //是否发送Cookie</span><br><span class="line">                 .allowCredentials(true)</span><br><span class="line">                 //放⾏哪些原始域</span><br><span class="line">                 .allowedOriginPatterns(&quot;*&quot;)</span><br><span class="line">                 .allowedMethods(new String[]&#123;&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;&#125;)</span><br><span class="line">                 .allowedHeaders(&quot;*&quot;)</span><br><span class="line">                 .exposedHeaders(&quot;*&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>修改了后端的<code>listP</code>方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/listP&quot;)</span><br><span class="line">    public List&lt;User&gt; listP(@RequestBody User user) &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper();</span><br><span class="line">        if(StringUtils.isNotBlank(user.getName()))&#123;</span><br><span class="line">            lambdaQueryWrapper.like(User::getName, user.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        return userService.list(lambdaQueryWrapper);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多加了 if，如果不加 if 的话，当<code>user.getName()</code>的返回值为 null（前端没有传body），会导致查不到数据</p>
</blockquote>
<h4 id="6-6-列表的基本展示"><a href="#6-6-列表的基本展示" class="headerlink" title="6.6 列表的基本展示"></a>6.6 列表的基本展示</h4><ol>
<li>是如何展示出来的，用<code>element-plus</code>封装好的属性<code>prop</code></li>
</ol>
<ul>
<li><pre><code>&lt;el-table :data=&quot;tableData&quot;
            :header-cell-style=&quot;&#123; background:&#39;#f2f5fc&#39;, color:&#39;#555&#39;&#125;&quot;
            border
            &gt;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  `tableData`接收后端传来的数据</span><br><span class="line"></span><br><span class="line">- `&lt;el-table-column prop=&quot;id&quot; label=&quot;ID&quot; width=&quot;60&quot; /&gt;`</span><br><span class="line"></span><br><span class="line">&gt; 子组件el-table-column的 prop 属性对应对象（后端传来的）中的键名</span><br><span class="line"></span><br><span class="line">2. 实现UI界面上0 对应女，1 对应男的功能</span><br><span class="line"></span><br><span class="line">&lt;el-table-column prop=&quot;sex&quot; label=&quot;性别&quot; width=&quot;80&quot;&gt;</span><br><span class="line">    &lt;template #default=&quot;scope&quot;&gt;</span><br><span class="line">        &lt;el-tag</span><br><span class="line">            :type=&quot;scope.row.sex === 1 ? &#x27;primary&#x27; : &#x27;success&#x27;&quot;</span><br><span class="line">            disable-transitions&gt;</span><br><span class="line">           &#123;&#123;scope.row.sex === 1 ? &#x27;男&#x27; : &#x27;女&#x27; &#125;&#125;</span><br><span class="line">        &lt;/el-tag&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/el-table-column&gt;</span><br><span class="line"></span><br><span class="line">&gt; 本质是具名插槽，名字为 default</span><br><span class="line">&gt;</span><br><span class="line">&gt; scope：是父组件的对象，可以通过它来访问父组件的属性</span><br><span class="line">&gt;</span><br><span class="line">&gt; 父组件和子组件**有包含关系即可**，不是必须要在两个.vue文件中</span><br><span class="line"></span><br><span class="line">3. 改变列表第一行颜色`header-cell-style`，加上边框`border`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
&lt;el-table :data=&quot;tableData&quot;
          :header-cell-style=&quot;&#123; background:&#39;#f2f5fc&#39;, color:&#39;#555&#39;&#125;&quot;
          border
          &gt;
</code></pre>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. 加上按钮</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>        &lt;el-table-column prop=&quot;operate&quot; label=&quot;操作&quot;&gt;
            &lt;el-button type=&quot;success&quot;&gt;编辑&lt;/el-button&gt;
            &lt;el-button type=&quot;danger&quot;&gt;删除&lt;/el-button&gt;
        &lt;/el-table-column&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. 封装后端返回到前端的数据，修改后端接口代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>   @PostMapping(“&#x2F;listP”)<br>    public Result listP(@RequestBody User user) {<br>        LambdaQueryWrapper<User> lambdaQueryWrapper &#x3D; new LambdaQueryWrapper();<br>        if(StringUtils.isNotBlank(user.getName())){<br>            lambdaQueryWrapper.like(User::getName, user.getName());<br>        }<br>        return Result.suc(userService.list(lambdaQueryWrapper));<br>    }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6. 因为后端返回给前端的数据多封装了一层，所以前端拿数据时需要往下一层</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>const loadPost = () =&gt; &#123;
    axios.post(&#39;http://localhost:8080/user/listP&#39;,&#123;&#125;).then(res =&gt; res.data).then(res=&gt;&#123;
        console.log(res);
        if(res.code == 200)&#123;
            tableData.value = res.data;
        &#125;else&#123;
            alert(&#39;获取数据失败&#39;)
        &#125;
    &#125;)
&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 6.7  分页查询</span><br><span class="line"></span><br><span class="line">1. 使用 element-plus 中的分页组件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>template部分：<br>        &lt;el-pagination<br>            :current-page&#x3D;”pageNum”<br>            :page-size&#x3D;”pageSize”<br>            :page-sizes&#x3D;”[5, 10, 20, 30]”<br>            :size&#x3D;”size”<br>            layout&#x3D;”total, sizes, prev, pager, next, jumper”<br>            :total&#x3D;”total”<br>            @size-change&#x3D;”handleSizeChange”<br>            @current-change&#x3D;”handleCurrentChange”<br>        &#x2F;&gt;</p>
<p>script部分：<br>    <script lang="ts" setup><br>    import { onMounted, ref } from &#39;vue&#39;<br>    import axios from &#39;axios&#39;<br>    import type { ComponentSize } from &#39;element-plus&#39;</p>
<pre><code>const tableData = ref()
const pageSize = ref(10)
const pageNum = ref(1)
const total = ref(0)
const size = ref&lt;ComponentSize&gt;(&#39;default&#39;)
const loadGet = () =&gt; &#123;
    axios.get(&#39;http://localhost:8080/user/list&#39;).then(res =&gt; res.data).then(res=&gt;&#123;
        console.log(res);
    &#125;)
&#125;
const loadPost = () =&gt; &#123;
    axios.post(&#39;http://localhost:8080/user/listPageC1&#39;,&#123;pageSize:pageSize.value,pageNum:pageNum.value&#125;).then(res =&gt; res.data).then(res=&gt;&#123;
        console.log(res);
        if(res.code == 200)&#123;
            tableData.value = res.data;
            total.value = res.total;
        &#125;else&#123;
            alert(&#39;获取数据失败&#39;)
        &#125;
    &#125;)
&#125;
onMounted(() =&gt; &#123;
    //loadGet();
    loadPost();
&#125;)
const handleSizeChange = (val: number) =&gt; &#123;  // val是组件 el-pagination 自带的属性
    console.log(`$&#123;val&#125; items per page`)
    pageNum.value = 1
    pageSize.value = val;
    loadPost()
&#125;
const handleCurrentChange = (val: number) =&gt; &#123;
    console.log(`current page: $&#123;val&#125;`)
    pageNum.value = val;
    loadPost()
&#125;
</code></pre>
<p></script></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 总结: element-plus 已经将属性定义好了,我需要做的就是把后端传来的数据传给这个属性即可</span><br><span class="line"></span><br><span class="line">#### 6.8 查询处理</span><br><span class="line"></span><br><span class="line">1. 搜索栏：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div style="margin:5px;">
            <el-input v-model="name" placeholder="请输入名字" suffix-icon="el-icon-search" style="width: 200px;"  @keyup.enter="loadPost" ></el-input>
            <el-icon><Search /></el-icon>
            <el-button type="primary" style="margin-left: 5px;" @click="loadPost">查询</el-button>
            <el-button type="success">重置</el-button>
        </div>
        
<p>const name &#x3D; ref();<br>   const loadPost &#x3D; () &#x3D;&gt; {<br>        axios.post(‘<a href="http://localhost:8080/user/listPageC1',%7BpageSize:pageSize.value,pageNum:pageNum.value,param:%7Bname:name.value%7D%7D).then">http://localhost:8080/user/listPageC1&#39;,{pageSize:pageSize.value,pageNum:pageNum.value,param:{name:name.value}}).then</a>(res &#x3D;&gt; res.data).then(res&#x3D;&gt;{<br>            console.log(res);<br>            if(res.code &#x3D;&#x3D; 200){<br>                tableData.value &#x3D; res.data;<br>                total.value &#x3D; res.total;<br>            }else{<br>                alert(‘获取数据失败’)<br>            }<br>        })<br>    }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt; @keyup.enter=&quot;loadPost&quot;：回车事件</span><br><span class="line"></span><br><span class="line">实现流程：绑定响应式数据 name ，再将 name 传到后端去查询</span><br><span class="line"></span><br><span class="line">2. 下拉查询：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&lt;el-select<br>                v-model&#x3D;”sex”  &#x2F;&#x2F; 定义一个响应式属性 sex<br>                filterable<br>                placeholder&#x3D;”请选择性别”<br>                style&#x3D;”width: 240px; margin-left: 5px;”<br>            &gt;<br>            <el-option
            v-for="item in sexs"
            :key="item.value"
            :label="item.label"
            :value="item.value"
            /><br>            </el-select></p>
<p>const sex &#x3D; ref();<br>    const sexs &#x3D; [<br>  {<br>    value: ‘1’,<br>    label: ‘男’,<br>  },<br>  {<br>    value: ‘0’,<br>    label: ‘女’,<br>  }];<br>  axios.post(‘<a href="http://localhost:8080/user/listPageC1">http://localhost:8080/user/listPageC1</a>‘,<br>        {pageSize:pageSize.value,pageNum:pageNum.value,param:{name:name.value,sex:sex.value}}) &#x2F;&#x2F; 新加 sex，传到后端</p>
<p>后端新增：<br>String sex &#x3D; (String) param.get(“sex”);<br>if (StringUtils.isNotBlank(sex)){<br>            lambdaQueryWrapper.eq(User::getSex,sex);<br>        }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 重置</span><br><span class="line"></span><br><span class="line">实现流程：将 sex 和 name 属性清空</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&lt;el-button type&#x3D;”success” @click&#x3D;”resetParam”&gt;重置</el-button><br>   const resetParam &#x3D;() &#x3D;&gt; {<br>        name.value &#x3D; ‘’;<br>        sex.value &#x3D; ‘’;<br>    }</p>
<pre><code>









</code></pre>
]]></content>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>八股</title>
    <url>/2025/05/25/%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[<h1 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h1><h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h3 id="什么是面向对象的设计思想？"><a href="#什么是面向对象的设计思想？" class="headerlink" title="什么是面向对象的设计思想？"></a>什么是面向对象的设计思想？</h3><p>OOP（ Object-Oriented Programming ），通过<strong>对象</strong>来组织和管理程序</p>
<p>四大特征</p>
<ul>
<li>封装：将属性和方法绑定在一起，形成一个对象。并将对象内部隐藏起来，只暴露必要的接口供外部使用（数据保护）</li>
<li>继承：一个类继承另一个类的属性和方法（代码复用，已于扩展）。</li>
<li>多态：同一个方法用于不同的对象时，产生不同的行为。</li>
</ul>
<blockquote>
<p> <strong>Animal</strong> dog &#x3D; new <strong>Dog</strong>();  &#x2F;&#x2F;  <strong>允许将父类对象引用指向子类对象</strong></p>
<p> def animal_sound(animal):  </p>
<p> print(animal.speak()) &#x2F;&#x2F; animal</p>
<p> animal_sound(dog)  # 输出: Bark（ 前提是子类 dog 要重写父类的 sound 方法 ）</p>
<p> animal_sound(cat)  # 输出: Meow</p>
</blockquote>
<ul>
<li>抽象：隐藏复杂的实现细节，只保留重要的功能接口（程序员可以将注意力集中在高层次设计上）。</li>
</ul>
<hr>
<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul>
<li>接口：包含常量和方法签名（ 不包含方法的实现 ），多个类可以实现该接口，实现多态。多继承（ implements ）。适用于定义类的功能。方法是 public abstract，变量 public static final，被default 修饰的方法，允许在实现该接口的类中<strong>不必重写</strong>这个方法</li>
<li>抽象类：包含抽象方法和具体方法（ 可以有方法的具体实现 ）。单继承（ extends ）。适用于有明显继承关系的场景。</li>
</ul>
<hr>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>作用：允许程序在<strong>运行时</strong>动态地获取类的信息和操作类的方法</p>
<p>动态性：反射使得我们在运行时动态地创建对象、调用方法和访问属性，与编译时不同，运行时反射允许程序在<strong>不知道具体类</strong>的情况下，根据需要处理对象</p>
<p>使用场景：框架设计，动态代理（ 通过反射来创建对象 ）</p>
<p>原理：加载完类之后，在堆中生成了一个 Class 类型的对象，这个对象包含了类的完整结构，然后通过 class 实例获取 class 信息和方法</p>
<hr>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>定义：是 Java 语言中的一种特性，允许在类、接口、方法中使用类型参数。在实例化时指定具体的数据类型即可。</p>
<p>使用场景：集合框架，自定义数据结构</p>
<hr>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><p>由两大接口派生而来：<code>Collection</code> 和 <code>Map</code></p>
<p>![屏幕截图 2025-05-12 164335](D:\xmind\Typora\image\屏幕截图 2025-05-12 164335.png)</p>
<img src="D:\xmind\Typora\image\屏幕截图 2025-05-12 164753.png" alt="屏幕截图 2025-05-12 164753" style="zoom:80%;" />

<hr>
<h3 id="说说List、Set、Queue、Map的区别？"><a href="#说说List、Set、Queue、Map的区别？" class="headerlink" title="说说List、Set、Queue、Map的区别？"></a>说说List、Set、Queue、Map的区别？</h3><ul>
<li>List：存储的元素是<strong>有序</strong>的、可重复</li>
<li>Set：存储的元素<strong>不可重复</strong></li>
<li>Queue：特定的排序规则（先进先出），存储的元素和 List 性质一样</li>
<li>Map：使用 key-value 存储</li>
</ul>
<hr>
<h3 id="ArrayLIst-和-LinkedList-区别"><a href="#ArrayLIst-和-LinkedList-区别" class="headerlink" title="ArrayLIst 和 LinkedList 区别"></a>ArrayLIst 和 LinkedList 区别</h3><ul>
<li>都线程不安全</li>
<li>ArrayList 底层使用数组，LinkedList 底层使用双向链表</li>
<li>ArrayList 支持随机访问，LinkedList 不支持 随机访问</li>
<li>ArrayList 使用场景：根据索引快速访问，内存开销小。LinkedList使用场景：在中间位置插入或删除，不需要随机访问</li>
</ul>
<hr>
<h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><p>HashSet：底层是哈希表，不保证元素插入和取出顺序</p>
<p>LinkedHashSet：底层是链表和哈希表，FIFO</p>
<p>TreeSet：底层是红黑树，支持对元素自定义排序</p>
<hr>
<h3 id="String、-StringBuffer-、StringBuilder-的区别"><a href="#String、-StringBuffer-、StringBuilder-的区别" class="headerlink" title="String、 StringBuffer 、StringBuilder 的区别"></a>String、 StringBuffer 、StringBuilder 的区别</h3><p>可变性：String 不可变、Buffer 和 Builder 可变，因为它们继承自 AbstractStringBuilder 类（ 提供了很多修改字符串的方法，比如 append ）</p>
<p>线程安全性：String 中的对象不可变，可以理解为常量，线程安全。StringBuffer 在 AbstractStringBuilder 方法上加了同步锁，线程安全。StringBuilder 没有加锁，线程不安全</p>
<p>使用场景：String（ 操作少量数据 ）、StringBuilder（ 单线程下操作大量数据 ）、StringBuffer（ 多线程操作大量数据 ）</p>
<hr>
<h3 id="什么是BlockingQueue"><a href="#什么是BlockingQueue" class="headerlink" title="什么是BlockingQueue"></a>什么是BlockingQueue</h3><p>阻塞队列，继承自<code>Queue</code>，功能：当队列没有元素时一直阻塞，如果队列已满，一直等到队列可以放入新元素时再放入。</p>
<p>常用于生产者-消费者模型中，生产者线程向队列中添加元素，消费者线程从队列中取出数据</p>
<hr>
<h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><p>HashMap：线程不安全。可以存储 null 的 key 和 value。总是以 2 的幂作为容量大小。</p>
<p>Hashtable：线程安全，不能存储 null。 容量变为 2n + 1。底层基于 HashMap</p>
<hr>
<h3 id="HashMap与ConcurrentHashMap的区别是什么？"><a href="#HashMap与ConcurrentHashMap的区别是什么？" class="headerlink" title="HashMap与ConcurrentHashMap的区别是什么？"></a><strong>HashMap与ConcurrentHashMap的区别是什么？</strong></h3><p>内存结构：都是数组+链表+红黑树</p>
<p>线程安全：Hashmap 非线程安全，ConcurrentHashMap，java7及之前，采用将整个哈希表分成多个段，每个段有自己的锁。java8 之后，采用 CAS（实现并发编程的原子性操作） 和 synchronized 来保证线程安全</p>
<hr>
<h3 id="HashMap-的底层原理"><a href="#HashMap-的底层原理" class="headerlink" title="HashMap 的底层原理"></a>HashMap 的底层原理</h3><ul>
<li>HashMap 是什么：使用一个数组来存储数据，每个数组元素被称为“桶”，每个桶可以存储一个链表或红黑树</li>
</ul>
<ol>
<li>将Key 的  <code>hashcode（ 通过哈希函数计算得来 ）</code> 输入到扰动函数（ 优化哈希值的分布，减小碰撞 ）处理后得到 hash 值</li>
</ol>
<blockquote>
<p>扰动函数 hash</p>
<p> static final int hash(Object key) {<br>   int h;<br>   &#x2F;&#x2F; key.hashCode()：返回散列值也就是hashcode<br>   &#x2F;&#x2F; ^：按位异或<br>   &#x2F;&#x2F; &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐<br>   return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>}</p>
</blockquote>
<ol start="2">
<li>(n（数组长度） - 1) &amp; hash&#96; 判断元素存在的位置</li>
</ol>
<p>如果存在元素，就判断两者的 hash 值和 key 是否相同，相同则直接覆盖，不同就通过拉链法解决冲突</p>
<blockquote>
<p>拉链法：若遇到哈希冲突，将冲突的值加到链表中</p>
</blockquote>
<p>当链表长度大于 8 时（ 当数组长度小于64，会优先进性数组扩容（ 因为可以减少哈希冲突的发生概率 ） ），将链表转化为红黑树（ 减少搜索时间 ）</p>
<ul>
<li>怎么扩容 ？</li>
</ul>
<p>当元素数量（ 键值对 ）达到 capacity * loadFactor（ 负载因子，默认0.75 ），就会触发扩容</p>
<ol>
<li><p>创建一个扩大到当前容量的<strong>两倍</strong>的新数组</p>
</li>
<li><p>重新计算哈希值（ 用第 1 步的方法 ）</p>
</li>
<li><p>迁移元素，重新计算位置（ 用第 2 步的方法 ）</p>
</li>
<li><p>更新指针：将指向原数组得引用更新为指向新数组得引用</p>
</li>
</ol>
<hr>
<h3 id="hashcode-冲突怎么解决"><a href="#hashcode-冲突怎么解决" class="headerlink" title="hashcode 冲突怎么解决"></a>hashcode 冲突怎么解决</h3><p>链地址法：在值中，使用链表才存储哈希值相同的对象</p>
<p>开放地址法：寻找哈希表下一个空的桶来存储冲突对象</p>
<p>再哈希法：使用另一个哈希函数再次计算键的哈希值</p>
<hr>
<h3 id="java中怎么把一个字符串反转"><a href="#java中怎么把一个字符串反转" class="headerlink" title="java中怎么把一个字符串反转"></a>java中怎么把一个字符串反转</h3><ul>
<li>使用 StringBuilder（ 非线程安全 ） 或 StringBuffer（ 线程安全 ） 的 reverse () 方法</li>
<li>手动反转字符串</li>
</ul>
<hr>
<h2 id="Java-并发"><a href="#Java-并发" class="headerlink" title="Java 并发"></a>Java 并发</h2><h3 id="怎么保证线程安全"><a href="#怎么保证线程安全" class="headerlink" title="怎么保证线程安全"></a>怎么保证线程安全</h3><ul>
<li>原子性：一个操作要么完全执行，要么完全不执行</li>
<li>可见性：一个线程对共享变量的修改，能够即时被其他线程看到（ volatile：用于修饰变量，确保在多线程环境下对该变量的写操作可以被其他线程及时看到 ）</li>
<li>有序性：保证程序中语句执行的顺序</li>
</ul>
<hr>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>作用：保证被它修饰的方法或代码块在同一时刻只能由一个线程执行</p>
<p>非公平（ 多个线程竞争一把锁时，锁的获取顺序并不保证遵循请求的顺序 ）、可重入（ 同一线程可以多次获取同同一把锁 ）</p>
<p>重量级锁：因为监视器锁（ 内置的并且使用者看不到的锁称为监视器锁 ）依赖于操作系统，挂起或环形一个线程，需要从<strong>用户态转到内核态</strong>，时间成本相对较高</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><ul>
<li>使用 synchronized 之后，会在编译之后在代码块前后加上 <code>monitorenter</code> 和 <code>monitorexit</code> 字节码指令。执行monitorenter 指令会尝试获取对象锁，如果对象没有锁或者已经获得了锁，锁的<strong>计数器</strong> + 1。此时其他竞争锁的线程进入等待队列，执行 monitorexit 会把计数器 -1，当计数器为 0，锁释放。处于等待队列中的线程再继续竞争锁</li>
</ul>
<hr>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>非公平、可重入</p>
<p>实现了 <code>Lock</code> 接口，可重入锁，和 Synchronized 类似，但是<strong>多了</strong>公平锁、支持超时（ 超过等待时间就会获取锁失败 ）功能</p>
<hr>
<h3 id="reentrantlock和sync区别是什么"><a href="#reentrantlock和sync区别是什么" class="headerlink" title="reentrantlock和sync区别是什么"></a>reentrantlock和sync区别是什么</h3><p>用法不同：synchronized 可用来修饰普通方法、静态方法，而 reentrantLock 只能用在代码块上</p>
<p>获取锁和释放锁方式不同：sync 自动加锁和释放锁，reen 需要手动</p>
<p>锁类型不同：sync 非公平，reen 可以非公平也可以公平</p>
<p>响应中断：reen 可以响应中断（ 一个线程持有某个锁并且等待其他资源时被中断，可以及时释放持有的锁 ），解决死锁问题，sync 不能</p>
<hr>
<h3 id="ThreadLocal-是什么"><a href="#ThreadLocal-是什么" class="headerlink" title="ThreadLocal 是什么"></a>ThreadLocal 是什么</h3><ul>
<li><p>解决线程安全问题的一种机制，允许创建线程的局部变量</p>
</li>
<li><p>原理：ThreadLocalMap ，key 是 ThreadLocal 本身，value 是 线程特定的变量</p>
</li>
<li><p>内存泄漏原因：未调用ThreadLocal.remove方法（ ThreadLocalMap 继续持有对变量的引用 ）</p>
</li>
</ul>
<hr>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>一种用于管理和复用线程的技术</p>
<p>好处：</p>
<ul>
<li><p>降低因创建和销毁线程造成的消耗</p>
</li>
<li><p>提高响应速度。任务到达时，任务不需要等待线程创建就能立刻从池中分配一个空闲线程来执行任务</p>
</li>
<li><p>提高线程的可管理性</p>
</li>
</ul>
<p>核心参数：</p>
<ul>
<li>核心线程数( corePoolSize )：线程池中始终保持活动的线程数量</li>
<li>最大线程数( maximumPoolSize )：线程池允许的最大线程数量</li>
<li>线程空闲时间( keepAliveTime ) :当任务数量大于核心线程数，多余的线程会在空闲时间到达后被终止</li>
<li>任务队列( workQueue)：存放等待执行的任务</li>
<li>线程工厂( threadFactory )：可以为线程设置名称、优先级等属性</li>
<li>拒绝策略( handler )：当线程池和队列都满了，再有新任务提交时，线程池会采取拒绝策略</li>
</ul>
<blockquote>
<p>CallerRunsPolicy：使用线程池的调用者所在的线程去执行被拒绝的任务</p>
<p>AbortPolicy：直接抛出一个任务被线程池拒绝的异常</p>
<p>DiscardPolicy：不做任何处理</p>
<p>DiscardOldestPolicy：抛弃最小的任务，然后执行该任务</p>
</blockquote>
<h4 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h4><ol>
<li>创建线程池</li>
<li>提交任务</li>
<li>任务排队（任务首先进入 BlockingQueue ）</li>
<li>线程的创建与复用（ 一系列比较判断 ） </li>
<li>任务执行</li>
<li>任务完成（ 线程回到线程池 ）</li>
</ol>
<hr>
<h3 id="读写锁和互斥锁的区别，使用场景"><a href="#读写锁和互斥锁的区别，使用场景" class="headerlink" title="读写锁和互斥锁的区别，使用场景"></a>读写锁和互斥锁的区别，使用场景</h3><ul>
<li>互斥锁：同一时刻只允许一个线程或进程发访问共享资源（ 用于写操作频繁 ）</li>
<li>读写锁：将对共享资源的访问分为读操作和写操作。允许多个线程同时进行读操作，但在写操作时，会排斥其他的读操作和写操作（ 用于读操作多余写操作 ）</li>
</ul>
<hr>
<h3 id="java中容易出现的异常"><a href="#java中容易出现的异常" class="headerlink" title="java中容易出现的异常"></a>java中容易出现的异常</h3><ul>
<li>检查异常：必须在代码里处理或抛出</li>
</ul>
<p>SQLException：与数据库交互式发生错误时</p>
<p>IOException：输入输出操作失败会中断时</p>
<ul>
<li>运行时异常：不要求强制处理，但在运行时可能会出现</li>
</ul>
<p>NullPointerException：对一个 null 对象进行操作时</p>
<p>ArrayIndexOutOfBoundsException：访问数组时，索引超出了数组有效范围</p>
<hr>
<h3 id="ABA是什么问题，一般可以怎么解决？"><a href="#ABA是什么问题，一般可以怎么解决？" class="headerlink" title="ABA是什么问题，一般可以怎么解决？"></a>ABA是什么问题，一般可以怎么解决？</h3><p>线程对共享状态的错误理解，情景：线程 A 读取某个变量的值为 A，线程 B 将该值修改为 B 而后又将其恢复为 A ，当线程 A 执行 CAS 操作时，会发现值还是 A，误认为没有其他线程对该变量修改，最终成功修改该值</p>
<p>通过版本号解决</p>
<hr>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>定义：一系列命令的集合</p>
<p>作用：保证数据的一致性</p>
<p>ACID特性：</p>
<ul>
<li>原子性（ Atomicity ）：事务是最小的执行单位。要么全部完成，要么全部不起作用</li>
<li>一致性（Consistency）：执行事务前后，数据保持一致</li>
</ul>
<blockquote>
<p>转账业务中，无论事务是否成功， 转账这和收款人的总额应该是不变的</p>
</blockquote>
<ul>
<li><p>隔离性（ Isolation ）：各并发事务之间的数据库是独立的</p>
</li>
<li><p>持久性（ Durability ）：一个事务被提交后，数据库中的改变是持久的</p>
</li>
<li><p>保证了事务的原子性，隔离性和持久性之后，一致性才能保证，AID是手段，C是目的</p>
</li>
</ul>
<hr>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>一个事务读取了另一个事务未提交的修改数据，由于未提交的修改数据可能回滚，因此读取到的数据可能并不可靠</p>
<blockquote>
<p>回滚：数据库的状态恢复到事务开始之前的状态</p>
</blockquote>
<h3 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h3><p>一个事务读取一个数据时，另一个事务也访问了该数据，那么在第一个事务中修改了这个数据，第二个事务也修改了这个数据。这样第一个事务修改结果就被丢失，称为丢失修改</p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>相同的查询在同一个事务中返回的<strong>结果集</strong>不同，因为另一个事务插入( <strong>增删</strong> )了符合条件的新数据</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>相同的<strong>行</strong>数据在同一个事务中被多次读取，结果不同，因为另一个事务<strong>修改</strong>了该行数据</p>
<hr>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>作用：负责如何存储、检索和管理数据</p>
<ul>
<li>InnoDB（ 默认的存储引擎 ）</li>
</ul>
<ol>
<li><p>事务支持：提供了对事务的支持，可以进行 ACID 属性的操作</p>
</li>
<li><p>并发性能：采用了行级锁定的机制，可以提供更好的并发性能</p>
</li>
</ol>
<blockquote>
<p>行级锁定：数据库管理系统中对数据进行的锁定机制，与表级锁不同，行级锁只锁定被修改的特定行，允许多个事务同时访问不同的行，提高并发性能</p>
</blockquote>
<ol start="3">
<li>崩溃恢复：通过 redolog 日志实现了崩溃恢复，保证数据的持久性</li>
</ol>
<ul>
<li>MyISAM：具有较低的存储空间和内存消耗，适用于大量读操作中</li>
<li>Memory：将数据存储在内存中国，适用于对性能要求较高的读操作中</li>
</ul>
<hr>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>定义：用于加速数据检索的一种数据结构，可以显著提高查询性能（ MySQL能快速定位到数据，而不需要扫描整个表 ）</p>
<ul>
<li>B+ tree：叶子节点才存放数据，非叶子节点只放索引（ 索引里有多个键，例如：类似于将搜索树的左右两个节点变成一个节点，而这个节点里就是索引，索引里有两个键 ）。子节点有两个指针，分别执</li>
</ul>
<h4 id="索引失效的场景"><a href="#索引失效的场景" class="headerlink" title="索引失效的场景"></a>索引失效的场景</h4><ol>
<li><p>WHERE 语句中，OR 前的条件列是索引列，而 OR 后的条件列不是索引列</p>
</li>
<li><p>在索引列上使用了函数或表达式计算</p>
</li>
<li><p>使用 LIKE 且通配符 % 位于字符串的开头</p>
</li>
</ol>
<hr>
<h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC( 多版本并发控制 )"></a>MVCC( 多版本并发控制 )</h3><p>定义：一种用于数据库管理系统中的并发控制机制，确保数据的一致性和隔离性</p>
<ul>
<li>多版本：MVCC 通过为每个事务创建数据的多个版本（ <strong>快照</strong> ），允许不同的事务同时读取和写入数据，而不会相互阻塞</li>
<li>并发控制：在多个事务同时访问数据库时，MVCC 通过版本管理来控制事务之间的并发访问</li>
</ul>
<p>工作原理：</p>
<ul>
<li>版本管理：当对数据进行修改时，数据库并<strong>不会直接覆盖原有的数据</strong>，而是创建一个新的数据版本</li>
<li>读操作：MVCC 确保读取的是事务<strong>开始时可见的版本</strong>，实现快照读。由于每个事务有自己的快照，所以读操作不会阻塞写操作。</li>
</ul>
<blockquote>
<p>读取数据的过程：一个事务在读取数据时，其他事务提交了对该数据的修改，该事务会看到的是修<strong>改前的旧版本</strong>，而不是正在进行的修改，保证了读取操作的隔离性</p>
</blockquote>
<ul>
<li>写操作：当事务进行写操作时，创建一个新的版本，并将该版本标记为当前事务的版本。完成事务后，新的版本被提交，成为最新的可见版本。</li>
</ul>
<hr>
<h3 id="MySQL-隔离级别"><a href="#MySQL-隔离级别" class="headerlink" title="MySQL 隔离级别"></a>MySQL 隔离级别</h3><p>决定了多个事务并发执行时的行为</p>
<ol>
<li>读未提交：一个事务可以读取另一个事务未提交的数据。可能出现脏读</li>
<li>读已提交：一个事务只能读取已提交的数据。可能出现不可重复读</li>
<li>可重复读：一个事务在开始后，期间读取的数据在该事务内都是一致的。可能出现幻读，因为查询的结果可能因为其他事务的插入（ 增删 ）而变化</li>
<li>串行行：所有事务按顺序执行</li>
</ol>
<hr>
<h3 id="三个日志"><a href="#三个日志" class="headerlink" title="三个日志"></a>三个日志</h3><ul>
<li>错误日志：记录错误信息</li>
<li>二进制日志：记录所有更改数据库状态的操作</li>
<li>重做日志：记录事务对数据库的操作</li>
</ul>
<hr>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h3><p>JMM：用于解决<strong>多线程环境</strong>下的可见性、有序性和原子性问题，核心是通过定义主内存和工作内存的交互规则，确保进程间通信正确。</p>
<ul>
<li>原子性：同一时刻只能有一个线程对数据进行操作</li>
<li>可见性：一个线程对主内存的修改可以及时地被其他线程看到</li>
<li>有序性：使用 happens-before原则（ 第一个操作会在第二个操作之前执行 ）</li>
</ul>
<hr>
<h3 id="jvm内存模型介绍一下"><a href="#jvm内存模型介绍一下" class="headerlink" title="jvm内存模型介绍一下"></a><strong>jvm内存模型介绍一下</strong></h3><p>作用：定义了 Java 程序如何在内存中分配和管理数据</p>
<ul>
<li>方法区：存储类信息、常量、静态变量和 JIT 编译后的代码。Java 8 之后，成为<strong>元空间</strong>，不再使用堆内存而是本地内存（ JVM运行时从操作系统分配的内存 ），是线程共享的</li>
<li>堆区：存储对象实例，是 JVM 中最大的内存区域。也是所有<strong>线程共享</strong>的内存区域，垃圾回收的主要区域，</li>
</ul>
<p>有新生代（ 存放新创建的对象 ）、老年代（ 存放长期存活的对象）和元空间（ 存储类的元数据 ）</p>
<ul>
<li>栈区：线程私有，存储局部变量、方法调用。局部变量在方法调用结束后立即被销毁</li>
<li>程序计数器：记录当前线程执行字节码的地址，该区域<strong>线程私有</strong></li>
<li>本地方法栈：执行本地方法（通过 JNI调用的、用其他编程语言编写的方法 ）的调用</li>
</ul>
<hr>
<h3 id="怎么进行垃圾回收？"><a href="#怎么进行垃圾回收？" class="headerlink" title="怎么进行垃圾回收？"></a>怎么进行垃圾回收？</h3><p>垃圾回收定义：回收不再用的对象，来释放内存空间</p>
<p>垃圾回收算法：</p>
<ul>
<li>引用计数法：每个对象维护引用计数器，每当有一个地方引用该对象时，计数器 +1，失效时，计数器 -1。当引用为 0 时回收</li>
<li>可达性分析：从被称为 GC Roots（ 线程、静态变量、栈中的局部变量、全局变量等 ）的对象作为起始点，开始向下搜索，搜索走过的路径叫引用链。当从 GC Roots 到该对象不可达，则证明该对象不可用，可被回收</li>
</ul>
<blockquote>
<p>本地变量：代码内部声明的</p>
</blockquote>
<hr>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>类加载器：负责在运行时将 Java 类加载到内存中，作用：将字节码文件（ .class 文件 ）转化为 JVM 可以使用的类对象</p>
<p>定义：Java 类加载器在加载类时，首先会将请求委派给<strong>父类加载器</strong>，只有当父类加载器无法找到该类时，子类加载器才会尝试自己加载</p>
<p>优点：</p>
<ul>
<li>避免重复加载（ 当父类加载了该类，就不需要子加载器再次加载 ）</li>
<li>防止核心 API 被篡改（ 无法编写一个自己的 java.lang.String 类来替换系统的 String 类，因为所有的 String 类都会有启动类加载器加载（ 父类 ））</li>
</ul>
<hr>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="为什么-Redis-比-MySQL-快？"><a href="#为什么-Redis-比-MySQL-快？" class="headerlink" title="为什么 Redis 比 MySQL 快？"></a>为什么 Redis 比 MySQL 快？</h3><ul>
<li><p>Redis 数据主要存储在内存中，MySQL数据存储在磁盘上，内存的读写速度远远快于磁盘。</p>
</li>
<li><p>采用了简单的数据结构，MySQL 的数据结构相对发杂，以表的形式存储</p>
</li>
</ul>
<hr>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>String：值是字符串，用于缓存</li>
<li>Hash：键值对的集合，存储对象</li>
<li>List：有序字符串集合，可以在两端快速推入或弹出元素，类似于链表，用于消息队列</li>
<li>Set：无序字符串集合，支持<strong>唯一性</strong>，方法除了添加获取删除还有<strong>交集并集</strong>，用于共同关注</li>
<li>Zset：与 Set 类似，但是多了每个元素有与之关联的<strong>分数</strong>，用于排行榜</li>
</ul>
<hr>
<h3 id="Redis持久化机制有哪些，底层原理是怎样的"><a href="#Redis持久化机制有哪些，底层原理是怎样的" class="headerlink" title="Redis持久化机制有哪些，底层原理是怎样的"></a>Redis持久化机制有哪些，底层原理是怎样的</h3><ul>
<li><p>AOF 日志</p>
<p>每执行一条写操作命令，就把该命令以追加的方式写入到一个日志文件里</p>
</li>
</ul>
<p>​	同步策略：1.Always：每次写操作后同步、2.Everysec：每秒同步、3.No：从不同不（依赖操作系统）</p>
<p>​	重写策略：根据数据库状态所需的最小命令集来生成一个新的 AOF 文件</p>
<p>​	数据恢复：Redis重启时，可以通过 AOF 文件重放其中的命令来啊恢复数据</p>
<ul>
<li><p>RDB 快照</p>
<p>为什么有RDB快照？AOF记录的时操作命令而不是实际的数据，若AOF日志非常多，会造成Redis恢复操作缓慢</p>
</li>
</ul>
<p>​	定义：记录某一个瞬间的内存数据</p>
<p>​	生成 RDB 文件的命令：save：在主线程中生成RDB文件，会阻塞主线程、bgsave：创建一个子进程生成RDB，避免阻塞</p>
<hr>
<h3 id="redis分布式锁读写一致性如何保证"><a href="#redis分布式锁读写一致性如何保证" class="headerlink" title="redis分布式锁读写一致性如何保证"></a>redis分布式锁读写一致性如何保证</h3><p>锁过期导致读写不一致，使用 Redisson 的自动续期机制（ 锁被持有期间，Redisson会自动延长锁的过期时间 ）</p>
<hr>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="RabbitMQ-是什么"><a href="#RabbitMQ-是什么" class="headerlink" title="RabbitMQ 是什么"></a>RabbitMQ 是什么</h3><p>消息队列，特性如下</p>
<ul>
<li>核心组件：生产者发送消息给 RabbitMQ、消费者从 RabbitMQ 接收并处理消息、RabbitMQ 本身负责存储和转发消息</li>
<li>交换机：接收来自生产者的消息，并根据 Routing key 和绑定规则将消息路由到一个或多个队列</li>
</ul>
<blockquote>
<p>Routing key：消息发送时附加的一个字符串，交换机根据这个字符串来决定将消息路由到哪些队列</p>
<p>绑定规则：</p>
<ul>
<li>Direct Binding：队列与交换机通过一个具体的路由键连接</li>
<li>Topic Binding：使用匹配模式（ * 代表一个单词， # 代表多个单词 ）</li>
<li>Fanout Binding：所有绑定到该交换机的队列都会收到消息</li>
</ul>
</blockquote>
<ul>
<li>持久化：可以将消息保存在磁盘上</li>
<li>确认机制：消费者处理完消息后发送确认给 RabbitMQ，未确认的消息会重新入队</li>
<li>高可用性：可以将多个 RabbitMQ 实例组成一个集群</li>
</ul>
<hr>
<h3 id="消息幂等性"><a href="#消息幂等性" class="headerlink" title="消息幂等性"></a>消息幂等性</h3><p>定义：同一条消息被处理多次时，结果是相同的，不会产生副作用（ 重复扣款、重复创建订单 ）</p>
<p>为什么需要幂等性：1. 生产者消息重发、2. 消费者重复处理</p>
<p>实现方法</p>
<ul>
<li>唯一标识符：为每条消息分配一个唯一的标识符，消费者在处理消息时，首先检查（ 判断 Set 集合中有没有这个唯一标识符 ）该标识符是否已经处理过（ 背景：每次处理完后都会把唯一识别符记录到一个 Set 集合中 ）</li>
<li>数据库约束：在数据库中使用唯一约束（ 防止在指定的列中插入重复数据 ），确保同一条消息不会导致重复插入</li>
</ul>
<hr>
<h3 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h3><p>定义：消息传递过程中，消息未能成功到达目标消费者的情况。</p>
<p>解决方案：</p>
<ul>
<li>持久化消息（ 队列崩溃 ）：确保消息在发送到队列时进行持久化。实现：将消息标记为 persistent 来确保其被写入磁盘</li>
<li>确认机制（ 消费者崩溃 ）：消费者在成功处理消息后，必须向消息队列发送确认信号，确保只有在消息成功处理后，才会从队列中删除</li>
<li>重试机制 （ 消费者处理消息失败 ）：将处理失败的消息重新放回队列中</li>
<li>死信队列（ 消费者处理消息失败 ）：将无法处理的消息发送到死信队列。实现：配置一个死信交换机，将处理失败的消息路由到特定的死信队列</li>
</ul>
<hr>
<h3 id="消费堆积"><a href="#消费堆积" class="headerlink" title="消费堆积"></a>消费堆积</h3><p>定义：消息队列中未消费的消息数量不断增加</p>
<p>解决方法：</p>
<ul>
<li>增加消费者实例（ 加快消费速率 ）</li>
<li>优化消息处理逻辑（ 减少处理时间 ）</li>
<li>使用延迟队列：将不那么紧急的消息放入延迟队列</li>
</ul>
<hr>
<h2 id="黑马点评"><a href="#黑马点评" class="headerlink" title="黑马点评"></a>黑马点评</h2><h3 id="如何在-Java-项目中使用-Redis"><a href="#如何在-Java-项目中使用-Redis" class="headerlink" title="如何在 Java 项目中使用 Redis"></a>如何在 Java 项目中使用 Redis</h3><p>添加 Redis 客户端 Jedis 依赖</p>
<hr>
<h3 id="为什么用Redis替代Session？还有其他解决办法吗？"><a href="#为什么用Redis替代Session？还有其他解决办法吗？" class="headerlink" title="为什么用Redis替代Session？还有其他解决办法吗？"></a>为什么用Redis替代Session？还有其他解决办法吗？</h3><p>Session 有集群共享问题：默认情况下，Session 保存在单个服务器上，当有多个服务器时，Session 信息不能共享，而 Redis 数据共享</p>
<p>Redis 的优点</p>
<ul>
<li>读写速度块（ 基于内存的数据库 ）</li>
<li>保证数据的持久性</li>
<li>丰富的数据结构（ 选用 Hash，因为可以对单个字段进行CRUD，更加灵活 ）</li>
</ul>
<p>其他解决办法：Session拷贝，会导致增加服务器的额外内存开销和数据一致性问题</p>
<hr>
<h3 id="您能详细解释一下如何使用-Redis-实现-Session-共享的吗？"><a href="#您能详细解释一下如何使用-Redis-实现-Session-共享的吗？" class="headerlink" title="您能详细解释一下如何使用 Redis 实现 Session 共享的吗？"></a>您能详细解释一下如何使用 Redis 实现 Session 共享的吗？</h3><p>注册用户时，会生成一个随机的 Token 作为 Key 值存放用户到 Redis 中</p>
<hr>
<h3 id="为什么使用-ThreadLocal-保存用户信息"><a href="#为什么使用-ThreadLocal-保存用户信息" class="headerlink" title="为什么使用 ThreadLocal 保存用户信息"></a>为什么使用 ThreadLocal 保存用户信息</h3><p>线程安全：<strong>避免多线程并发修改问题</strong>，将信息保存到线程内部，保证用户信息一致性</p>
<p>提高性能：第一层拦截器已经将用户信息保存到 ThreadLocal 中，第二层拦截器可以直接使用这些数据，而<strong>不需要重复查询 Redis</strong></p>
<hr>
<h3 id="权限怎么刷新"><a href="#权限怎么刷新" class="headerlink" title="权限怎么刷新"></a>权限怎么刷新</h3><p>也就是如何刷新 Redis 中的 token：EXPIRE、SETEX 命令</p>
<blockquote>
<p>Token：用于身份验证，是后端生成的，要发送给前端。以后每次请求前端要携带 Token </p>
</blockquote>
<hr>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><img src="D:\xmind\Typora\image\屏幕截图 2025-05-15 224105.png" alt="屏幕截图 2025-05-15 224105" style="zoom: 80%;" />

<p>实现复用登录校验和权限刷新的<strong>复用</strong></p>
<hr>
<h3 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h3><p>定义：缓存和数据库中的数据不同步</p>
<p>缓存更新策略</p>
<ul>
<li>内存淘汰：利用 Redis 的内存淘汰机制，当内存不足时自动淘汰部分数据</li>
<li>超时剔除：给缓存增加 TTL 时间，到期后自动删除缓存</li>
<li>主动更新：编写业务逻辑，在修改数据库的同时，更新缓存</li>
</ul>
<p>对于读数据：如果缓存未命中，会从数据库中加载数据到缓存</p>
<p>对于写数据，使用删除缓存模式：更新数据时更新数据库并删除缓存，查询时更新缓存（ 无效写操作较少 ）</p>
<ul>
<li>先删缓存再更新数据库，存在缓存击穿问题</li>
<li>先更新数据库再删缓存，存在脏读现象。</li>
</ul>
<p>将缓存和数据库操作放到同一个事务（ 实现方法：消息队列（ 更新数据库后，将更新缓存的请求发送到消息队列，这样可以异步地更新缓存））来保证原子性</p>
<hr>
<h3 id="缓存穿透、缓存雪崩、缓存击穿"><a href="#缓存穿透、缓存雪崩、缓存击穿" class="headerlink" title="缓存穿透、缓存雪崩、缓存击穿"></a>缓存穿透、缓存雪崩、缓存击穿</h3><p>缓存穿透</p>
<ul>
<li>客户端请求的数据在缓存和数据库中都不存在</li>
<li>解决方法</li>
</ul>
<ol>
<li><p>缓存空对象（ 当查询一个不存在的数据时，可以将这个空结果缓存一段时间 ）</p>
</li>
<li><p>布隆过滤器（ 用于测试一个元素是否存在一个集合中的概率数据结构（ 哈希函数和位数组 ））</p>
</li>
</ol>
<blockquote>
<p>工作原理：使用 N 个哈希函数对数据作哈希运算，得到 N 个哈希值，对位图数组长度取模，得到对应位置并置为 1</p>
<p>它说存在不一定数据库中有（ 哈希冲突 ），它说不存在数据库一定没有</p>
</blockquote>
<p>缓存雪崩</p>
<ul>
<li>同一段时间内，大量的缓存 key 同时失效或 Redis 服务宕机</li>
<li>解决方法</li>
</ul>
<ol>
<li>给不同的 Key 的 TTL 添加随机值（ 固定时间 + 一个范围的随机时间 ）</li>
<li>利用多级缓存 （ 本地缓存 ConcurrentHashMap 和 分布式缓存 Redis ）</li>
</ol>
<p>缓存击穿（ 热点 Key 问题 ）</p>
<ul>
<li>高并发访问的 Key 突然消失</li>
<li>解决方法</li>
</ul>
<ol>
<li>使用互斥锁：控制只有一个请求可以查询数据库并更新缓存，其他请求需要等待（ 避免了大量请求同时访问 ）</li>
<li>合理设置缓存过期时</li>
</ol>
<hr>
<h3 id="您能详细描述一下使用-Redis-实现全局唯一-ID-的过程吗？"><a href="#您能详细描述一下使用-Redis-实现全局唯一-ID-的过程吗？" class="headerlink" title="您能详细描述一下使用 Redis 实现全局唯一 ID 的过程吗？"></a>您能详细描述一下使用 Redis 实现全局唯一 ID 的过程吗？</h3><p>自增 ID 的问题</p>
<ul>
<li>id 的规律过于明显：容易出现信息泄漏</li>
<li>受表单数据量的限制：MySQL 中表能够存储的数据有限，会出现分库分表的情况，<strong>id 不能一直自增</strong></li>
</ul>
<p>时间戳 + 序列号（ 秒内计数器 ） +数据库自增</p>
<p>其他方法：雪花算法</p>
<hr>
<h3 id="乐观锁解决超卖问题"><a href="#乐观锁解决超卖问题" class="headerlink" title="乐观锁解决超卖问题"></a>乐观锁解决超卖问题</h3><ul>
<li>悲观锁：认为线程安全一定会发生，因此操作数据库之前需要先获取锁（ synchronized、lock ）</li>
<li>乐观锁：认为线程安全不一定会发生，不加锁，在更新数据库的时候判断判断有没有其它线程对数据进行修改实现方法：（ 版本号、 CAS ），不安全则抛出异常或中断</li>
</ul>
<ol>
<li>版本号法：新增一个版本号字段，线程 1 在进行库存扣减的同时将版本号 +1，线程 2 在进行扣减操作时，要先判断此时的版本号和查询库存时的版本号是否一致</li>
<li>CAS（ Compare-And-Swap ） 法：使用库存代替版本</li>
</ol>
<blockquote>
<p>读取内存地址 V 的当前值，将当前值与预期值（ 查询时的库存数 ） A 比较，如果当前值等于预期值则将 V 更新为新值 B，否则不进行更新，返回当前值</p>
</blockquote>
<hr>
<h3 id="为什么使用分布式锁"><a href="#为什么使用分布式锁" class="headerlink" title="为什么使用分布式锁"></a>为什么使用分布式锁</h3><p><strong>乐观锁</strong>用于低并发、简单的更新操作中，在涉及多个步骤（ 检查库存、扣减库存 ）时，使用分布式锁来确保这些操作的<strong>互斥性和原子性</strong></p>
<p>分布式锁定义：用于<strong>分布式环境下</strong>并发控制的一种机制，用于控制某个资源在同一时刻只能被一个应用使用</p>
<p>JVM 之间是相互独立的，每个 JVM 中的 synchronized 锁都是局部的、独立的锁。在集群环境中，两个运行在不同 JVM 上的程序无法共享同一个 synchronized 锁，锁失效。</p>
<p>所以需要分布式锁（ 在集群模式下多进程可见并且互斥的锁 ）</p>
<hr>
<h3 id="分布式锁优化"><a href="#分布式锁优化" class="headerlink" title="分布式锁优化"></a>分布式锁优化</h3><p>产生的问题：业务阻塞导致锁的超时释放，而后业务又完成了，释放锁的时候就出现了问题</p>
<p>分布式锁优化 1：产生原因：释放了别人的锁，解决方法：判断这个锁是不是自己的锁</p>
<p>分布式锁优化 2：产生原因：判断是否是锁之后阻塞了，又释放了别人的锁（ 误判 ），解决方法：Lua 脚本（ 保障判断锁和释放锁这段代码的原子性 ）</p>
<p>为什么需要 Lua：解锁有两个操作，先判断该锁是否是加锁客户端，是的话，再将锁删除</p>
<p>Lua 保证原子性的原理：单线程执行，Redis 的事务支持（ Lua 脚本执行期间，Redis 不允许执行其他命令 ）</p>
<hr>
<h3 id="分布式锁为什么使用redisson而不是直接使用SETNX，redisson有什么优势吗？"><a href="#分布式锁为什么使用redisson而不是直接使用SETNX，redisson有什么优势吗？" class="headerlink" title="分布式锁为什么使用redisson而不是直接使用SETNX，redisson有什么优势吗？"></a>分布式锁为什么使用redisson而不是直接使用SETNX，redisson有什么优势吗？</h3><ul>
<li>功能丰富性：Redisson提供可重入锁（ 锁以 hash 结构存储在 Redis 中，每次获取锁 value 值 +1，释放锁 value 值 -1，当 value 值为 0 时才真正释放锁）、公平锁等，SETNX 不可重入（ 同一线程不能重复获取<strong>同一把锁</strong> ）</li>
</ul>
<blockquote>
<p>不可重入导致死锁：方法 A 中调用方法 B，方法 A、B 都要获取分布式锁（ 同一把锁 ），线程 1 进入方法 A 获取了一次锁，进入方法 B 又获取一次锁，由于锁不可重入，所以会导致死锁</p>
<p>SETNX：键不存在时才插入</p>
</blockquote>
<ul>
<li>自动续约功能：Redisson 在锁持有期间<strong>自动续约</strong>，确保锁不会过期</li>
<li>SETNX 不可重试，失败了就返回 false，Redisson 的 <strong>tryLock</strong>方法有<strong>超时释放机制和等待机制</strong></li>
<li>简洁 API：提供了简洁易用的 API，无需关心底层的 Redis 命令</li>
</ul>
<hr>
<h3 id="基于-Stream-结构实现消息队列（-异步秒杀优化-）"><a href="#基于-Stream-结构实现消息队列（-异步秒杀优化-）" class="headerlink" title="基于 Stream 结构实现消息队列（ 异步秒杀优化 ）"></a>基于 Stream 结构实现消息队列（ 异步秒杀优化 ）</h3><p>为什么要消息队列？将一个同步的程序变成两个异步的程序，其中一个程序读取另一个程序中放到消息队列中的数据，实现了效率提高</p>
<p>将判断秒杀库存和校验一人一单放进 Redis 里查询，并将优惠卷、用户id、订单 id 保存到阻塞队列，而后查询优惠卷、查询订单等操作可以异步去从队列中读取，实现了优化</p>
<img src="D:\xmind\Typora\image\屏幕截图 2025-05-19 202339.png" alt="屏幕截图 2025-05-19 202339" style="zoom: 67%;" />

<hr>
<h3 id="在实现异步秒杀下单时，您是如何保证消息的可靠性和一致性的？"><a href="#在实现异步秒杀下单时，您是如何保证消息的可靠性和一致性的？" class="headerlink" title="在实现异步秒杀下单时，您是如何保证消息的可靠性和一致性的？"></a>在实现异步秒杀下单时，您是如何保证消息的可靠性和一致性的？</h3><hr>
<h3 id="如何用-redis-的-Sortedset做排行榜？"><a href="#如何用-redis-的-Sortedset做排行榜？" class="headerlink" title="如何用 redis 的 Sortedset做排行榜？"></a>如何用 redis 的 Sortedset做排行榜？</h3><p>它能够存储唯一的元素，并且每个元素都有一个分数，可以根据这个分数进行排序</p>
<ul>
<li><strong>ZADD</strong> leaderboard 用户ID 得分：将用户得分添加到 SortedSet 中</li>
<li><strong>ZRANGE</strong> leaderboard 0 N-1 WITHSCORES：升序返回前 N 名，<strong>ZREVRANK</strong> 降序</li>
<li><strong>ZREM</strong> leaderboard 用户ID：移除某个用户</li>
</ul>
<hr>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring-中的事务如何实现"><a href="#Spring-中的事务如何实现" class="headerlink" title="Spring 中的事务如何实现"></a>Spring 中的事务如何实现</h3><p>事务管理的两种方式</p>
<ol>
<li><p>编程式事务管理：手动控制事务的开始、提交和回滚</p>
</li>
<li><p>声明式事务管理：通过注解，Spring 会为目标类创建一个代理对象，通过 JDK 动态代理：程序运行时生成一个新的对象，作用：对这个新的对象操作的时候就可以把操作传给被注释的对象</p>
</li>
<li><p>事务管理的<strong>原理</strong></p>
<p>AOP（ 面向切面编程 ），切面包括切入点和通知</p>
<p>切入点：程序执行的一个特定位置，例如：方法的调用或异常的抛出</p>
<p>通知：在切入点上执行的动作或逻辑，在目标方法的不同阶段插入自定义行为</p>
</li>
</ol>
<hr>
<h3 id="springboot-的-bean-创建方式"><a href="#springboot-的-bean-创建方式" class="headerlink" title="springboot 的 bean 创建方式"></a>springboot 的 bean 创建方式</h3><ul>
<li><p>Bean 的定义：由 Spring IoC 容器管理的对象，可以是任何一个类的实例</p>
</li>
<li><p>基于注解：</p>
<ol>
<li>@Component（ 标记一个类为 Spring 管理的 Bean）</li>
<li>@Service、@Reposity、@Controller 是 Component 的变种，标识服务层、数据访问层、控制层的 Bean</li>
</ol>
</li>
<li><p>基于 Java 配置类声明：@Configuration（ 类可以定义 Bean ） + @Bean（ 显示定义 Bean ）</p>
</li>
<li><p>基于 XML 配置</p>
</li>
</ul>
<hr>
<h3 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h3><ul>
<li>实例化（ @Component ）</li>
<li>属性注入（ @Autowired ）</li>
<li>BeanPostProcessor 的前置处理：Bean 初始化前，Spring 会调用实现了 <code>BeanPostProcessor</code> 接口的 <code>postProcessBeforeInitialization()</code> 方法，允许对 Bean 进行自定义修改</li>
<li>初始化</li>
</ul>
<ol>
<li>使用 @PostConstruct 注解：在方法上添加 @ PostConstruct 注解，Spring 会在依赖注入完成后调用该方法</li>
<li>实现 InitializingBean 接口，并重写 afterPropertiesSet 方法</li>
<li>配置 init-method</li>
</ol>
<ul>
<li>销毁（ @PreDestroy ）</li>
</ul>
<hr>
<h3 id="IoC（-Inversion-of-Control-）"><a href="#IoC（-Inversion-of-Control-）" class="headerlink" title="IoC（ Inversion of Control ）"></a>IoC（ Inversion of Control ）</h3><p>控制反转：将对象的控制权交给外部容器（ IoC 容器 ），是一种设计思想</p>
<p>好处：减少组件之间的耦合，提高可测试性（ 可以轻松模拟对象来代替真实对象 ）</p>
<h4 id="IoC-的实现方式：-DI"><a href="#IoC-的实现方式：-DI" class="headerlink" title="IoC 的实现方式： DI"></a>IoC 的实现方式： DI</h4><p>依赖注入（ Dependency Injection ）：通过将目标对象依赖的其他对象（ 依赖对象 ）在运行时注入到对象中</p>
<p>实现方法：</p>
<ul>
<li>构造函数注入：通过构造函数将依赖对象传递给目标对象</li>
<li>方法注入：调用方法时传递依赖项</li>
<li>字段注入：通过直接在字段上使用 @Autowired 注解进行注入（ 自动装配：Spring 框架提供的一个功能，框架能够自动识别并注入依赖对象，无需手动配置 ）</li>
</ul>
<hr>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>面向切面编程（ Aspect-Oriented Programming ）：是一种编程范式，用于将跨越多个模块的关注点（ 如日志、事务管理、安全等 ）从业务逻辑中分离出来，以提高代码的模块化和可维护性</p>
<ul>
<li>横切关注点：多个类或对象中的公共行为（ 如日志记录、事务管理等 ）</li>
<li>切面：对横切关注点进行封装的类，用来实现具体的功能</li>
<li>连接点：程序执行中的一个点（ 如方法调用、对象创建 ）</li>
<li>通知：切面在某个连接点要执行的操作（ 前置、后置、环绕 ）</li>
<li>切点：定义了哪些连接点上应用切面</li>
<li>织入：将切面代码与业务逻辑代码结合的过程</li>
</ul>
<p><strong>原理</strong>：动态代理（ 在运行时创建代理对象的技术，代理对象可以拦截对目标方法的调用，并在调用之前或之后执行一些额外的操作 ）</p>
<ul>
<li><p>基于 JDK 的动态代理：是基于<strong>接口</strong>的代理方式，利用<strong>反射</strong>机制，在运行时创建一个实现了目标队形所实现的所有接口的代理对象，当调用代理对象的方法时，会触发 <code>InvocationHandler</code> 的 <code>invoke</code> 方法，在这个方法中可以添加额外的逻辑，从而实现对目标方法的增强</p>
</li>
<li><p>基于 CGLIB( Code Genertion Library ) 的动态代理：使用 CGLIB 库来创建代理对象，代理对象<strong>继承</strong>了目标对象，通过方法拦截来实现代码逻辑。</p>
</li>
</ul>
<hr>
<h3 id="Sprng-MVC"><a href="#Sprng-MVC" class="headerlink" title="Sprng MVC"></a>Sprng MVC</h3><p>是一个基于 Java 的框架，是 Spring 框架的一部分，用于构建 Web 应用程序，它遵循 MVC（ Model-View-Controller ）设计模式，旨在分离应用程序的不同关注点。与 SpringBoot 的区别是配置较麻烦，需要手动添加依赖，且没有内置的 Tomcat 服务器</p>
<ul>
<li>Model（ 模型 ）：代表应用程序的数据和业务逻辑，对应于数据库中的实体类</li>
<li>View（ 视图 ）：负责呈现数据给用户</li>
<li>Controller（ 控制器 ）：用于处理用户请求，调用相应的服务处进行业务处理，并返回视图</li>
</ul>
<hr>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a>TCP三次握手过程</h3><ul>
<li>一开始，客户端和服务端都处于 CLOSE 状态，先是服务端主动监听某个端口，处于 LISEN 状态</li>
<li>第一次握手：客户端向服务器发送一个 <strong>SYN</strong> 报文，报文中包含客户端的初始序列号，表示客户端请求连接，之后客户端处于 SYN-SENT 状态</li>
<li>第二次握手：服务端向客户端发送一个 <strong>SYN-ACK</strong> 报文。报文中包含服务器的初始序列号，确认应答号中是<code>客户端序列号 + 1</code>。之后服务端处于 *YN-RCVD 状态</li>
<li>第三次握手：客户端向服务端发送 <strong>ACK</strong> 报文，报文中的确认应答号为<code>服务端序列号 + 1</code>，可以携带客户端数据到服务端，之后客户端处于 ESTABLISHED 状态</li>
<li>服务端就受到客户端的应答报文后，也进入 ESTABLISHED 状态</li>
</ul>
<hr>
<h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><ul>
<li>第一次挥手：客户端发送一个 <strong>FIN</strong>（ 表示它已经没有数据要发送 ）报文给服务器，，但仍可以接收数据</li>
<li>第二次挥手：服务器发送一个 <strong>ACK</strong> 报文给客户端（ 表示收到了客户端的关闭请求 ），此时服务器可能还有数据需要发送，所以不会立刻关闭</li>
<li>第三次挥手：服务器数据全部发送完成，发送 FIN 报文给客户端，表示它也没有数据需要发送了，准备关闭连接</li>
<li>第四次挥手：客户端发送 ACK 报文给服务器。服务器收到 ACK 后就 CLOSE，客户端经过 2MSL（ MSL：报文最大生存时间，确保即使有延迟的报文段在网络中，也会在这段事件被丢弃，<strong>从而不会干扰到新连接</strong> ） 后 CLOSE</li>
</ul>
<hr>
<h3 id="打开页面的全过程"><a href="#打开页面的全过程" class="headerlink" title="打开页面的全过程"></a>打开页面的全过程</h3><hr>
<h3 id="HTTP-和-HTTPS的区别是什么？"><a href="#HTTP-和-HTTPS的区别是什么？" class="headerlink" title="HTTP 和 HTTPS的区别是什么？"></a>HTTP 和 HTTPS的区别是什么？</h3><ul>
<li>HTTPS 在传输层和网络层之间加入了 SSL&#x2F;TLS 协议，使得报文能够加密传输</li>
<li>HTTP 80、HTTPS 443</li>
<li>HTTPS 协议需要向 CA（ 证书权威机构 ）申请数字证书，来保证服务器的身份是可信的</li>
</ul>
<hr>
<h3 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h3><p>轻量级（ 为低带宽、不可靠网络设计 ）消息传输协议，多用于物联网设备之间的通信</p>
<p>发布&#x2F;订阅模式</p>
<ul>
<li>发布：客户端通过MQTT代理（ Mosquitto ）向特定的主题发送消息</li>
<li>订阅：客户端向MQTT代理（ Mosquitto ）请求接受特定主题消息</li>
<li>MQTT 提供三种 QoS（服务质量）等级</li>
</ul>
<ol>
<li>QoS 0：至多一次，可能丢失</li>
<li>QoS 1：至少一次，确保消息被送达，但可能重复</li>
<li>QoS 2：只有一次，确保消息被唯一地送达</li>
</ol>
<p>Eclipse Paho：一个用于实现 MQTT 协议的开源项目</p>
<hr>
<h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><ul>
<li>连接：TCP 传输前需要连接，UDP 不需要连接</li>
<li>服务对象：TCP 是一对一，UDP支持一对一、一对多（ 广播 ）、多对多</li>
<li>可靠性：TCP 可靠交付数据，UDP 尽最大努力，不保证可靠交付数据，但是可以在其基础上设计一个可靠传输协议 QUIC</li>
</ul>
<blockquote>
<p>连接管理：三次握手</p>
<p>超时重传</p>
<p>流量控制：为了防止接收方溢出，实现方式：滑动窗口</p>
<p>拥塞控制：为了防止网络拥塞，实现方式：慢开始、拥塞避免、快重传、快恢复</p>
</blockquote>
<ul>
<li>使用场景：TCP（ Web浏览、远程登录 ）、UDP（ 视频会议 ）</li>
</ul>
<hr>
<h3 id="HTTP1-0到3-0的版本更新所带来的新特性"><a href="#HTTP1-0到3-0的版本更新所带来的新特性" class="headerlink" title="HTTP1.0到3.0的版本更新所带来的新特性"></a>HTTP1.0到3.0的版本更新所带来的新特性</h3><ul>
<li>HTTP&#x2F;1.1</li>
</ul>
<ol>
<li>持久连接：允许多个请求通过同一个 TCP 连接</li>
<li>管道化：允许在一个连接上并行发送多个请求（ 只要第一个请求发出，不必等待其回来就可以发送第二个请求 ），缺点：如果一个请求阻塞，多个请求统统阻塞</li>
</ol>
<ul>
<li>HTTP&#x2F;2</li>
</ul>
<ol>
<li>头部压缩：通过 HPACK 算法（ 在客户端和服务器同时维护一张头信息表，字段会对应索引号，以后发送时就发送个索引号 ）进行头部压缩，减少了请求和响应的头部的大小</li>
<li>二进制分帧：将数据分割成更小的二进制帧（ 而不是纯文本形式的报文 ）</li>
<li>优先级：允许客户端为请求设置优先级</li>
<li>多路复用：同一连接上并行处理多个请求和响应，消除了对头阻塞问题（ HTTP&#x2F;1.1 的串行请求 ）</li>
</ol>
<blockquote>
<p>串行请求：一次处理一个，处理完这个再处理下一个</p>
<p>并行处理：处理 A，发现 A 很耗时，先把处理过的返回 A，去执行 B，B 处理完后再处理 A</p>
</blockquote>
<ol start="5">
<li>缺点：多个 HTTP 复用一个连接，下层 TCP 协议不知道有多少个 HTTP 请求，会导致一旦发生丢包现象，所有的 HTTP 请求都必须等待这个丢了的包被重传</li>
</ol>
<ul>
<li>HTTP&#x2F;3</li>
</ul>
<ol>
<li>使用 QUIC（ 基于 UDP ） 作为传输层协议，好处：UDP 不管顺序和丢包，所以不会出现 HTTP&#x2F;1.1 的对头阻塞和 HTTP&#x2F;2 的一个丢包全部重传问题</li>
</ol>
<hr>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="协程是什么？有什么好处？"><a href="#协程是什么？有什么好处？" class="headerlink" title="协程是什么？有什么好处？"></a><strong>协程是什么？有什么好处？</strong></h3><ul>
<li>极高的性能：切换开销非常小（ 无需进行内核级的上下文切换 ）</li>
</ul>
<hr>
<h3 id="介绍一下操作系统的虚拟内存？"><a href="#介绍一下操作系统的虚拟内存？" class="headerlink" title="介绍一下操作系统的虚拟内存？"></a>介绍一下操作系统的虚拟内存？</h3><hr>
<h3 id="进程通信方式你知道哪些？"><a href="#进程通信方式你知道哪些？" class="headerlink" title="进程通信方式你知道哪些？"></a>进程通信方式你知道哪些？</h3><ul>
<li>管道</li>
<li>消息队列</li>
<li>共享内存</li>
</ul>
<hr>
<h2 id="进程、线程、协程的区别"><a href="#进程、线程、协程的区别" class="headerlink" title="进程、线程、协程的区别"></a>进程、线程、协程的区别</h2><ul>
<li>进程：是正在执行的程序的一个实例，操作系统中资源分配的基本单位，每个进程有独立的内存，由操作系统调度。使用场景：CPU密集型任务</li>
<li>线程：进程中的一个执行单元，共享同一进程的资源和内存，由操作系统调度，并发执行的任务。</li>
</ul>
<ol>
<li>轻量级：线程的上下文切换涉及的状态信息较少（ 主要是 CPU 寄存器和栈指针等 ）</li>
<li>创建开销小：只需要在进程的内存空间中分配少量的栈空间</li>
</ol>
<ul>
<li>协程：是一种用户态的<strong>轻量级</strong>（ 无需进行内核级的上下文切换 ）线程，调度由<strong>程序自身控制</strong>，不需要内核参与。使用场景：I&#x2F;O密集型任务（ 单个线程可以运行多个协程 ）</li>
</ul>
<hr>
<h3 id="IO多路复用是什么"><a href="#IO多路复用是什么" class="headerlink" title="IO多路复用是什么"></a>IO多路复用是什么</h3><p>允许程序在单一线程中同时监控多个IO流</p>
<blockquote>
<p>IO 操作：计算机系统和外部设备进行数据交换的过程</p>
</blockquote>
<hr>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="如何查看进程号状态"><a href="#如何查看进程号状态" class="headerlink" title="如何查看进程号状态"></a>如何查看进程号状态</h3><p><code>ps aux</code> ：显示所有用户进程</p>
<p><code>ps -ef | grep</code>：查找特定进程</p>
<p><code>top</code></p>
<hr>
<h3 id="查看线程"><a href="#查看线程" class="headerlink" title="查看线程"></a>查看线程</h3><p><code>top -H</code></p>
<p><code>ps -T -p 1234</code></p>
<hr>
<h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><p><code>ls</code> ：列出目录内容</p>
<p><code>cd</code>：更改当前目录</p>
<p><code>mv</code>：移动文件</p>
<p><code>rm</code>：删除文件</p>
<p><code>mkdir</code>：创建信目录</p>
<p><code>touch</code>：创建空文件</p>
<hr>
]]></content>
  </entry>
</search>
