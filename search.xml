<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo个人博客搭建</title>
    <url>/2025/04/05/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="Hexo个人博客搭建"><a href="#Hexo个人博客搭建" class="headerlink" title="Hexo个人博客搭建"></a>Hexo个人博客搭建</h1><ol>
<li><p>安装 Node.js</p>
</li>
<li><p>配置镜像源</p>
</li>
</ol>
<p><code>npm install -g cnpm --registry=https://registry.npmmirror.com</code></p>
<ol start="3">
<li>安装 Hexo</li>
</ol>
<p><code>cnpm install -g hexo-cli</code>  </p>
<ol start="4">
<li>新建个文件夹，在命令行中执行</li>
</ol>
<p><code>hexo init</code></p>
<ol start="5">
<li>命令</li>
</ol>
<p><code>hexo s（start）</code>：启动hexo，在浏览器预览一下</p>
<p><code>hexo n（new） &quot;xx&quot;</code>： 新建一个名子为xx帖子 </p>
<p>在 <code>D:\Blog\source\_posts</code> 中用Vscode打开，并编辑内容  </p>
<blockquote>
<p>编辑时有 syntax 格式</p>
<blockquote>
<p>键值对中间必须有空格</p>
</blockquote>
</blockquote>
<p><code>hexo clean</code>：清理（ 更新博客时不能省略这个步骤 ）</p>
<p><code>hexo g (generate)</code>：生成</p>
<hr>
<h1 id="将博客部署到Github上"><a href="#将博客部署到Github上" class="headerlink" title="将博客部署到Github上"></a>将博客部署到Github上</h1><ol>
<li>在<code>Github</code>中创建一个新仓库</li>
</ol>
<blockquote>
<p>仓库名字有要求：<code>yanwuuu.github.io</code>  仓库名需要<strong>全小写</strong></p>
<p>以后访问博客即可通过这个名字访问</p>
</blockquote>
<hr>
<ol start="2">
<li>在创建的文件夹的命令行中，安装<code>hexo-deployer-git</code></li>
</ol>
<p><code>cnpm install --save hexo-deployer-git</code></p>
<hr>
<ol start="3">
<li>修改<code>_config.yml</code>文件</li>
</ol>
<blockquote>
<p>文件底部</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: https://github.com/YanWuuu/YanWuuu.github.io.git  // Github仓库的地址</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></blockquote>
</blockquote>
<hr>
<ol start="4">
<li><code>hexo d</code>：部署到远端（不能使用加速器）</li>
</ol>
<blockquote>
<p>如果在本地不使用加速器不能访问Github的话，也会导致失败</p>
<p>玄学：可以先开加速器访问一下，再关掉，可能就可以访问了</p>
</blockquote>
<hr>
<h2 id="配置到云服务器"><a href="#配置到云服务器" class="headerlink" title="配置到云服务器"></a>配置到云服务器</h2><p>在云服务器上也是类似于本地电脑上的安装，但是多了 Nginx 的配置操作（ 通过 Nginx 可以将请求定位到某个文件夹中 ）</p>
<p>注意要路径选择 &#x2F;blog&#x2F;public，这个文件及里才有 index.html</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root /var/www/html;</span><br><span class="line"></span><br><span class="line"># Add index.php to the list if you are using PHP</span><br><span class="line">index index.html index.htm index.nginx-debian.html;</span><br><span class="line"></span><br><span class="line">server_name _;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">        # First attempt to serve request as file, then</span><br><span class="line">        # as directory, then fall back to displaying a 404.</span><br><span class="line">        try_files $uri $uri/ =404;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /pdf/ &#123;</span><br><span class="line">        root /var/www/;  // 会在 /var/www/pdf 中查找，类似于拼接</span><br><span class="line">        try_files $uri $uri/ =404;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /blog/public（ 浏览器发送请求的 url ） &#123;</span><br><span class="line">        alias /var/www/blog/public;  // /blog/public 路径被重定向到 /var/www/blog/public</span><br><span class="line">        try_files $uri $uri/ =404;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>学到了：可以通过浏览器的控制台看错误</p>
<p>linux命令：mv 当前路径 指定路径</p>
<p>为解决的问题：请求 css 文件的路径不对，导致页面上没有样式</p>
<h1 id="更换Hexo主题"><a href="#更换Hexo主题" class="headerlink" title="更换Hexo主题"></a>更换Hexo主题</h1><p>博主地址：github.com&#x2F;litten&#x2F;hexo-theme-yilia </p>
<p>有些文件要以管理员身份才可以修改，所以需要以管理员方式打开记事本</p>
<blockquote>
<ol>
<li><p>先以管理员方式打开命令行</p>
</li>
<li><p>notepad C:\Windows\System32\drivers\etc\hosts</p>
</li>
</ol>
</blockquote>
<p>克隆代码</p>
<p><code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia(克隆到的本地位置)</code></p>
<p>修改_config.yml文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: yilia //改动的地方</span><br></pre></td></tr></table></figure>

<p><strong>更新之后显示界面会有点慢，别着急</strong>   </p>
<hr>
<h1 id="更改主题样式"><a href="#更改主题样式" class="headerlink" title="更改主题样式"></a>更改主题样式</h1><p>在<code>themes</code>中更改克隆主题的配置文件</p>
<p>最新用的是 Nex T主题</p>
<hr>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul>
<li><p>Vue语法的代码，不能写在代码块中，markdown会渲染（我只想静态的显示代码而已）</p>
</li>
<li><p>npm 报错 <code>npm ERR! Cannot read properties of null (reading &#39;isDescendantOf&#39;)</code></p>
</li>
</ul>
<p>解决办法：<strong>使用cnpm</strong></p>
<ul>
<li>使用 Google Chrom 去预览效果</li>
</ul>
]]></content>
      <tags>
        <tag>安装 Node.js</tag>
        <tag>配置镜像源</tag>
        <tag>安装 Hexo</tag>
        <tag>启动 Hexo</tag>
        <tag>部署到 Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Hot 100</title>
    <url>/2025/06/01/Hot-100/</url>
    <content><![CDATA[<h1 id="LeetCode-Hot-100"><a href="#LeetCode-Hot-100" class="headerlink" title="LeetCode Hot 100"></a>LeetCode Hot 100</h1><h2 id="0-方法论"><a href="#0-方法论" class="headerlink" title="0 方法论"></a>0 方法论</h2><ul>
<li>解题核心</li>
</ul>
<ol>
<li>问题建模</li>
</ol>
<blockquote>
<p>定义：将实际问题或抽象的题目，转化为<strong>计算机</strong>可以理解并解决<strong>的数学模型或数据结构</strong>的过程</p>
<p>核心：从问题的描述中提炼出核心要素，并选择合适的**数据结构（ 抽象 ） + 算法（ 解决特定问题的步骤或规则 ）**来解决问题（ 用什么数据结构去实现解题的算法 ）</p>
<blockquote>
<p>问题建模步骤：</p>
<ol>
<li>分析题意：理解要求的是什么，输入是什么，输出是什么（需不需要新建一个数据结构来当作答案）</li>
<li>提取关键数据：把题目中提到的<strong>各种元素提取出</strong>来进行<strong>抽象</strong>（1.根据要求的问题往深看一层，看到本质 2.借助什么把这个本质表示出来），思考这些元素如何<strong>组合</strong>在一起</li>
<li>选择合适的模型（复杂的问题或降低复杂度）：数据结构＋算法（dp，贪心等，且一个根据题意列出来的方程式也算是一个算法）</li>
</ol>
<blockquote>
<p>如何选择合适的数据结构？</p>
<p>在写题时去总结某种数据结构的使用场景，去想为什么使用它好 ？</p>
<p>算法：为了求解出答案想出来的方法</p>
</blockquote>
</blockquote>
</blockquote>
<ol start="2">
<li>多去思考：Why it work </li>
<li>思路是对的，代码写出来？有需要抽象的没有抽象出来</li>
<li>算法：</li>
</ol>
<ul>
<li>双指针</li>
<li>滑动窗口</li>
<li>前缀和、前缀后缀积</li>
<li>递归</li>
</ul>
<hr>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>为什么使用哈希表：</p>
<ul>
<li>时间复杂低：查找和判断键是否存在的复杂度为 O(1)</li>
<li>避免多次遍历重复的值：将遍历过一次之后的值放入表中，后续只需要判断这个值在不在表中即可</li>
<li>可以根据特征归类：将键用特征表示即可</li>
</ul>
<p>键（ 用来查找的 ）是什么？值（ 真正需要的 ）又是什么？</p>
<p>HashSet 仅用来查找</p>
<hr>
<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1 两数之和"></a>1 两数之和</h2><p><strong>哈希表</strong></p>
<ul>
<li>作用：作为一种存储，此题中的使用场景：<strong>可以根据元素值找下标</strong></li>
<li>本质：键和值有一个函数关系，被称为哈希函数。键输入到哈希函数中，值输出。</li>
<li>C++ 中使用 <code>unordered_map</code>和 <code>map</code>表示哈希表</li>
</ul>
<blockquote>
<p>如果使用 .find() 方法没找到，则会返回 end()</p>
<p>迭代器 -&gt;first 取得是键，迭代器-&gt;second取得是值 </p>
</blockquote>
<p>Why it work：</p>
<p>为什么相较暴力法降低了复杂度 ?：哈希表将某个元素存进去了，不用像暴力法一样每次都要再取一遍</p>
<p>此题的算法是我根据问题建模第二步的组合，列出来的方程式</p>
<p>方法</p>
<ul>
<li>HashMap.containsKey：判断键是否存在</li>
<li>HashMap.put：将键值推进哈希表</li>
<li>HashMap.get：根据键返回值</li>
<li>返回一个之前没有的数组，return new int[] { x, x } 即可&#x2F; return new int[0]：返回长度为 0 的整型数组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (hashtable.containsKey(target - nums[i])) &#123;</span><br><span class="line">                return new int[] &#123; hashtable.get(target - nums[i]), i &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        return new int[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="2-字母异位词"><a href="#2-字母异位词" class="headerlink" title="2 字母异位词"></a>2 字母异位词</h2><ul>
<li>哈希表使用场景：需要根据特征进行归类（ 这个总结是经验，如何选择合适的数据结构 ），然后通过这个特征去拿到想要的值</li>
<li>问题建模：</li>
<li>算法：不同的异位词排序后是一样的，将排序过后的作为键</li>
</ul>
<blockquote>
<p>将要求结果的特征进行抽象</p>
</blockquote>
<ul>
<li>存储到哈希表（ 数据结构 ）</li>
</ul>
<p>方法</p>
<ul>
<li>HashMap.getOrDefault(key, new ArrayList<String>())：查找键返回值，没查到则返回第二个参数</li>
<li>HahsMap.values()：用于获取所有值的集合</li>
<li>char[] array &#x3D; String.toCharArray()：将字符串转换为字符数组</li>
<li>Arrays.sort()</li>
</ul>
<hr>
<h2 id="3-最长连续序列"><a href="#3-最长连续序列" class="headerlink" title="3 最长连续序列"></a>3 最长连续序列</h2><p>使用哈希表将要找的元素存储起来，这样查找一个数的复杂度就是 O(1)</p>
<p>数据结构：HashSet：只存储值，适用于检查元素是否存在</p>
<p>方法</p>
<ul>
<li>HashSet.contains()：判断 HashSet 中是否有这个元素</li>
<li>HashSet.add()</li>
</ul>
<hr>
<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>广义上的算法（ 解决某种问题的<strong>特定步骤</strong> ），我们需要想办法去实现它：在指针的移动中穿插我的解题算法思路</p>
<p>Why it work？因为要分<strong>两部分</strong>？</p>
<hr>
<h2 id="4-移动零"><a href="#4-移动零" class="headerlink" title="4 移动零"></a>4 移动零</h2><p><strong>双指针</strong>（ 算法 ）之快慢指针</p>
<p>此题：使用两个指针，从左往右，一个快（默认向右移动），一个慢（快指针遇到某种情况时才移动）</p>
<p>作用：可以控制顺序（因为慢指针都走过了的地方就是排好了的）</p>
<p>指针使用场景：题目中对结果或解题条件中有<strong>限制条件</strong></p>
<hr>
<h2 id="5-盛最多水的容器"><a href="#5-盛最多水的容器" class="headerlink" title="5 盛最多水的容器"></a>5 盛最多水的容器</h2><p>双指针之<strong>左右两边</strong></p>
<p>双指针的关键是：某个条件时才移动指针（ 算法 ），此题是左右两边哪边先移动  </p>
<p>此题的抽象：<strong>短的边决定了最大容量</strong></p>
<blockquote>
<p>应为短的边先移动，因为短的边决定了最后的结果</p>
</blockquote>
<p>方法</p>
<ul>
<li>Math.min&#x2F;max</li>
</ul>
<hr>
<h2 id="6-三数之和"><a href="#6-三数之和" class="headerlink" title="6 三数之和"></a>6 三数之和</h2><p>双指针，去重</p>
<p>利用排序，就可以根据 Sum 的大小，移动指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] &gt; 0) &#123;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int left = i + 1;</span><br><span class="line">            int right = nums.length - 1;</span><br><span class="line">            while (right &gt; left) &#123;</span><br><span class="line">                int sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                if (sum &gt; 0) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; else if (sum &lt; 0) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span><br><span class="line">                    while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span><br><span class="line"></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法</p>
<ul>
<li><p>Arrays.asList(nums[i], nums[left], nums[right])：将参数转换为列表对象</p>
</li>
<li><p>Arrays.sort()：排序</p>
</li>
</ul>
<hr>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>适用于</p>
<ol>
<li>某部分可以<strong>复用</strong></li>
<li><strong>滑动 + 窗口里面的逻辑</strong>来实现我的算法</li>
</ol>
<h2 id="8-无重复字符的最长子串"><a href="#8-无重复字符的最长子串" class="headerlink" title="8 无重复字符的最长子串"></a>8 无重复字符的最长子串</h2><p><strong>滑动窗口</strong>（ 算法 ）之快慢指针，用指针来滑动窗口 + unordered_set（ 数据结构 ）</p>
<p>why it work：当某个子串在加了某个值重复了，中间是可以<strong>复用</strong>的，滑动窗口就刚好符合这个特性，之前的还可以用，只需要再往下找就行</p>
<p>用到了 unordered_set，只看值，不看键</p>
<blockquote>
<p>.count()方法：计算特定元素的出现次数</p>
</blockquote>
<p>方法</p>
<ul>
<li>String.charAt()：将参数位置转换为 char</li>
</ul>
<hr>
<h2 id="9-找到字符串中所有字母异位词"><a href="#9-找到字符串中所有字母异位词" class="headerlink" title="9 找到字符串中所有字母异位词"></a>9 找到字符串中所有字母异位词</h2><p>滑动窗口和比较窗口和 p 中的元素数量（ 算法 ） + 数组 （ 数据结构 ）</p>
<p>why it work：需要进行比较的就是一个窗口（ 有多个元素 ）</p>
<p>滑动窗口性质：进一个出一个来代表滑动，窗口中的东西用另一种算法去抽象（ 这里是窗口中元素的数量 ）</p>
<p>问题建模：找异位词  &#x3D;&#x3D;&gt;   比较数组存放窗口中每种字母的数量。通过改变数组来移动窗口</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">++sCount[s[i] - <span class="string">&#x27;a&#x27;</span>]  <span class="comment">// a 的索引是 0</span></span><br></pre></td></tr></table></figure></blockquote>
<p>方法</p>
<ul>
<li>ArrayList.add()</li>
<li>Arrays.equals()</li>
</ul>
<hr>
<h1 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h1><h2 id="10-和为K的子数组"><a href="#10-和为K的子数组" class="headerlink" title="10 和为K的子数组"></a>10 和为K的子数组</h2><ol>
<li>枚举法，时间复杂度O(n²)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int subarraySum(int[] nums, int k) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for (int j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                if (sum == k) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><strong>前缀和</strong>（算法）+哈希表（数据结构）</li>
</ol>
<ul>
<li><p>前缀和：作用：降低复杂度，快速计算<strong>任意子数组</strong>的和，时间复杂度是 O(1），一般的枚举法，需要O(n²)。因为可以通过<code>sum(nums[j..i]) = pre[i] - pre[j-1]</code> 来计算</p>
</li>
<li><p>哈希表：作用：1. <strong>快速</strong>判断是否存在符合条件的前缀和  2. 还可以保存一个与这个键（特征）有关系的值</p>
</li>
</ul>
<blockquote>
<p>哈希表提供了<strong>常数时间</strong>的查找和插入操作</p>
</blockquote>
<p>解题思路：先建模（算法能力，数学能力）再将抽象用 code（代码能力，数据结构或其他的）表示</p>
<blockquote>
<p>算法能力：问题建模，目标函数</p>
</blockquote>
<hr>
<h1 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h1><h2 id="13-最大子数组和"><a href="#13-最大子数组和" class="headerlink" title="13 最大子数组和"></a>13 最大子数组和</h2><p>问题建模：</p>
<ol>
<li><p>核心要素：子串和</p>
</li>
<li><p><strong>动态规划</strong>（算法）</p>
</li>
<li><p>思路：找出每个位置的子数组最大和，再返回每个位置中的最大值</p>
</li>
</ol>
<p>Why it work？</p>
<hr>
<h2 id="14-合并区间"><a href="#14-合并区间" class="headerlink" title="14 合并区间"></a>14 合并区间</h2><p>我想到了比较的方法（算法），但是没有考虑特殊情况（ intervals是无序的 ），而且前后都需要比较</p>
<p>改进：sort可以解决这两个问题，因为排序之后前面的 L 一定比后面的 L 小，只需要更新结果中的 R</p>
<p>方法</p>
<ul>
<li>Arrays.sort()：参数为一维数组，默认从小到大。自定义情况（ 因为这里是二维数组 ）需要用Comparator接口实现自定义排序规则，例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123;</span><br><span class="line">           public int compare(int[] interval1, int[] interval2) &#123;</span><br><span class="line">               return interval1[0] - interval2[0]; // 左减右大于 0 ，左在后</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>ArrayList.toArray( new int [merged.size()] [] )：将列表元素转换为一个数组</li>
<li>List.size()，没有 List.length</li>
</ul>
<hr>
<h2 id="15-轮转数组"><a href="#15-轮转数组" class="headerlink" title="15 轮转数组"></a>15 轮转数组</h2><p>新建一个数据结构来保存最后的答案</p>
<p>方法</p>
<ul>
<li>System.arraycopy( newArr, 0, nums, 0, n )：从一个源数组复制元素到另一个目标数组中</li>
</ul>
<hr>
<h2 id="16-除自身以外数组的乘积"><a href="#16-除自身以外数组的乘积" class="headerlink" title="16 除自身以外数组的乘积"></a>16 除自身以外数组的乘积</h2><p>算法：<strong>前缀后缀</strong>乘积</p>
<blockquote>
<p>前缀乘积的实现：本质：每次多乘一个数，所以就可以把每次前缀存着，然后再乘一个数</p>
</blockquote>
<p>why it work：空间换时间</p>
<hr>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="18-矩阵置零"><a href="#18-矩阵置零" class="headerlink" title="18 矩阵置零"></a>18 矩阵置零</h2><p>算法√，使用标记数组去实现</p>
<hr>
<h2 id="19-螺旋矩阵"><a href="#19-螺旋矩阵" class="headerlink" title="19 螺旋矩阵"></a>19 螺旋矩阵</h2><p>本质：右增左增右减左减√。没想全用什么来把这个本质用代码表示出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int top = 0;</span><br><span class="line">        int bottom = matrix.length - 1;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = matrix[0].length - 1;</span><br><span class="line"></span><br><span class="line">        while (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            for (int col = left; col &lt;= right; col++) &#123;</span><br><span class="line">                result.add(matrix[top][col]);</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line"></span><br><span class="line">            for (int row = top; row &lt;= bottom; row++) &#123;</span><br><span class="line">                result.add(matrix[row][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line"></span><br><span class="line">            if (top &lt;= bottom) &#123;</span><br><span class="line">                for (int col = right; col &gt;= left; col--) &#123;</span><br><span class="line">                    result.add(matrix[bottom][col]);</span><br><span class="line">                &#125;</span><br><span class="line">                bottom--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (left &lt;= right) &#123;</span><br><span class="line">                 for (int row = bottom; row &gt;= top; row--) &#123;</span><br><span class="line">                    result.add(matrix[row][left]);</span><br><span class="line">                 &#125;</span><br><span class="line">                 left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="20-旋转图像"><a href="#20-旋转图像" class="headerlink" title="20 旋转图像"></a>20 旋转图像</h2><p>找索引的规律</p>
<hr>
<h2 id="21-搜索二维矩阵-II"><a href="#21-搜索二维矩阵-II" class="headerlink" title="21 搜索二维矩阵 II"></a>21 搜索二维矩阵 II</h2><p>算法：二分查找</p>
<p>二分查找的 return 可以根据题意变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean searchMatrix(int[][] matrix, int target) &#123;</span><br><span class="line">        for (int[] row : matrix) &#123;          </span><br><span class="line">            if (search(row, target)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean search(int[] nums, int target) &#123;</span><br><span class="line">        int left = 0, right = nums.length - 1;</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int mid = ((right - left) &gt;&gt; 1) + left;</span><br><span class="line">            if (target == nums[mid]) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if (target &gt; nums[mid]) &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>先将头节点赋值给 temp，再使用临时变量 temp 来遍历 </p>
<h2 id="22-相交链表"><a href="#22-相交链表" class="headerlink" title="22 相交链表"></a>22 相交链表</h2><p>使用哈希集合</p>
<hr>
<h2 id="23-反转链表"><a href="#23-反转链表" class="headerlink" title="23 反转链表"></a>23 反转链表</h2><p>类似于数组的交换位置，链表多了 <code>.next</code> 和移动链表节点（ 数组中直接使用下标即可 ）的操作</p>
<p><strong>需要抽象出来帮助解题的量没有想到，代码肯定写不出来</strong></p>
<hr>
<h2 id="24-回文链表"><a href="#24-回文链表" class="headerlink" title="24 回文链表"></a>24 回文链表</h2><p>空间换时间</p>
<p>算法：把链表保存到数组中，再用双指针</p>
<p>方法：</p>
<ul>
<li>List.size()：返回列表大小</li>
<li>List.get()：类似于数组中的 arr[]</li>
<li>List.equals()</li>
</ul>
<hr>
<h2 id="25-环形链表"><a href="#25-环形链表" class="headerlink" title="25 环形链表"></a>25 环形链表</h2><p>unordered_set 也可以保存链表节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        Set&lt;ListNode&gt; seen = new HashSet&lt;ListNode&gt;();</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        while (temp != null) &#123;</span><br><span class="line">            if (seen.contains(temp)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                seen.add(temp);</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法：</p>
<ul>
<li>HashSet.add()：将指定元素添加到集合中，如果元素原先不存在于集合中，则返回成功，否则返回失败</li>
</ul>
<hr>
<h2 id="27-合并两个有序链表"><a href="#27-合并两个有序链表" class="headerlink" title="27 合并两个有序链表"></a>27 合并两个有序链表</h2><p>prev 这个帮助解题的抽象没有想到，写不出来 代码</p>
<blockquote>
<p>链表需要一个 ListNode头指针 来表示一个新的链表</p>
<p>链表中头指针的移动：prev &#x3D; prev-&gt;next </p>
</blockquote>
<p>解题思维好像也有问题，为什么要将preHead等于list1或list2（错误的），我是要用一个新的链表来返回答案</p>
<hr>
<h2 id="28-两数相加"><a href="#28-两数相加" class="headerlink" title="28 两数相加"></a>28 两数相加</h2><p>局部变量sum共享</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        ListNode dummyHead = new ListNode(0);</span><br><span class="line">        ListNode current = dummyHead;  // current 是 dummyHead 的牛马</span><br><span class="line">        int carry = 0;</span><br><span class="line"></span><br><span class="line">        while (l1 != null || l2 != null || carry != 0) &#123;</span><br><span class="line">            int sum = carry;</span><br><span class="line"></span><br><span class="line">            if (l1 != null) &#123;</span><br><span class="line">                sum += l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (l2 != null) &#123;</span><br><span class="line">                sum += l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            carry = sum / 10;</span><br><span class="line">            current.next = new ListNode(sum % 10);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="29-删除链表的倒数第-N-个节点"><a href="#29-删除链表的倒数第-N-个节点" class="headerlink" title="29 删除链表的倒数第 N 个节点"></a>29 删除链表的倒数第 N 个节点</h2><p>哑节点到头节点会占用一次循环</p>
<hr>
<h2 id="30-两两交换链表中的节点"><a href="#30-两两交换链表中的节点" class="headerlink" title="30 两两交换链表中的节点"></a>30 两两交换链表中的节点</h2><p>算法：递归</p>
<ul>
<li>basecase</li>
<li><strong>自己调用自己</strong>就是向最小的子问题进发（ 递归里面的<strong>参数是变的</strong>，为了得到最终的答案，向最小的一步变 ）</li>
<li>还要有最小子问题的<strong>基本操作</strong></li>
<li>return 的东西要根据题目需要的结果来写</li>
</ul>
<p>链表中只有两个节点的话，直接更改指向就可以完成交换操作，但是不止两个节点时，直接更改指向会导致更改指向的节点的后续节点丢失，所以需要把更改指向的节点先存储下来</p>
<hr>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ul>
<li>因为可以把大树（ 大问题 ）拆成小树（ 相同的小问题 ），所以递归用的频繁（ 与递归的本质类似 ）</li>
<li><strong>递归只是大方向</strong>，需要的还是 数据结构 + 算法</li>
</ul>
<h2 id="36-二叉树的中序遍历"><a href="#36-二叉树的中序遍历" class="headerlink" title="36 二叉树的中序遍历"></a>36 二叉树的中序遍历</h2><p>中序遍历：从头节点开始，每个以该节点的树都是按左中右顺序遍历</p>
<p>题目给出的输入是一层一层地从左往右排</p>
<p>算法是根据题意写<strong>递归</strong></p>
<p>Why it work：将大问题拆解成多个小问题且子问题和原问题非常类似</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void inorder(TreeNode root, List&lt;Integer&gt; res) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>迭代法</p>
<p>Java 中栈的实现：</p>
<ul>
<li>Deque<TreeNode> stk &#x3D; new LinkedList<TreeNode>();</li>
</ul>
<blockquote>
<p>stk.push()：将元素添加到栈顶</p>
<p>stk.pop()：从栈顶移除元素，并返回这个元素</p>
<p>stk.isEmpty()</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">        while (root != null || !stk.isEmpty()) &#123;</span><br><span class="line">            while (root != null) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.pop();</span><br><span class="line">            res.add(root.val);  // 变形点</span><br><span class="line">            root = root.right;  // 移动 root </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="37-二叉树的最大深度"><a href="#37-二叉树的最大深度" class="headerlink" title="37 二叉树的最大深度"></a>37 二叉树的最大深度</h2><p>算法：深度优先搜索，求得是根节点到最远叶子节点的最长路径上的节点数</p>
<p>L：是左边的最长子节点数</p>
<p>R：是右边最长子节点数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int leftHeight = maxDepth(root.left);</span><br><span class="line">        int rightHeight = maxDepth(root.right);</span><br><span class="line">        return Math.max(leftHeight, rightHeight) + 1;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="38-翻转二叉树"><a href="#38-翻转二叉树" class="headerlink" title="38 翻转二叉树"></a>38 翻转二叉树</h2><p>如何写递归的 code：递归肯定是要调用自己的，再根据题意写需要的步骤</p>
<p>从叶子节点一直向上翻转</p>
<hr>
<h2 id="39-对称二叉树"><a href="#39-对称二叉树" class="headerlink" title="39 对称二叉树"></a>39 对称二叉树</h2><hr>
<h2 id="40-二叉树的直径"><a href="#40-二叉树的直径" class="headerlink" title="40 二叉树的直径"></a>40 二叉树的直径</h2><p>算法：深度优先算法 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private int ans = 0;</span><br><span class="line"></span><br><span class="line">    public int diameterOfBinaryTree(TreeNode root) &#123; </span><br><span class="line">        depth(root);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int depth (TreeNode node) &#123;</span><br><span class="line">        if ( node == null ) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int L = depth(node.left);</span><br><span class="line">        int R = depth(node.right);</span><br><span class="line"></span><br><span class="line">        if ( L + R &gt;  ans ) &#123;</span><br><span class="line">             ans = L + R;</span><br><span class="line">        &#125;  // 相比深度优先搜索多了一个这个和 ans</span><br><span class="line"></span><br><span class="line">        return Math.max(L,R) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="41-二叉树的层序遍历"><a href="#41-二叉树的层序遍历" class="headerlink" title="41 二叉树的层序遍历"></a>41 二叉树的层序遍历</h2><p>算法：广度优先搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 基础版 BFS</span><br><span class="line">public class BinaryTreeBFS &#123;</span><br><span class="line">	public void breadthFirstSearch (TreeNode root) &#123;</span><br><span class="line">		if (root == null) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">		queue.offer(root);</span><br><span class="line">		</span><br><span class="line">		while (!queue.isEmpty()) &#123;</span><br><span class="line">			TreeNode currentNode = queue.poll();</span><br><span class="line">			System.out.print(currentNOde.val + &quot; &quot;);</span><br><span class="line">			</span><br><span class="line">			if (currentNode.left != null) &#123;</span><br><span class="line">				queue.offer(currentNode.left);</span><br><span class="line">			&#125;</span><br><span class="line">			if (currentNode.right != null) &#123;</span><br><span class="line">				queue.offer(currentNode.right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 此题修改版，多了个 result和每次取出多个元素（ 因为题意要每一行分组保存 ）,levelSize 这个限制条件很关键，确保了在同一层的节点放到一个列表里</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null)&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();  // 列表的实现</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            int levelSize = queue.size();</span><br><span class="line">            List&lt;Integer&gt; levelList = new ArrayList&lt;&gt;();</span><br><span class="line">            for(int i = 0; i &lt; levelSize; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                levelList.add(node.val);</span><br><span class="line"></span><br><span class="line">                if (node.left != null) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (node.right != null) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            result.add(levelList);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据结构：Queue<TreeNode> queue &#x3D; new LinkedList&lt;&gt;();</p>
<p>方法：</p>
<ul>
<li>Queue.offer()：将指定元素添加到队列中</li>
<li>Queue.poll()：移除并返回队列头部元素</li>
<li>List.add()：将指定元素添加到列表的末尾</li>
</ul>
<hr>
<h2 id="42-将有序数组转换为二叉搜索树"><a href="#42-将有序数组转换为二叉搜索树" class="headerlink" title="42 将有序数组转换为二叉搜索树"></a>42 将有序数组转换为二叉搜索树</h2><p>搜索二叉树的中序遍历是升序序列</p>
<p>有高度限制 –&gt; 限制根节点（ 每次选择中间节点作为根节点 ）</p>
<hr>
<h2 id="43-验证二叉搜索树"><a href="#43-验证二叉搜索树" class="headerlink" title="43 验证二叉搜索树"></a>43 验证二叉搜索树</h2><p>数据结构：栈 Deque&lt; TreeNode &gt; stack &#x3D; new LinkedList&lt; TreeNode &gt;();</p>
<p>算法：二叉搜索树的中序遍历是升序，所以中序遍历的节点值都要大于前面一个节点值（ 此题是中序遍历迭代法的变形 ）</p>
<p>方法：</p>
<ul>
<li><p>stack.push()：添加到栈顶</p>
</li>
<li><p>stack.pop()：取出栈顶的元素，并返回</p>
</li>
<li><p>double inorder &#x3D; -Double.MAX_VALUE;</p>
</li>
</ul>
<hr>
<h2 id="44-二叉搜索树中第-K-小的元素"><a href="#44-二叉搜索树中第-K-小的元素" class="headerlink" title="44 二叉搜索树中第 K 小的元素"></a>44 二叉搜索树中第 K 小的元素</h2><p>利用中序遍历的迭代法</p>
<hr>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="63-搜索插入位置"><a href="#63-搜索插入位置" class="headerlink" title="63 搜索插入位置"></a>63 搜索插入位置</h2><p>return 的 left 就是插入的位置（大于 target 的第一个位置 ）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.length - 1;</span><br><span class="line"></span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int mid = left + (right - left) / 2;</span><br><span class="line"></span><br><span class="line">            if (nums[mid] == target) &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="64-搜索二维矩阵"><a href="#64-搜索二维矩阵" class="headerlink" title="64 搜索二维矩阵"></a>64 搜索二维矩阵</h2><p>对第一列用二分时，我的目的是找到包含target的列，而不是大于target的列，所以结果要减 1.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean searchMatrix(int[][] matrix, int target) &#123;</span><br><span class="line">        int rowIndex = binarySearchFirstColumn(matrix, target);</span><br><span class="line">        if (rowIndex &lt; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return binarySearchRow(matrix[rowIndex], target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int binarySearchFirstColumn(int[][] matrix, int target) &#123;</span><br><span class="line">        int low = 0, high = matrix.length - 1;</span><br><span class="line">        while (low &lt;= high) &#123;</span><br><span class="line">            int mid = low + (high - low) / 2;</span><br><span class="line">            if (matrix[mid][0] == target) &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125; else if (matrix[mid][0] &lt; target) &#123;</span><br><span class="line">                low = mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                high = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return low - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean binarySearchRow(int[] row, int target) &#123;</span><br><span class="line">        int left = 0, right = row.length - 1;</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int mid = ((right - left) / 2) + left;</span><br><span class="line">            if (row[mid] == target) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if (row[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h2 id="69-有效的括号"><a href="#69-有效的括号" class="headerlink" title="69 有效的括号"></a>69 有效的括号</h2><p>数据结构：栈，HashMap</p>
<ul>
<li>栈：Deque &lt; Character &gt; pairs &#x3D; new LinkedList&lt; Character &gt;</li>
</ul>
<p>算法：看栈取完了没，如果是对应的话，栈会是空的</p>
<p>方法：</p>
<ul>
<li>String.charAt ( x )：将字符串的第 x 个位置的元素转化为 char 类型</li>
<li>stack.peek()：查看栈中的顶部元素</li>
</ul>
<hr>
<h2 id="70-最小栈"><a href="#70-最小栈" class="headerlink" title="70 最小栈"></a>70 最小栈</h2><p>此题的题意并不是实现栈的底层，而是想一个方法来服务于实现最小栈</p>
<p>用一个辅助栈来保存最小值</p>
<hr>
<h2 id="71-字符串解码"><a href="#71-字符串解码" class="headerlink" title="71 字符串解码"></a>71 字符串解码</h2><p>数据结构：栈</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String decodeString(String s) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; countStack = new Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;StringBuilder&gt; stringStack = new Stack&lt;&gt;();  // 字符串是这个栈的元素</span><br><span class="line">        StringBuilder currentString = new StringBuilder();</span><br><span class="line">        int currentNum = 0;</span><br><span class="line"></span><br><span class="line">        // 遍历字符串</span><br><span class="line">        for (char c : s.toCharArray()) &#123;</span><br><span class="line">            if (Character.isDigit(c)) &#123;</span><br><span class="line">                // 如果是数字，更新当前数字（k的值）</span><br><span class="line">                currentNum = currentNum * 10 + (c - &#x27;0&#x27;); // 将字符表示的数字转换为整数</span><br><span class="line">            &#125; else if (c == &#x27;[&#x27;) &#123;</span><br><span class="line">                // 如果是 &#x27;[&#x27;，将当前数字和当前字符串压入栈</span><br><span class="line">                countStack.push(currentNum);</span><br><span class="line">                stringStack.push(currentString);</span><br><span class="line">                // 重置当前字符串和当前数字</span><br><span class="line">                currentString = new StringBuilder();</span><br><span class="line">                currentNum = 0;</span><br><span class="line">            &#125; else if (c == &#x27;]&#x27;) &#123;</span><br><span class="line">                // 如果是 &#x27;]&#x27;，表示结束了一个编码块</span><br><span class="line">                // 弹出栈顶的数字（重复次数）和字符串</span><br><span class="line">                int repeatCount = countStack.pop();</span><br><span class="line">                StringBuilder prevString = stringStack.pop();</span><br><span class="line">                // 将当前字符串重复 repeatCount 次</span><br><span class="line">                for (int i = 0; i &lt; repeatCount; i++) &#123;</span><br><span class="line">                    prevString.append(currentString);</span><br><span class="line">                &#125;</span><br><span class="line">                // 将重复后的字符串加到之前的字符串后面</span><br><span class="line">                currentString = prevString;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果是字母，直接添加到当前字符串</span><br><span class="line">                currentString.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 返回解码后的字符串</span><br><span class="line">        return currentString.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="74-数组中的第-K-个最大元素"><a href="#74-数组中的第-K-个最大元素" class="headerlink" title="74 数组中的第 K 个最大元素"></a>74 数组中的第 K 个最大元素</h2><p>算法：快排变一下，因为快排每一次 patition 就是确定一个数的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">        if (nums == null || nums.length &lt; k || k &lt;= 0) &#123;</span><br><span class="line">            return -1;  // 确保 k 是有效的</span><br><span class="line">        &#125;</span><br><span class="line">    // 调用快速选择方法，找到第 k 个最大的元素</span><br><span class="line">        return quickSelect(nums, 0, nums.length - 1, nums.length - k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int quickSelect(int[] arr, int L, int R, int targetIndex) &#123;</span><br><span class="line">        if (L == R) &#123;</span><br><span class="line">            return arr[L];  // 如果 L == R, 说明已经找到了目标元素</span><br><span class="line">        &#125;</span><br><span class="line">        // 随机选择一个基准元素</span><br><span class="line">        int pivotIndex = L + (int)(Math.random() * (R - L + 1));</span><br><span class="line">        swap(arr, pivotIndex, R);  // 将基准元素交换到数组的末尾</span><br><span class="line"></span><br><span class="line">        // 分区操作</span><br><span class="line">        int[] partitionIndices = partition(arr, L, R);</span><br><span class="line">        int leftPartitionEnd = partitionIndices[0] - 1;  // 小于基准元素的部分</span><br><span class="line">        int rightPartitionStart = partitionIndices[1] + 1;  // 大于基准元素的部分</span><br><span class="line"></span><br><span class="line">        // 如果目标索引在小于区</span><br><span class="line">        if (targetIndex &lt;= leftPartitionEnd) &#123;</span><br><span class="line">            return quickSelect(arr, L, leftPartitionEnd, targetIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果目标索引在大于区</span><br><span class="line">        else if (targetIndex &gt;= rightPartitionStart) &#123;</span><br><span class="line">            return quickSelect(arr, rightPartitionStart, R, targetIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果目标索引在等于区</span><br><span class="line">        else &#123;</span><br><span class="line">            return arr[partitionIndices[0]];  // partitionIndices[0] 是等于区的第一元素</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 荷兰国旗问题的分区方法</span><br><span class="line">    public int[] partition(int[] arr, int L, int R) &#123;</span><br><span class="line">        if (L == R) &#123;</span><br><span class="line">            return new int[] &#123; L, R &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        int lessPointer = L - 1;  // 初始化小于区的指针</span><br><span class="line">        int morePointer = R;       // 初始化大于区的指针</span><br><span class="line">        int index = L;</span><br><span class="line"></span><br><span class="line">        while (index &lt; morePointer) &#123;</span><br><span class="line">            if (arr[index] &lt; arr[R]) &#123;</span><br><span class="line">                swap(arr, index++, ++lessPointer);</span><br><span class="line">            &#125; else if (arr[index] == arr[R]) &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125; else &#123; // arr[index] &gt; arr[R]</span><br><span class="line">                swap(arr, index, --morePointer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, R, morePointer); // 将基准元素放到合适的位置</span><br><span class="line">        return new int[] &#123; lessPointer + 1, morePointer &#125;; // 返回小于区和大于区的边界</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 交换数组中的两个元素</span><br><span class="line">    public void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">        int temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2025/06/01/Vue/</url>
    <content><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h3 id="1-通过Vite创建Vue项目"><a href="#1-通过Vite创建Vue项目" class="headerlink" title="1. 通过Vite创建Vue项目"></a>1. 通过Vite创建Vue项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. `yarn create vite`</span><br><span class="line">2. `yarn` 下载配置</span><br><span class="line">3. `yarn dev` 运行</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-Two-core-feature-of-Vue"><a href="#2-Two-core-feature-of-Vue" class="headerlink" title="2. Two core feature of Vue"></a>2. Two core feature of Vue</h3><ul>
<li>Declarative Rendering：不用手动操作DOM，Vue会自动更新数据</li>
</ul>
<blockquote>
<p><strong>document.getElementById</strong>，用 Javasript 改变DOM需要这个命令，被称作命令式渲染</p>
</blockquote>
<ul>
<li>Reactivity：是Declarative Rendering的基础，当数据发生变化时可以自动追踪这些数据的状态，完成更新和改变</li>
</ul>
<hr>
<h3 id="3-开发者文档"><a href="#3-开发者文档" class="headerlink" title="3. 开发者文档"></a>3. 开发者文档</h3><h4 id="3-1-Reactivity"><a href="#3-1-Reactivity" class="headerlink" title="3.1. Reactivity"></a>3.1. Reactivity</h4><p><code>reactive(),ref()</code>   :用于创建<strong>响应式数据</strong>的两个API</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 返回代理对象，追踪其内部属性</span><br><span class="line">2. 当属性修改时，vue会**自动更新**依赖与这些属性的组件（.vue）</span><br><span class="line">3. 使用`ref()`时，用于**单个基本数据类型**，对象可以用`.value`来取值  </span><br><span class="line">4. `reactive()`，用于**复杂对象**</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-Attribute-Bindings"><a href="#3-2-Attribute-Bindings" class="headerlink" title="3.2 Attribute Bindings"></a>3.2 Attribute Bindings</h4><p><code>mustaches</code> : 双花号  </p>
<p><code>v-bind</code>：bind an <strong>attribute(class,id)</strong> to a <strong>dynamic</strong> value，shorthand syntax is ：</p>
<blockquote>
<p>例：<code>&lt;h1 :class=&quot;titleClass&quot;&gt;Make me red&lt;/h1&gt;</code>     </p>
</blockquote>
<hr>
<h4 id="3-3-Event-Listeners"><a href="#3-3-Event-Listeners" class="headerlink" title="3.3 Event Listeners"></a>3.3 Event Listeners</h4><p><code>v-on</code>：lisen to DOM events，shorthand syntax is @ ，作用：绑定一个事件</p>
<blockquote>
<p>微信小程序中是bindtap</p>
</blockquote>
<p><code>v-on:click=&quot;function&quot;</code>：<strong>click</strong>处理点击事件  </p>
<p><code>@submit.prevent</code> ： <strong>submit</strong>提交表单时执行某个方法，<strong>.prevent</strong>阻止事件的默认行为，表单的情况下，默认是发送请求并刷新页面，<em><strong>会导致一点击输入框就使用了某个方法</strong></em></p>
<hr>
<h4 id="3-4-Form-Bindings"><a href="#3-4-Form-Bindings" class="headerlink" title="3.4 Form Bindings"></a>3.4 Form Bindings</h4><p><code>v-model</code>： <strong>sugar syntax</strong> for : and @，automatially bound <code>&lt;input&gt;</code>‘s value with state  </p>
<blockquote>
<p>例：<code>&lt;input :value=&quot;text&quot; @input=&quot;onInput&quot;&gt;</code> to <code>&lt;input v-model=&quot;text&quot;&gt;</code>  </p>
<p>onInput函数：this.$emit(‘input’, event.target.value)，作用：向父组件发出一个 Input 事件，并将当前输入的值作为参数传递给父组件</p>
<p>v-model：会自动把 text 属性绑定到 value上，并在用户输入时，会发出一个 input事件，<strong>实现双向绑定</strong></p>
</blockquote>
<hr>
<h4 id="3-5-Conditional-Rendring"><a href="#3-5-Conditional-Rendring" class="headerlink" title="3.5 Conditional Rendring"></a>3.5 Conditional Rendring</h4><p> <code>v-if</code>  </p>
<p> <code>v-else</code> </p>
<hr>
<h4 id="3-6-List-Rendering"><a href="#3-6-List-Rendering" class="headerlink" title="3.6. List Rendering"></a>3.6. List Rendering</h4><p><code>v-for</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">todos.value.push()  // 向数组末尾增加一个元素</span><br><span class="line">todos.value.filter()  // 通过（）中的筛选然后返回一个新数组</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-7-Lifecycle-and-Template-Refs"><a href="#3-7-Lifecycle-and-Template-Refs" class="headerlink" title="3.7. Lifecycle and Template Refs"></a>3.7. Lifecycle and Template Refs</h4><p><code>onMounted</code>：注册一个回调函数，在组件挂载完成后执行  </p>
<blockquote>
<p>回调函数：作为另一个函数参数的函数   </p>
</blockquote>
<p><code>ref = &quot;xx&quot;</code>：用于手动操作DOM   </p>
<blockquote>
<p>例：<code> &lt;p ref=&quot;pElementRef&quot;&gt;hello&lt;/p&gt;</code>  </p>
</blockquote>
<hr>
<h4 id="3-8-Props"><a href="#3-8-Props" class="headerlink" title="3.8. Props"></a>3.8. Props</h4><p>Role：父组件将数据传递给子组件</p>
<p>syntax of child using ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line">  msg: String（类型）</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>syntax of parent using  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ChildComp :msg=&quot;greeting&quot; /&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-9-路由配置"><a href="#3-9-路由配置" class="headerlink" title="3.9. 路由配置"></a>3.9. 路由配置</h4><p><code>yarn add vue-router</code>   </p>
<ol>
<li>路由规则的配置，在 router.ts中配置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">    &#123;path:&#x27;/&#x27;, component: HomeView &#125;,</span><br><span class="line">    &#123;path:&#x27;/about&#x27;, component: AboutView&#125;, // HomeView、AboutView是两个.vue组件</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>路由器，在 router.ts中配置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const router = createRouter(&#123;</span><br><span class="line">    history: createMemoryHistory(),</span><br><span class="line">    routes,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default router;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>路由和Vue进行绑定 ，在 main.ts 中绑定</li>
</ol>
<p><code>app.use(router)</code></p>
<ol start="4">
<li>在App.vue中配置 RouterLink 和 RouterView</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;Hello App!&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;strong&gt;Current route path:&lt;/strong&gt; &#123;&#123; $route.fullPath &#125;&#125;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;nav&gt;</span><br><span class="line">    &lt;RouterLink to=&quot;/&quot;&gt;Go to Home&lt;/RouterLink&gt;  // 作用：跳转入口，像一个链接</span><br><span class="line">    &lt;RouterLink to=&quot;/about&quot;&gt;Go to About&lt;/RouterLink&gt;</span><br><span class="line">  &lt;/nav&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;RouterView /&gt;  // 不导入，Vue Router就不会渲染任何东西</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-10-HTML"><a href="#3-10-HTML" class="headerlink" title="3.10. HTML"></a>3.10. HTML</h4><p>label 的 <code>for</code>属性：如果和 input的 id属性一致，则点击label<strong>也</strong>会转移到input</p>
<hr>
<h4 id="3-11-Flex布局"><a href="#3-11-Flex布局" class="headerlink" title="3.11. Flex布局"></a>3.11. Flex布局</h4><p><code>display:flex</code> ：使用flex</p>
<p><code>flex-direction</code>：决定主轴方向，即内部项目的排列方向   </p>
<p><code>justify-content</code>：项目在主轴上的对齐方式  </p>
<p><code>align-items</code>：项目在交叉轴上的对齐方式  </p>
<blockquote>
<p><code>flex：1</code>：均匀的占据容器中所有可用空间</p>
</blockquote>
<hr>
<h4 id="3-12-箭头函数"><a href="#3-12-箭头函数" class="headerlink" title="3.12. 箭头函数"></a>3.12. 箭头函数</h4><ol>
<li><strong>简化</strong>，参数从包裹在()里变成&#x3D;号，没有了 return</li>
<li><strong>this</strong>，捕获上下文的 this ，不适用箭头函数的话可能会指向全局变量  </li>
<li>前面是函数名，后面是返回值</li>
</ol>
<hr>
<h4 id="3-13-组合式和选项式的区别"><a href="#3-13-组合式和选项式的区别" class="headerlink" title="3.13. 组合式和选项式的区别"></a>3.13. 组合式和选项式的区别</h4><p>选项式将每个部分的功能分开了，组合式能更好地处理逻辑(放在一起)  </p>
<h4 id="3-14-API"><a href="#3-14-API" class="headerlink" title="3.14 API"></a>3.14 API</h4><p><code>createApp</code>：每个 Vue 应用都是通过它创建一个新的应用实例  </p>
<p><code>app.mount(&#39;#app&#39;)</code>：应用实例必须调用了<code>.mount</code>方法（挂载）才会渲染出来，接收一个<strong>容器参数</strong>，可以是一个CSS选择器字符串</p>
<p><code>$emit</code>：当前组件触发另外一个<strong>自定义</strong>事件  </p>
<p><code>slot（插槽）</code>: 父组件为子组件传递一些模板片段</p>
<hr>
<h3 id="4-Element-Plus"><a href="#4-Element-Plus" class="headerlink" title="4. Element Plus"></a>4. Element Plus</h3><ol>
<li>导入到Vue项目：去<a href="https://element-plus.org/zh-CN/#/zh-CN">element-ui 官网</a>查看指南</li>
</ol>
<blockquote>
<p>element-ui官网 选择 <strong>vue3 版本</strong> </p>
<p><em><strong>每修改完一个文件的代码后都要 <code>crtl+s</code> 保存一下</strong></em>   </p>
</blockquote>
<ol start="2">
<li><code>icon </code>图标<strong>不能直接使用</strong>，需要根据说明再安装另外一个包</li>
</ol>
<hr>
]]></content>
  </entry>
  <entry>
    <title>八股</title>
    <url>/2025/05/25/%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[<h1 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h1><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>​	面试官您好，我叫吴淳中，就读于西安邮电大学，专业是通信工程，平时用的语言有 Java，了解过 C++ 和 Python，拿过数学建模和创新大赛的奖，做过两个小项目，基础比较扎实。</p>
<hr>
<h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h3 id="什么是面向对象的设计思想？"><a href="#什么是面向对象的设计思想？" class="headerlink" title="什么是面向对象的设计思想？"></a>什么是面向对象的设计思想？</h3><p>OOP（ Object-Oriented Programming ），通过<strong>对象</strong>来组织和管理程序</p>
<p>四大特征</p>
<ul>
<li>封装：将属性和方法绑定在一起，形成一个对象。并将对象内部隐藏起来，只暴露必要的接口供外部使用（数据保护）</li>
<li>继承：一个类继承另一个类的属性和方法（代码复用，已于扩展）。</li>
<li>多态：同一个方法用于不同的对象时，产生不同的行为。</li>
</ul>
<blockquote>
<p> <strong>Animal</strong> dog &#x3D; new <strong>Dog</strong>();  &#x2F;&#x2F;  <strong>允许将父类对象引用指向子类对象</strong></p>
<p> def animal_sound(animal):  </p>
<p> print(animal.speak()) &#x2F;&#x2F; animal</p>
<p> animal_sound(dog)  # 输出: Bark（ 前提是子类 dog 要重写父类的 sound 方法 ）</p>
<p> animal_sound(cat)  # 输出: Meow</p>
</blockquote>
<ul>
<li>抽象：隐藏复杂的实现细节，只保留重要的功能接口（ 程序员可以将注意力集中在高层次设计上 ）。</li>
</ul>
<hr>
<h3 id="Final-关键字"><a href="#Final-关键字" class="headerlink" title="Final 关键字"></a>Final 关键字</h3><p>修饰类：不能被继承</p>
<p>修饰方法：不能再子类中重写</p>
<p>修饰变量：一旦赋值就不能在改变</p>
<hr>
<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul>
<li>接口：包含常量和方法签名（ 不包含方法的实现 ），多个类可以实现该接口，实现多态。多继承（ implements ）。方法是 public abstract，变量 public static final，被default 修饰的方法，允许在实现该接口的类中<strong>不必重写</strong>这个方法。作用：解耦（ 不直接依赖于具体的实现 ）、可维护（ 定义了同一的行为规范 ）、可扩展（ 新增接口的实现即可 ）。</li>
<li>抽象类：包含抽象方法和具体方法（ 可以有方法的具体实现 ）。单继承（ extends ）。适用于有明显继承关系的场景。</li>
</ul>
<hr>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>作用：允许程序在<strong>运行时</strong>动态地获取类的信息和操作类的方法</p>
<p>动态性：反射使得我们在运行时动态地创建对象、调用方法和访问属性，与编译时不同，运行时反射允许程序在<strong>不知道具体类</strong>的情况下，根据需要处理对象</p>
<p>使用场景：框架设计，动态代理（ 通过反射来创建对象 ）</p>
<p>原理：加载完类之后，在堆中生成了一个 Class 类型的对象，这个对象包含了类的完整结构，然后通过 class 实例获取 class 信息和方法</p>
<hr>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>定义：是 Java 语言中的一种特性，允许在类、接口、方法中使用<strong>类型参数</strong>。在实例化时指定具体的数据类型即可。</p>
<p>使用场景：集合框架，自定义数据结构</p>
<hr>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><p>由两大接口派生而来：<code>Collection</code> 和 <code>Map</code></p>
<p>![屏幕截图 2025-05-12 164335](D:\xmind\Typora\image\屏幕截图 2025-05-12 164335.png)</p>
<img src="D:\xmind\Typora\image\屏幕截图 2025-05-12 164753.png" alt="屏幕截图 2025-05-12 164753" style="zoom:80%;" />

<hr>
<h3 id="说说List、Set、Queue、Map的区别？"><a href="#说说List、Set、Queue、Map的区别？" class="headerlink" title="说说List、Set、Queue、Map的区别？"></a>说说List、Set、Queue、Map的区别？</h3><ul>
<li>List：存储的元素是<strong>有序</strong>的、可重复</li>
<li>Set：存储的元素<strong>不可重复</strong></li>
<li>Queue：特定的排序规则（先进先出），存储的元素和 List 性质一样</li>
<li>Map：使用 key-value 存储</li>
</ul>
<hr>
<h3 id="ArrayLIst-和-LinkedList-区别"><a href="#ArrayLIst-和-LinkedList-区别" class="headerlink" title="ArrayLIst 和 LinkedList 区别"></a>ArrayLIst 和 LinkedList 区别</h3><ul>
<li>都线程不安全</li>
<li>ArrayList 底层使用数组，LinkedList 底层使用双向链表</li>
<li>ArrayList 支持随机访问，LinkedList 不支持 随机访问</li>
<li>ArrayList 使用场景：根据索引快速访问，内存开销小。LinkedList使用场景：在中间位置插入或删除，不需要随机访问</li>
</ul>
<hr>
<h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><p>HashSet：底层是哈希表，不保证元素插入和取出顺序</p>
<p>LinkedHashSet：底层是链表和哈希表，FIFO</p>
<p>TreeSet：底层是红黑树，支持对元素自定义排序</p>
<hr>
<h3 id="String、-StringBuffer-、StringBuilder-的区别"><a href="#String、-StringBuffer-、StringBuilder-的区别" class="headerlink" title="String、 StringBuffer 、StringBuilder 的区别"></a>String、 StringBuffer 、StringBuilder 的区别</h3><p>可变性：String 不可变、Buffer 和 Builder 可变，因为它们继承自 AbstractStringBuilder 类（ 提供了很多修改字符串的方法，比如 append ）</p>
<p>线程安全性：String 中的对象不可变，可以理解为常量，线程安全。StringBuffer 在 AbstractStringBuilder 方法上加了同步锁，线程安全。StringBuilder 没有加锁，线程不安全</p>
<p>使用场景：String（ 字符串不经常修改 ）、StringBuilder（ 单线程下字符串经常修改 ）、StringBuffer（ 多线程下字符串经常修改）</p>
<hr>
<h3 id="什么是BlockingQueue"><a href="#什么是BlockingQueue" class="headerlink" title="什么是BlockingQueue"></a>什么是BlockingQueue</h3><p>阻塞队列，继承自<code>Queue</code>，功能：当队列没有元素时一直阻塞，如果队列已满，一直等到队列可以放入新元素时再放入。</p>
<p>常用于生产者-消费者模型中，生产者线程向队列中添加元素，消费者线程从队列中取出数据</p>
<hr>
<h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><p>HashMap：线程不安全。可以存储 null 的 key 和 value。总是以 2 的幂作为容量大小。</p>
<p>Hashtable：线程安全（ Synchronized ），不能存储 null。 容量变为 2n + 1。底层基于 HashMap</p>
<hr>
<h3 id="HashMap与ConcurrentHashMap的区别是什么？"><a href="#HashMap与ConcurrentHashMap的区别是什么？" class="headerlink" title="HashMap与ConcurrentHashMap的区别是什么？"></a><strong>HashMap与ConcurrentHashMap的区别是什么？</strong></h3><p>内存结构：都是数组+链表+红黑树</p>
<p>线程安全：Hashmap 非线程安全，ConcurrentHashMap，java7及之前，采用将整个哈希表分成多个段，每个段有自己的锁。java8 之后，采用 CAS（ 实现并发编程的原子性操作 ） 和 synchronized 来保证线程安全</p>
<hr>
<h3 id="HashMap-的底层原理"><a href="#HashMap-的底层原理" class="headerlink" title="HashMap 的底层原理"></a>HashMap 的底层原理</h3><ul>
<li>HashMap 是什么：使用一个数组来存储数据，每个数组元素被称为“桶”，每个桶可以存储一个链表或红黑树</li>
</ul>
<ol>
<li>将Key 的  <code>hashcode（ 通过哈希函数计算得来 ）</code> 输入到扰动函数（ 优化哈希值的分布，减小碰撞 ）处理后得到 hash 值</li>
</ol>
<blockquote>
<p>扰动函数 hash</p>
<p> static final int hash(Object key) {<br>   int h;<br>   &#x2F;&#x2F; key.hashCode()：返回散列值也就是hashcode<br>   &#x2F;&#x2F; ^：按位异或<br>   &#x2F;&#x2F; &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐<br>   return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>}</p>
</blockquote>
<ol start="2">
<li>(n（数组长度） - 1) &amp; hash&#96; 判断元素存在的位置</li>
</ol>
<p>如果存在元素，就判断两者的 hash 值和 key 是否相同，相同则直接覆盖，不同就通过拉链法解决冲突</p>
<blockquote>
<p>拉链法：若遇到哈希冲突，将冲突的值加到链表中</p>
</blockquote>
<p>当链表长度大于 8 时（ 当数组长度小于64，会优先进性数组扩容（ 因为可以减少哈希冲突的发生概率 ） ），将链表转化为红黑树（ 减少搜索时间 ）</p>
<ul>
<li>怎么扩容 ？</li>
</ul>
<p>当元素数量（ 键值对 ）达到 capacity * loadFactor（ 负载因子，默认0.75 ），就会触发扩容</p>
<ol>
<li><p>创建一个扩大到当前容量的<strong>两倍</strong>的新数组</p>
</li>
<li><p>重新计算哈希值（ 用第 1 步的方法 ）</p>
</li>
<li><p>迁移元素，重新计算位置（ 用第 2 步的方法 ）</p>
</li>
<li><p>更新指针：将指向原数组得引用更新为指向新数组得引用</p>
</li>
</ol>
<hr>
<h3 id="hashcode-冲突怎么解决"><a href="#hashcode-冲突怎么解决" class="headerlink" title="hashcode 冲突怎么解决"></a>hashcode 冲突怎么解决</h3><p>链地址法：在值中，使用链表才存储哈希值相同的对象</p>
<p>开放地址法：寻找哈希表下一个空的桶来存储冲突对象</p>
<p>再哈希法：使用另一个哈希函数再次计算键的哈希值</p>
<hr>
<h3 id="java中怎么把一个字符串反转"><a href="#java中怎么把一个字符串反转" class="headerlink" title="java中怎么把一个字符串反转"></a>java中怎么把一个字符串反转</h3><ul>
<li>使用 StringBuilder（ 非线程安全 ） 或 StringBuffer（ 线程安全 ） 的 reverse () 方法</li>
<li>手动反转字符串</li>
</ul>
<hr>
<h2 id="Java-并发"><a href="#Java-并发" class="headerlink" title="Java 并发"></a>Java 并发</h2><h3 id="怎么保证线程安全"><a href="#怎么保证线程安全" class="headerlink" title="怎么保证线程安全"></a>怎么保证线程安全</h3><ul>
<li>原子性：一个操作要么完全执行，要么完全不执行</li>
<li>可见性：一个线程对共享变量的修改，能够即时被其他线程看到（ volatile：用于修饰变量，确保在多线程环境下对该变量的写操作可以被其他线程及时看到 ）</li>
<li>有序性：保证程序中语句执行的顺序</li>
</ul>
<hr>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>定义：两个或多个进程因为争夺资源而相互等待，导致所有进程都无法执行（ A 请求 B 占用的资源，B 请求 A占用的资源 ）</p>
<p>发生的四个条件：</p>
<ol>
<li>互斥：至少有一个资源处于非共享模式，即每一时刻只能被一个进程占用</li>
<li>持有并等待：进程至少持有一个资源，并且在等待获取其他资源</li>
<li>不抢占：资源不能被抢占（ 只有持有它的进程可以释放 ）</li>
<li>循环等待：存在一种循环链，每个进程在等待下一个进程所持有的资源</li>
</ol>
<hr>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>作用：保证被它修饰的方法或代码块在同一时刻只能由一个线程执行</p>
<p>非公平（ 多个线程竞争一把锁时，锁的获取顺序并不保证遵循请求的顺序 ）、可重入（ 同一线程可以多次获取同同一把锁 ）</p>
<p>重量级锁：因为监视器锁（ 内置的并且使用者看不到的锁称为监视器锁 ）依赖于操作系统，挂起或环形一个线程，需要从<strong>用户态转到内核态</strong>，时间成本相对较高</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><ul>
<li>使用 synchronized 之后，会在编译之后在代码块前后加上 <code>monitorenter</code> 和 <code>monitorexit</code> 字节码指令。执行monitorenter 指令会尝试获取对象锁，如果对象没有锁或者已经获得了锁，锁的<strong>计数器</strong> + 1。此时其他竞争锁的线程进入等待队列，执行 monitorexit 会把计数器 -1，当计数器为 0，锁释放。处于等待队列中的线程再继续竞争锁</li>
</ul>
<hr>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>非公平、可重入</p>
<p>实现了 <code>Lock</code> 接口，可重入锁，和 Synchronized 类似，但是<strong>多了</strong>公平锁、支持超时（ 超过等待时间就会获取锁失败 ）功能</p>
<hr>
<h3 id="reentrantlock和sync区别是什么"><a href="#reentrantlock和sync区别是什么" class="headerlink" title="reentrantlock和sync区别是什么"></a>reentrantlock和sync区别是什么</h3><p>用法不同：synchronized 可用来修饰普通方法、静态方法，而 reentrantLock 只能用在代码块上</p>
<p>获取锁和释放锁方式不同：sync 自动加锁和释放锁，reen 需要手动</p>
<p>锁类型不同：sync 非公平，reen 可以非公平也可以公平</p>
<p>响应中断：reen 可以响应中断（ 一个线程持有某个锁并且等待其他资源时被中断，可以及时释放持有的锁 ），解决死锁问题，sync 不能</p>
<hr>
<h3 id="ThreadLocal-是什么"><a href="#ThreadLocal-是什么" class="headerlink" title="ThreadLocal 是什么"></a>ThreadLocal 是什么</h3><ul>
<li><p>解决线程安全问题的一种机制，允许创建<strong>线程的局部变量</strong></p>
</li>
<li><p>原理：ThreadLocalMap ，key 是 ThreadLocal 本身，value 是 线程特定的变量</p>
</li>
<li><p>内存泄漏原因：未调用ThreadLocal.remove方法（ ThreadLocalMap 继续持有对变量的引用 ）</p>
</li>
</ul>
<hr>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>一种用于管理和复用线程的技术</p>
<p>好处：</p>
<ul>
<li><p>降低因创建和销毁线程造成的消耗</p>
</li>
<li><p>提高响应速度。任务到达时，任务不需要等待线程创建就能立刻从池中分配一个空闲线程来执行任务</p>
</li>
<li><p>提高线程的可管理性</p>
</li>
</ul>
<p>核心参数：</p>
<ul>
<li>核心线程数( corePoolSize )：线程池中始终保持活动的线程数量</li>
<li>最大线程数( maximumPoolSize )：线程池允许的最大线程数量</li>
<li>线程空闲时间( keepAliveTime ) :当任务数量大于核心线程数后会创建新的线程，<strong>新的线程</strong>会在空闲时间到达后被终止</li>
<li>时间单位( TimeUnit )：空闲线程存活时间的描述单位</li>
<li>任务队列( workQueue)：存放等待执行的任务</li>
<li>线程工厂( threadFactory )：可以为线程设置名称、优先级等属性</li>
<li>拒绝策略( handler )：当线程池和队列都满了，再有新任务提交时，线程池会采取拒绝策略</li>
</ul>
<blockquote>
<p>CallerRunsPolicy：使用线程池的调用者所在的线程去执行被拒绝的任务</p>
<p>AbortPolicy：直接抛出一个任务被线程池拒绝的异常</p>
<p>DiscardPolicy：不做任何处理</p>
<p>DiscardOldestPolicy：抛弃最小的任务，然后执行该任务</p>
</blockquote>
<h4 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h4><ol>
<li>如果有空闲线程，线程池会直接分配任务给空闲线程</li>
<li>如果没有空闲线程，且线程池中线程数小于最大值，线程池会创建新的线程来执行任务</li>
<li>如果线程池中的线程数达到最大值，那么任务会被加入到任务队列中，等待线程池空闲后执行</li>
<li>如果等待队列已满，且任务数量超过最大线程数，会执行拒绝策略</li>
</ol>
<hr>
<h3 id="读写锁和互斥锁的区别，使用场景"><a href="#读写锁和互斥锁的区别，使用场景" class="headerlink" title="读写锁和互斥锁的区别，使用场景"></a>读写锁和互斥锁的区别，使用场景</h3><ul>
<li>互斥锁：同一时刻只允许一个线程或进程发访问共享资源（ 用于写操作频繁 ）</li>
<li>读写锁：将对共享资源的访问分为读操作和写操作。允许多个线程同时进行读操作，但在写操作时，会排斥其他的读操作和写操作（ 用于读操作多余写操作 ）</li>
</ul>
<hr>
<h3 id="java中容易出现的异常"><a href="#java中容易出现的异常" class="headerlink" title="java中容易出现的异常"></a>java中容易出现的异常</h3><ul>
<li>检查异常：必须在代码里处理或抛出</li>
</ul>
<p>SQLException：与数据库交互式发生错误时</p>
<p>IOException：输入输出操作失败会中断时</p>
<ul>
<li>运行时异常：不要求强制处理，但在运行时可能会出现</li>
</ul>
<p>NullPointerException：对一个 null 对象进行操作时</p>
<p>ArrayIndexOutOfBoundsException：访问数组时，索引超出了数组有效范围</p>
<hr>
<h3 id="ABA是什么问题，一般可以怎么解决？"><a href="#ABA是什么问题，一般可以怎么解决？" class="headerlink" title="ABA是什么问题，一般可以怎么解决？"></a>ABA是什么问题，一般可以怎么解决？</h3><p>线程对共享状态的错误理解，情景：线程 A 读取某个变量的值为 A，线程 B 将该值修改为 B 而后又将其恢复为 A ，当线程 A 执行 CAS 操作时，会发现值还是 A，误认为没有其他线程对该变量修改，最终成功修改该值</p>
<p>通过版本号解决</p>
<hr>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>定义：一组要执行的数据库操作</p>
<p>作用：保证数据的一致性</p>
<p>ACID特性：</p>
<ul>
<li>原子性（ Atomicity ）：事务是最小的执行单位。要么全部完成，要么全部不起作用（ 回滚 ）</li>
<li>一致性（Consistency）：执行事务前后，数据保持一致（ 数据库的约束检查 ）</li>
</ul>
<blockquote>
<p>转账业务中，无论事务是否成功， 转账这和收款人的总额应该是不变的</p>
</blockquote>
<ul>
<li><p>隔离性（ Isolation ）：各并发事务之间的数据库是独立的（ 行锁、表锁 ）</p>
</li>
<li><p>持久性（ Durability ）：一个事务被提交后，数据库中的改变是持久的（ 日志记录 ）</p>
</li>
<li><p>保证了事务的原子性，隔离性和持久性之后，一致性才能保证，AID是手段，C是目的</p>
</li>
</ul>
<hr>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>一个事务读取了另一个事务未提交的修改数据，由于未提交的修改数据可能回滚，因此读取到的数据可能并不可靠</p>
<blockquote>
<p>回滚：数据库的状态恢复到事务开始之前的状态</p>
</blockquote>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>相同的查询在同一个事务中返回的<strong>结果集</strong>不同，因为另一个事务插入( <strong>增删</strong> )了符合条件的新数据</p>
<p>解决方法：表级锁，MVCC、乐观锁悲观锁</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>相同的<strong>行</strong>数据在同一个事务中被多次读取，结果不同，因为另一个事务<strong>修改</strong>了该行数据</p>
<hr>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>作用：负责如何存储、检索和管理数据</p>
<ul>
<li>InnoDB（ 默认的存储引擎 ）</li>
</ul>
<ol>
<li><p>事务支持：提供了对事务的支持，可以进行 ACID 属性的操作</p>
</li>
<li><p>并发性能：采用了行级锁定的机制，可以提供更好的并发性能</p>
</li>
</ol>
<blockquote>
<p>行级锁定：允许多个事务同时对同一表进行操作，但每个事务只能对<strong>不同的行</strong>进行操作</p>
</blockquote>
<ol start="3">
<li>崩溃恢复：通过 redolog 日志实现了崩溃恢复，保证数据的持久性</li>
</ol>
<ul>
<li>MyISAM：具有较低的存储空间和内存消耗，适用于大量读操作中</li>
<li>Memory：将数据存储在内存中国，适用于对性能要求较高的读操作中</li>
</ul>
<hr>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>定义：用于加速数据检索的一种数据结构，可以显著提高查询性能（ MySQL能快速定位到数据，而不需要扫描整个表 ）</p>
<ul>
<li>B+ tree：叶子节点才存放数据，非叶子节点只放索引（ 索引里有多个键，例如：类似于将搜索树的左右两个节点变成一个节点，而这个节点里就是索引，索引里有两个键 ）。子节点有两个指针，分别执</li>
</ul>
<h4 id="索引失效的场景"><a href="#索引失效的场景" class="headerlink" title="索引失效的场景"></a>索引失效的场景</h4><ol>
<li><p>WHERE 语句中，OR 前的条件列是索引列，而 OR 后的条件列不是索引列</p>
</li>
<li><p>在索引列上使用了函数或表达式计算</p>
</li>
<li><p>使用 LIKE 且通配符 % 位于字符串的开头</p>
</li>
</ol>
<hr>
<h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC( 多版本并发控制 )"></a>MVCC( 多版本并发控制 )</h3><p>定义：一种用于数据库管理系统中的并发控制机制，确保数据的一致性和隔离性</p>
<ul>
<li>多版本：MVCC 通过为每个事务创建数据的多个版本（ <strong>快照</strong> ），允许不同的事务同时读取和写入数据，而不会相互阻塞</li>
<li>并发控制：在多个事务同时访问数据库时，MVCC 通过版本管理来控制事务之间的并发访问</li>
</ul>
<p>工作原理：</p>
<ul>
<li>版本管理：当对数据进行修改时，数据库并<strong>不会直接覆盖原有的数据</strong>，而是创建一个新的数据版本</li>
<li>读操作：MVCC 确保读取的是事务<strong>开始时可见的版本</strong>，实现快照读。由于每个事务有自己的快照，所以读操作不会阻塞写操作。</li>
</ul>
<blockquote>
<p>读取数据的过程：一个事务在读取数据时，其他事务提交了对该数据的修改，该事务会看到的是修<strong>改前的旧版本</strong>，而不是正在进行的修改，保证了读取操作的隔离性</p>
</blockquote>
<ul>
<li>写操作：当事务进行写操作时，创建一个新的版本，并将该版本标记为当前事务的版本。完成事务后，新的版本被提交，成为最新的可见版本。</li>
</ul>
<hr>
<h3 id="MySQL-隔离级别"><a href="#MySQL-隔离级别" class="headerlink" title="MySQL 隔离级别"></a>MySQL 隔离级别</h3><p>决定了多个事务并发执行时的行为</p>
<ol>
<li>读未提交：一个事务可以读取另一个事务未提交的数据。可能出现脏读</li>
<li>读已提交：一个事务只能读取已提交的数据。可能出现不可重复读</li>
<li>可重复读：一个事务在开始后，期间读取的数据在该事务内都是一致的。可能出现幻读，因为查询的结果可能因为其他事务的插入（ 增删 ）而变化</li>
<li>串行行：所有事务按顺序执行</li>
</ol>
<hr>
<h3 id="三个日志"><a href="#三个日志" class="headerlink" title="三个日志"></a>三个日志</h3><ul>
<li>撤销日志（ Undo Log ）：记录事务对数据<strong>修改前</strong>的状态，目的：支持事务<strong>回滚</strong></li>
<li>二进制日志（ Binary Log）：记录数据库的<strong>所有</strong>更改</li>
<li>重做日志（ Redo Log ）：记录<strong>已提交</strong>事务的修改，目的：确保已提交事务的<strong>持久性</strong></li>
</ul>
<hr>
<h3 id="UNION-和-UNION-ALL"><a href="#UNION-和-UNION-ALL" class="headerlink" title="UNION 和 UNION ALL"></a>UNION 和 UNION ALL</h3><p>都是用于合并两个或多个 SELECT 查询结果的关键字</p>
<p>UNION：会自动去除结果集中重复的行，所以会比 UNION ALL 消耗更多的系统资源和时间</p>
<p>UNION ALL：不会去除重复的行</p>
<hr>
<h3 id="EXISTS和IN的区别"><a href="#EXISTS和IN的区别" class="headerlink" title="EXISTS和IN的区别"></a>EXISTS和IN的区别</h3><p>IN：需要将子查询的结果集全部处理并存储起来，然后进行比较操作。</p>
<p>EXISTS：不需要存储子查询的全部结果集，只需要在找到一行匹配记录后就停止查询。</p>
<hr>
<h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><p>缓存</p>
<p>分页</p>
<p>索引</p>
<hr>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h3><p>JMM：用于解决<strong>多线程环境</strong>下的可见性、有序性和原子性问题，核心是通过定义主内存和工作内存的交互规则，确保进程间通信正确。</p>
<ul>
<li>原子性：同一时刻只能有一个线程对数据进行操作</li>
<li>可见性：一个线程对主内存的修改可以及时地被其他线程看到</li>
<li>有序性：使用 happens-before原则（ 第一个操作会在第二个操作之前执行 ）</li>
</ul>
<hr>
<h3 id="jvm内存模型介绍一下"><a href="#jvm内存模型介绍一下" class="headerlink" title="jvm内存模型介绍一下"></a><strong>jvm内存模型介绍一下</strong></h3><p>作用：定义了 Java 程序如何在内存中分配和管理数据</p>
<ul>
<li>方法区：存储类信息、常量、静态变量和 JIT 编译后的代码。Java 8 之后，成为<strong>元空间</strong>，不再使用堆内存而是本地内存（ JVM运行时从操作系统分配的内存 ），是线程共享的</li>
<li>堆区：存储对象实例，是 JVM 中最大的内存区域。也是所有<strong>线程共享</strong>的内存区域，垃圾回收的主要区域，</li>
</ul>
<p>有新生代（ 存放新创建的对象 ）、老年代（ 存放长期存活的对象）和元空间（ 存储类的元数据 ）</p>
<ul>
<li>栈区：线程私有，存储局部变量、方法调用。局部变量在方法调用结束后立即被销毁</li>
<li>程序计数器：记录当前线程执行字节码的地址，该区域<strong>线程私有</strong></li>
<li>本地方法栈：执行本地方法（通过 JNI调用的、用其他编程语言编写的方法 ）的调用</li>
</ul>
<hr>
<h3 id="怎么进行垃圾回收？"><a href="#怎么进行垃圾回收？" class="headerlink" title="怎么进行垃圾回收？"></a>怎么进行垃圾回收？</h3><p>垃圾回收定义：回收不再用的对象，来释放内存空间</p>
<p>垃圾回收算法：</p>
<ul>
<li>引用计数法：每个对象维护引用计数器，每当有一个地方引用该对象时，计数器 +1，失效时，计数器 -1。当引用为 0 时回收</li>
<li>可达性分析：从被称为 GC Roots（ 线程、静态变量、栈中的局部变量、全局变量等 ）的对象作为起始点，开始向下搜索，搜索走过的路径叫引用链。当从 GC Roots 到该对象不可达，则证明该对象不可用，可被回收</li>
</ul>
<blockquote>
<p>本地变量：代码内部声明的</p>
</blockquote>
<hr>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>类加载器：负责在运行时将 Java 类加载到内存中，作用：将字节码文件（ .class 文件 ）转化为 JVM 可以使用的类对象</p>
<p>定义：Java 类加载器在加载类时，首先会将请求委派给<strong>父类加载器</strong>，只有当父类加载器无法找到该类时，子类加载器才会尝试自己加载</p>
<p>优点：</p>
<ul>
<li>避免重复加载（ 当父类加载了该类，就不需要子加载器再次加载 ）</li>
<li>防止核心 API 被篡改（ 无法编写一个自己的 java.lang.String 类来替换系统的 String 类，因为所有的 String 类都会有启动类加载器加载（ 父类 ））</li>
</ul>
<hr>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="为什么-Redis-比-MySQL-快？"><a href="#为什么-Redis-比-MySQL-快？" class="headerlink" title="为什么 Redis 比 MySQL 快？"></a>为什么 Redis 比 MySQL 快？</h3><ul>
<li><p>Redis 数据主要存储在内存中，MySQL数据存储在磁盘上，内存的读写速度远远快于磁盘。</p>
</li>
<li><p>采用了简单的数据结构，MySQL 的数据结构相对发杂，以表的形式存储</p>
</li>
</ul>
<hr>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>String：值是字符串，用于缓存</li>
<li>Hash：键值对的集合，存储对象</li>
<li>List：有序字符串集合，可以在两端快速推入或弹出元素，类似于链表，用于消息队列</li>
<li>Set：无序字符串集合，支持<strong>唯一性</strong>，方法除了添加获取删除还有<strong>交集并集</strong>，用于共同关注</li>
<li>Zset：与 Set 类似，但是多了每个元素有与之关联的<strong>分数</strong>，用于排行榜</li>
</ul>
<hr>
<h3 id="Redis持久化机制有哪些，底层原理是怎样的"><a href="#Redis持久化机制有哪些，底层原理是怎样的" class="headerlink" title="Redis持久化机制有哪些，底层原理是怎样的"></a>Redis持久化机制有哪些，底层原理是怎样的</h3><ul>
<li><p>AOF 日志</p>
<p>每执行一条写操作<strong>命令</strong>，就把该命令以追加的方式写入到一个日志文件里</p>
</li>
</ul>
<p>​	同步策略：1.Always：每次写操作后同步、2.Everysec：每秒同步、3.No：从不同不（依赖操作系统）</p>
<p>​	重写策略：根据数据库状态所需的最小命令集来生成一个新的 AOF 文件</p>
<p>​	数据恢复：Redis重启时，可以通过 AOF 文件重放其中的命令来啊恢复数据</p>
<ul>
<li><p>RDB 快照</p>
<p>两者优缺点：为什么有RDB快照？AOF记录的时操作命令而不是实际的数据，若 AOF 日志<strong>非常多</strong>，会造成Redis恢复操作缓慢，但是 RDB 方式会存在<strong>某一段数据全部丢失</strong>的情况</p>
</li>
</ul>
<p>​	定义：记录某一个瞬间的<strong>内存数据</strong></p>
<p>​	生成 RDB 文件的命令：save：在主线程中生成RDB文件，会阻塞主线程、bgsave：创建一个子进程生成RDB，避免阻塞</p>
<hr>
<h3 id="redis分布式锁读写一致性如何保证"><a href="#redis分布式锁读写一致性如何保证" class="headerlink" title="redis分布式锁读写一致性如何保证"></a>redis分布式锁读写一致性如何保证</h3><p>锁过期导致读写不一致，使用 Redisson 的自动续期机制（ 锁被持有期间，Redisson会自动延长锁的过期时间 ）</p>
<hr>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="RabbitMQ-是什么"><a href="#RabbitMQ-是什么" class="headerlink" title="RabbitMQ 是什么"></a>RabbitMQ 是什么</h3><p>消息队列，特性如下</p>
<ul>
<li>核心组件：生产者发送消息给 RabbitMQ、消费者从 RabbitMQ 接收并处理消息、RabbitMQ 本身负责存储和转发消息</li>
<li>交换机：接收来自生产者的消息，并根据 Routing key 和绑定规则将消息路由到一个或多个队列</li>
</ul>
<blockquote>
<p>Routing key：消息发送时附加的一个字符串，交换机根据这个字符串来决定将消息路由到哪些队列</p>
<p>绑定规则：</p>
<ul>
<li>Direct Binding：队列与交换机通过一个具体的路由键连接</li>
<li>Topic Binding：使用匹配模式（ * 代表一个单词， # 代表多个单词 ）</li>
<li>Fanout Binding：所有绑定到该交换机的队列都会收到消息</li>
</ul>
</blockquote>
<ul>
<li>持久化：可以将消息保存在磁盘上</li>
<li>确认机制：消费者处理完消息后发送确认给 RabbitMQ，未确认的消息会重新入队</li>
<li>高可用性：可以将多个 RabbitMQ 实例组成一个集群</li>
</ul>
<hr>
<h3 id="消息幂等性"><a href="#消息幂等性" class="headerlink" title="消息幂等性"></a>消息幂等性</h3><p>定义：同一条消息被处理多次时，结果是相同的，不会产生副作用（ 重复扣款、重复创建订单 ）</p>
<p>为什么需要幂等性：1. 生产者消息重发、2. 消费者重复处理</p>
<p>实现方法</p>
<ul>
<li>唯一标识符：为每条消息分配一个唯一的标识符，消费者在处理消息时，首先检查（ 判断 Set 集合中有没有这个唯一标识符 ）该标识符是否已经处理过（ 背景：每次处理完后都会把唯一识别符记录到一个 Set 集合中 ）</li>
<li>数据库约束：在数据库中使用唯一约束（ 防止在指定的列中插入重复数据 ），确保同一条消息不会导致重复插入</li>
</ul>
<hr>
<h3 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h3><p>定义：消息传递过程中，消息未能成功到达目标消费者的情况。</p>
<p>解决方案：</p>
<ul>
<li>持久化消息（ 队列崩溃 ）：确保消息在发送到队列时进行持久化。实现：将消息标记为 persistent 来确保其被写入磁盘</li>
<li>确认机制（ 消费者崩溃 ）：消费者在成功处理消息后，必须向消息队列发送确认信号，确保只有在消息成功处理后，才会从队列中删除</li>
<li>重试机制 （ 消费者处理消息失败 ）：将处理失败的消息重新放回队列中</li>
<li>死信队列（ 消费者处理消息失败 ）：将无法处理的消息发送到死    信队列。实现：配置一个死信交换机，将处理失败的消息路由到特定的死信队列</li>
</ul>
<hr>
<h3 id="消费堆积"><a href="#消费堆积" class="headerlink" title="消费堆积"></a>消费堆积</h3><p>定义：消息队列中未消费的消息数量不断增加</p>
<p>解决方法：</p>
<ul>
<li>增加消费者实例（ 加快消费速率 ）</li>
<li>优化消息处理逻辑（ 减少处理时间 ）</li>
<li>使用延迟队列：将不那么紧急的消息放入延迟队列</li>
</ul>
<hr>
<h2 id="黑马点评"><a href="#黑马点评" class="headerlink" title="黑马点评"></a>黑马点评</h2><h3 id="如何在-Java-项目中使用-Redis"><a href="#如何在-Java-项目中使用-Redis" class="headerlink" title="如何在 Java 项目中使用 Redis"></a>如何在 Java 项目中使用 Redis</h3><p>添加 Redis 客户端 Jedis 依赖</p>
<hr>
<h3 id="为什么用Redis替代Session？还有其他解决办法吗？"><a href="#为什么用Redis替代Session？还有其他解决办法吗？" class="headerlink" title="为什么用Redis替代Session？还有其他解决办法吗？"></a>为什么用Redis替代Session？还有其他解决办法吗？</h3><p>Session 有集群共享问题：默认情况下，Session 保存在单个服务器上，当有多个服务器时，Session 信息不能共享，而 Redis 数据共享</p>
<p>Redis 的优点</p>
<ul>
<li>读写速度块（ 基于内存的数据库 ）</li>
<li>保证数据的持久性</li>
<li>丰富的数据结构（ 选用 Hash，因为可以对单个字段进行CRUD，更加灵活 ）</li>
</ul>
<p>其他解决办法：Session拷贝，会导致增加服务器的额外内存开销和数据一致性问题</p>
<hr>
<h3 id="您能详细解释一下如何使用-Redis-实现-Session-共享的吗？"><a href="#您能详细解释一下如何使用-Redis-实现-Session-共享的吗？" class="headerlink" title="您能详细解释一下如何使用 Redis 实现 Session 共享的吗？"></a>您能详细解释一下如何使用 Redis 实现 Session 共享的吗？</h3><p>注册用户时，会生成一个随机的 Token 作为 Key 值存放用户到 Redis 中</p>
<hr>
<h3 id="为什么使用-ThreadLocal-保存用户信息"><a href="#为什么使用-ThreadLocal-保存用户信息" class="headerlink" title="为什么使用 ThreadLocal 保存用户信息"></a>为什么使用 ThreadLocal 保存用户信息</h3><p>线程安全：<strong>避免多线程并发修改问题</strong>，将信息保存到线程内部，保证用户信息一致性</p>
<p>提高性能：第一层拦截器已经将用户信息保存到 ThreadLocal 中，第二层拦截器可以直接使用这些数据，而<strong>不需要重复查询 Redis</strong></p>
<hr>
<h3 id="权限怎么刷新"><a href="#权限怎么刷新" class="headerlink" title="权限怎么刷新"></a>权限怎么刷新</h3><p>也就是如何刷新 Redis 中的 token：EXPIRE、SETEX 命令</p>
<blockquote>
<p>Token：用于身份验证，是后端生成的，要发送给前端。以后每次请求前端要携带 Token </p>
</blockquote>
<hr>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><img src="D:\xmind\Typora\image\屏幕截图 2025-05-15 224105.png" alt="屏幕截图 2025-05-15 224105" style="zoom: 80%;" />

<p>实现复用登录校验和权限刷新的<strong>复用</strong></p>
<hr>
<h3 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h3><p>定义：缓存和数据库中的数据不同步</p>
<p>缓存更新策略</p>
<ul>
<li>内存淘汰：利用 Redis 的内存淘汰机制，当内存不足时自动淘汰部分数据</li>
<li>超时剔除：给缓存增加 TTL 时间，到期后自动删除缓存</li>
<li>主动更新：编写业务逻辑，在修改数据库的同时，更新缓存</li>
</ul>
<p>对于读数据：如果缓存未命中，会从数据库中加载数据到缓存</p>
<p>对于写数据，使用删除缓存模式：更新数据时更新数据库并删除缓存，查询时更新缓存（ 无效写操作较少 ）</p>
<ul>
<li>先删缓存再更新数据库，存在缓存击穿问题</li>
<li>先更新数据库再删缓存，存在脏读现象。</li>
</ul>
<p>将缓存和数据库操作放到同一个事务（ 实现方法：消息队列（ 更新数据库后，将更新缓存的请求发送到消息队列，这样可以异步地更新缓存））来保证原子性</p>
<hr>
<h3 id="缓存穿透、缓存雪崩、缓存击穿"><a href="#缓存穿透、缓存雪崩、缓存击穿" class="headerlink" title="缓存穿透、缓存雪崩、缓存击穿"></a>缓存穿透、缓存雪崩、缓存击穿</h3><p>缓存穿透</p>
<ul>
<li>客户端请求的数据在缓存和数据库中都不存在</li>
<li>解决方法</li>
</ul>
<ol>
<li><p>缓存空对象（ 当查询一个不存在的数据时，可以将这个空结果缓存一段时间 ）</p>
</li>
<li><p>布隆过滤器（ 用于测试一个元素是否存在一个集合中的概率数据结构（ 哈希函数和位数组 ））</p>
</li>
</ol>
<blockquote>
<p>工作原理：使用 N 个哈希函数对数据作哈希运算，得到 N 个哈希值，对位图数组长度取模，得到 <strong>N 个</strong>对应位置并置为 1</p>
<p>它说存在不一定数据库中有（ 哈希冲突 ），它说不存在数据库一定没有</p>
</blockquote>
<p>缓存雪崩</p>
<ul>
<li>同一段时间内，大量的缓存 key 同时失效或 Redis 服务宕机</li>
<li>解决方法</li>
</ul>
<ol>
<li>给不同的 Key 的 TTL 添加随机值（ 固定时间 + 一个范围的随机时间 ）</li>
<li>利用多级缓存 （ 本地缓存 ConcurrentHashMap 和 分布式缓存 Redis ）</li>
</ol>
<p>缓存击穿（ 热点 Key 问题 ）</p>
<ul>
<li>高并发访问的 Key 突然消失</li>
<li>解决方法</li>
</ul>
<ol>
<li>使用互斥锁（ SETNX ）：控制只有一个请求可以查询数据库并更新缓存，其他请求需要等待（ 避免了大量请求同时访问 ）</li>
</ol>
<blockquote>
<p>SETNX：给键赋值，当键不存在的时候才成功</p>
</blockquote>
<ol start="2">
<li>合理设置缓存过期时</li>
</ol>
<hr>
<h3 id="您能详细描述一下使用-Redis-实现全局唯一-ID-的过程吗？"><a href="#您能详细描述一下使用-Redis-实现全局唯一-ID-的过程吗？" class="headerlink" title="您能详细描述一下使用 Redis 实现全局唯一 ID 的过程吗？"></a>您能详细描述一下使用 Redis 实现全局唯一 ID 的过程吗？</h3><p>自增 ID 的问题</p>
<ul>
<li>id 的规律过于明显：容易出现信息泄漏</li>
<li>受表单数据量的限制：MySQL 中表能够存储的数据有限，会出现分库分表的情况，<strong>id 不能一直自增</strong></li>
</ul>
<p>时间戳 + 序列号（ 秒内计数器 ） +数据库自增</p>
<p>其他方法：雪花算法</p>
<hr>
<h3 id="乐观锁解决超卖问题"><a href="#乐观锁解决超卖问题" class="headerlink" title="乐观锁解决超卖问题"></a>乐观锁解决超卖问题</h3><ul>
<li><p>超卖问题一：库存减到了负数，但是每个线程在减库存之前<strong>会先判断库存是否充足</strong>，为什么还会发生超卖问题呢？</p>
<p>产生原因：假设两个线程，A 和 B，A 扣减库存是需要时间的，如果这之间又进入了一个线程 B，B 去判断库存发现库存是大于零的（ 因为 A 还没有扣减成功 ），而后 A 扣减库存成功，B不知道，又扣减库存</p>
</li>
<li><p>解决方法：</p>
</li>
</ul>
<ol>
<li><p>悲观锁：认为线程安全一定会发生，因此操作数据库之前需要先获取锁（ synchronized、lock ）</p>
</li>
<li><p>乐观锁：认为线程安全不一定会发生，不加锁，在更新数据库的时候判断判断有没有其它线程对数据进行修改实现方法：（ 版本号、 CAS ），不安全则抛出异常或中断</p>
</li>
</ol>
<ul>
<li><p>版本号法：新增一个版本号字段，线程 1 在进行库存扣减的同时将版本号 +1，线程 2 在进行扣减操作时，要先判断此时的版本号和查询库存时的版本号是否一致</p>
</li>
<li><p>CAS（ Compare-And-Swap ） 法：使用库存代替版本</p>
</li>
</ul>
<blockquote>
<p>读取内存地址 V 的当前值，将当前值与预期值（ 查询时的库存数 ） A 比较，如果当前值等于预期值则将 V 更新为新值 B，否则不进行更新，返回当前值</p>
</blockquote>
<hr>
<h3 id="一人一单的超卖问题"><a href="#一人一单的超卖问题" class="headerlink" title="一人一单的超卖问题"></a>一人一单的超卖问题</h3><img src="D:\xmind\Typora\image\屏幕截图 2025-06-08 151659.png" alt="屏幕截图 2025-06-08 151659" style="zoom:80%;" />

<ul>
<li>超卖问题二：一人购买了多次，增加了校验一人一单的操作（ 判断订单是否存在 ）为什么还会出现这个问题？</li>
</ul>
<p>​	产生原因：理由和上面的类似，创建订单是需要时间的</p>
<ul>
<li>解决方法：</li>
</ul>
<p>​	使用了悲观锁，将校验一人一单（  判断订单是否存在 ）和减库存、创建订单的操作锁起来</p>
<hr>
<h3 id="为什么使用分布式锁"><a href="#为什么使用分布式锁" class="headerlink" title="为什么使用分布式锁"></a>为什么使用分布式锁</h3><p>分布式锁定义：用于<strong>分布式环境下</strong>并发控制的一种机制，用于控制某个资源在同一时刻只能被一个应用使用</p>
<p>JVM 之间是相互独立的，每个 JVM 中的 synchronized 锁都是局部的、独立的锁。在集群环境中，两个运行在不同 JVM 上的程序无法共享同一个 synchronized 锁，锁失效。</p>
<p>所以需要分布式锁（ 在集群模式下多进程可见并且互斥的锁 ）</p>
<hr>
<h3 id="分布式锁优化"><a href="#分布式锁优化" class="headerlink" title="分布式锁优化"></a>分布式锁优化</h3><p>产生的问题：业务阻塞导致<strong>锁的超时释放</strong>，而后业务又完成了，释放锁的时候就出现了问题</p>
<p>分布式锁优化 1：产生原因：释放了别人的锁，解决方法：释放锁时判断这个锁是不是自己的锁</p>
<p>分布式锁优化 2：产生原因：判断是否是锁之后阻塞了，又释放了别人的锁（ 误判 ），解决方法：Lua 脚本（ 保障判断锁和释放锁这段代码的原子性 ）</p>
<p>为什么需要 Lua：解锁有两个操作，先判断该锁是否是加锁客户端，是的话，再将锁删除</p>
<p>Lua 保证原子性的原理：单线程执行，Redis 的事务支持（ Lua 脚本执行期间，Redis 不允许执行其他命令 ）</p>
<hr>
<h3 id="分布式锁为什么使用redisson而不是直接使用SETNX，redisson有什么优势吗？"><a href="#分布式锁为什么使用redisson而不是直接使用SETNX，redisson有什么优势吗？" class="headerlink" title="分布式锁为什么使用redisson而不是直接使用SETNX，redisson有什么优势吗？"></a>分布式锁为什么使用redisson而不是直接使用SETNX，redisson有什么优势吗？</h3><ul>
<li>功能丰富性：Redisson提供可重入锁（ 锁以 hash 结构存储在 Redis 中，每次获取锁 value 值 +1，释放锁 value 值 -1，当 value 值为 0 时才真正释放锁）、公平锁等，SETNX 不可重入（ 同一线程不能重复获取<strong>同一把锁</strong> ）</li>
</ul>
<blockquote>
<p>不可重入导致死锁：方法 A 中调用方法 B，方法 A、B 都要获取分布式锁（ 同一把锁 ），线程 1 进入方法 A 获取了一次锁，进入方法 B 又获取一次锁，由于锁不可重入，所以会导致死锁</p>
<p>SETNX：键不存在时才插入</p>
</blockquote>
<ul>
<li>自动续约功能：Redisson 在锁持有期间<strong>自动续约</strong>，确保锁不会过期</li>
<li>SETNX 不可重试，失败了就返回 false，Redisson 的 <strong>tryLock</strong>方法有<strong>超时释放机制和等待机制</strong></li>
<li>简洁 API：提供了简洁易用的 API，无需关心底层的 Redis 命令</li>
</ul>
<hr>
<h3 id="基于-Stream-结构实现消息队列（-异步秒杀优化-）"><a href="#基于-Stream-结构实现消息队列（-异步秒杀优化-）" class="headerlink" title="基于 Stream 结构实现消息队列（ 异步秒杀优化 ）"></a>基于 Stream 结构实现消息队列（ 异步秒杀优化 ）</h3><p>为什么要消息队列？将一个同步的程序变成两个异步的程序，其中一个程序读取另一个程序中放到消息队列中的数据，实现了效率提高</p>
<p>将判断秒杀库存和校验一人一单放进 Redis 里查询，并将优惠卷、用户id、订单 id 保存到阻塞队列，而后查询优惠卷、查询订单等操作可以异步去从队列中读取，实现了优化</p>
<img src="D:\xmind\Typora\image\屏幕截图 2025-05-19 202339.png" alt="屏幕截图 2025-05-19 202339" style="zoom: 67%;" />

<hr>
<h3 id="在实现异步秒杀下单时，您是如何保证消息的可靠性和一致性的？"><a href="#在实现异步秒杀下单时，您是如何保证消息的可靠性和一致性的？" class="headerlink" title="在实现异步秒杀下单时，您是如何保证消息的可靠性和一致性的？"></a>在实现异步秒杀下单时，您是如何保证消息的可靠性和一致性的？</h3><hr>
<h3 id="如何用-redis-的-Sortedset-做排行榜？"><a href="#如何用-redis-的-Sortedset-做排行榜？" class="headerlink" title="如何用 redis 的 Sortedset 做排行榜？"></a>如何用 redis 的 Sortedset 做排行榜？</h3><p>它能够存储唯一的元素，并且每个元素都有一个分数，可以根据这个分数进行排序</p>
<ul>
<li><strong>ZADD</strong> leaderboard 用户ID 得分：将用户得分添加到 SortedSet 中</li>
<li><strong>ZRANGE</strong> leaderboard 0 N-1 WITHSCORES：升序返回前 N 名，<strong>ZREVRANK</strong> 降序</li>
<li><strong>ZREM</strong> leaderboard 用户ID：移除某个用户</li>
</ul>
<hr>
<h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p>底层使用 Redis 中的 String 结构</p>
<p>键（ 用户 id + 日期  ） offset（ 第几天 ） 值（ 1 or 0 ）</p>
<hr>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring-中的事务如何实现"><a href="#Spring-中的事务如何实现" class="headerlink" title="Spring 中的事务如何实现"></a>Spring 中的事务如何实现</h3><p>事务管理的两种方式</p>
<ol>
<li><p>编程式事务管理：手动控制事务的开始、提交和回滚</p>
</li>
<li><p>声明式事务管理：通过注解，Spring 会为目标类创建一个代理对象，通过 JDK 动态代理：程序运行时生成一个新的对象，作用：对这个新的对象操作的时候就可以把操作传给被注释的对象</p>
</li>
<li><p>事务管理的<strong>原理</strong></p>
<p>AOP（ 面向切面编程 ），切面包括切入点和通知</p>
<p>切入点：程序执行的一个特定位置，例如：方法的调用或异常的抛出</p>
<p>通知：在切入点上执行的动作或逻辑，在目标方法的不同阶段插入自定义行为</p>
</li>
</ol>
<hr>
<h3 id="springboot-的-bean-创建方式"><a href="#springboot-的-bean-创建方式" class="headerlink" title="springboot 的 bean 创建方式"></a>springboot 的 bean 创建方式</h3><ul>
<li><p>Bean 的定义：由 Spring IoC 容器管理的对象，可以是任何一个类的实例</p>
</li>
<li><p>基于注解：</p>
<ol>
<li>@Component（ 标记一个类为 Spring 管理的 Bean）</li>
<li>@Service、@Reposity、@Controller 是 Component 的变种，标识服务层、数据访问层、控制层的 Bean</li>
</ol>
</li>
<li><p>基于 Java 配置类声明：@Configuration（ 类可以定义 Bean ） + @Bean（ 显示定义 Bean ）</p>
</li>
<li><p>基于 XML 配置</p>
</li>
</ul>
<hr>
<h3 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h3><ul>
<li>实例化（ @Component ）</li>
<li>依赖注入（ @Autowired ）</li>
<li>初始化</li>
</ul>
<ol>
<li>使用 @PostConstruct 注解：在方法上添加 <strong>@ PostConstruct</strong> 注解，Spring 会在依赖注入完成后调用该方法</li>
</ol>
<ul>
<li>销毁（ @PreDestroy ）</li>
</ul>
<hr>
<h3 id="IoC（-Inversion-of-Control-）"><a href="#IoC（-Inversion-of-Control-）" class="headerlink" title="IoC（ Inversion of Control ）"></a>IoC（ Inversion of Control ）</h3><p>控制反转：将对象的控制权交给外部容器（ IoC 容器 ），还不是在对象内部通过 new 的方式，是一种设计思想</p>
<p>好处：减少组件之间的耦合，提高可测试性（ 可以轻松模拟对象来代替真实对象 ）</p>
<h4 id="IoC-的实现方式：-DI"><a href="#IoC-的实现方式：-DI" class="headerlink" title="IoC 的实现方式： DI"></a>IoC 的实现方式： DI</h4><p>依赖注入（ Dependency Injection ）：通过将目标对象依赖的其他对象（ 依赖对象 ）在运行时注入到对象中</p>
<p>实现方法：</p>
<ul>
<li>构造函数注入：通过构造函数将依赖对象传递给目标对象（ new 出来的对象 ）</li>
<li>方法注入：调用方法时传递依赖项</li>
<li>字段注入：通过直接在字段上使用 @Autowired 注解进行注入（ 自动装配：Spring 框架提供的一个功能，框架能够自动识别并注入依赖对象，无需手动配置 ）</li>
</ul>
<hr>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>面向切面编程（ Aspect-Oriented Programming ）：是一种编程范式，允许我们在不修改原有业务逻辑的情况下，向代码中添加额外的功能，比如日志记录、事务管理、安全控制等</p>
<ul>
<li>横切关注点：多个类或对象中的<strong>公共行为</strong>（ 如日志记录、事务管理等 ）</li>
<li>切面：对横切关注点进行封装的类，用来实现具体的功能</li>
<li>连接点：程序执行中的一个点（ 如方法调用、对象创建 ）</li>
<li>通知：切面在某个连接点要执行的操作（ 前置、后置、环绕 ）</li>
<li>切点：定义了哪些连接点上应用切面</li>
<li>织入：将切面代码与业务逻辑代码结合的过程</li>
</ul>
<p><strong>原理</strong>：动态代理（ 在运行时创建代理对象的技术，代理对象可以拦截对目标方法的调用，并在调用之前或之后执行一些额外的操作 ）</p>
<ul>
<li><p>基于 JDK 的动态代理：是基于<strong>接口</strong>的代理方式，利用<strong>反射</strong>机制，在运行时创建一个实现了目标队形所实现的所有接口的代理对象，当调用代理对象的方法时，会触发 <code>InvocationHandler</code> 的 <code>invoke</code> 方法，在这个方法中可以添加额外的逻辑，从而实现对目标方法的增强</p>
</li>
<li><p>基于 CGLIB( Code Genertion Library ) 的动态代理：使用 CGLIB 库来创建代理对象，代理对象<strong>继承</strong>了目标对象，通过方法拦截来实现代码逻辑。</p>
</li>
</ul>
<hr>
<h3 id="Sprng-MVC"><a href="#Sprng-MVC" class="headerlink" title="Sprng MVC"></a>Sprng MVC</h3><p>是一个基于 Java 的框架，是 Spring 框架的一部分，用于构建 Web 应用程序，它遵循 MVC（ Model-View-Controller ）设计模式，旨在分离应用程序的不同关注点。与 SpringBoot 的区别是配置较麻烦，需要手动添加依赖，且没有内置的 Tomcat 服务器</p>
<ul>
<li>Model（ 模型 ）：代表应用程序的数据和业务逻辑，对应于数据库中的实体类</li>
<li>View（ 视图 ）：负责呈现数据给用户</li>
<li>Controller（ 控制器 ）：用于处理用户请求，调用相应的服务处进行业务处理，并返回视图</li>
</ul>
<hr>
<h3 id="SpringBoot-三级缓存解决循环依赖"><a href="#SpringBoot-三级缓存解决循环依赖" class="headerlink" title="SpringBoot 三级缓存解决循环依赖"></a>SpringBoot 三级缓存解决循环依赖</h3><p>和 Bean 的<strong>生命周期</strong>相关（ 实例化，依赖注入，初始化 ）</p>
<p>一级缓存：存放最终形态的 Bean（ 完成了实例化、依赖注入、初始化 ）</p>
<p>二级缓存：存放过渡 Bean（ 半成品，这些对象的<strong>依赖注入还没完成</strong> ），也就是三级缓存中 <code>ObjectFactory</code>产生的对象，作用：<strong>暴露</strong>出来供某个遇到循环依赖的对象使用。与三级缓存配合使用，可以<strong>防止</strong> AOP 情况下，每次调用会产生<strong>新的代理对象</strong></p>
<p>三级缓存：存放<code>ObjectFactory</code>（ Bean 的工厂方法 ），它的方法<code>getObject()</code>可以生成原始 Bean 对象或代理对象（ 虽然没有初始化完成，但是可以拿到该对象在堆中的内存地址了 ）</p>
<p>创建 Bean 的流程：</p>
<ol>
<li>先去一级缓存中获取，存在就返回；</li>
<li>如果不存在或者对象正在创建，就去二级缓存中获取；</li>
<li>如果还没有，就去三级缓存中获取，通过<code>ObjectFactory.getObject()</code>可以获取该对象，获取成功后，从三级缓存移除，并将该对象加入到二级缓存中</li>
</ol>
<p>缺点：增加了内存开销，非单例 Bean 和 @Async 注解的 Bean 无法支持循环依赖</p>
<hr>
<h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><ol>
<li>会根据依赖自动配置应用程序需要的 <strong>bean</strong></li>
<li>可以与 yml 文件（ 配置应用程序的属性 ）集成，可通过 yml 文件自定义自动配置的行为</li>
</ol>
<blockquote>
<p>自定义 yml 需要 <strong>@ConfigurationProperties( prefix &#x3D; ‘myapp’ )</strong>，@Value( “${ myapp.name }” )：用于从配置文件中注入单个值</p>
</blockquote>
<hr>
<h3 id="SpringBootApplication（-自动装配原理-）"><a href="#SpringBootApplication（-自动装配原理-）" class="headerlink" title="SpringBootApplication（ 自动装配原理 ）"></a>SpringBootApplication（ 自动装配原理 ）</h3><ul>
<li>@Configuration：定义一个 Java 类作为 Spring 的配置类，作用：告诉 Spring 容器，这个类包含了一个或多个 @Bean 方法，这些方法会被 Spring 容器管理</li>
<li>@EnableAutoConfiguration：启动自动配置功能</li>
<li>@ComponentScan：扫描当前包及其子包中的组件（ @Component ）</li>
</ul>
<hr>
<h3 id="Aop-环绕通知原理"><a href="#Aop-环绕通知原理" class="headerlink" title="Aop 环绕通知原理"></a>Aop 环绕通知原理</h3><p>不仅能在方法执行前后执行一些自定义的代码，还能控制方法是否执行，并且可以修改方法的返回值</p>
<p>@Aspect：定义一个切面类</p>
<p>@Around（ 切点 ）</p>
<p><strong>ProceedingJoinPoint 的 proceed() 方法</strong>：执行目标方法</p>
<hr>
<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="mybatis中-和-符号的区别"><a href="#mybatis中-和-符号的区别" class="headerlink" title="mybatis中 # 和 $ 符号的区别"></a>mybatis中 # 和 $ 符号的区别</h3><p>#：会创建<strong>预编译</strong>的 SQL 语句，将 SQL 中的 #{} 替换为 ？号，在执行 SQL 时为 ？（占位符）赋值，防止 <strong>SQL 注入</strong></p>
<blockquote>
<p>SQL 注入：传入的参数被恶意修改成 SQL 语句</p>
</blockquote>
<p>$：会<strong>直接</strong>将参数值替换到 SQL 语句中，导致 SQL 注入风险</p>
<hr>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a>TCP三次握手过程</h3><ul>
<li>一开始，客户端和服务端都处于 CLOSE 状态，先是服务端主动监听某个端口，处于 LISEN 状态</li>
<li>第一次握手：客户端向服务器发送一个 <strong>SYN</strong> 报文，报文中包含客户端的初始序列号，表示客户端请求连接，之后客户端处于 SYN-SENT 状态</li>
<li>第二次握手：服务端向客户端发送一个 <strong>SYN-ACK</strong> 报文。报文中包含服务器的初始序列号，确认应答号中是<code>客户端序列号 + 1</code>。之后服务端处于 *YN-RCVD 状态</li>
<li>第三次握手：客户端向服务端发送 <strong>ACK</strong> 报文，报文中的确认应答号为<code>服务端序列号 + 1</code>，可以携带客户端数据到服务端，之后客户端处于 ESTABLISHED 状态</li>
<li>服务端就受到客户端的应答报文后，也进入 ESTABLISHED 状态</li>
</ul>
<hr>
<h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><ul>
<li>第一次挥手：客户端发送一个 <strong>FIN</strong>（ 表示它已经没有数据要发送 ）报文给服务器，，但仍可以接收数据</li>
<li>第二次挥手：服务器发送一个 <strong>ACK</strong> 报文给客户端（ 表示收到了客户端的关闭请求 ），此时服务器可能还有数据需要发送，所以不会立刻关闭</li>
<li>第三次挥手：服务器数据全部发送完成，发送 FIN 报文给客户端，表示它也没有数据需要发送了，准备关闭连接</li>
<li>第四次挥手：客户端发送 ACK 报文给服务器。服务器收到 ACK 后就 CLOSE，客户端经过 2MSL（ MSL：报文最大生存时间，确保即使有延迟的报文段在网络中，也会在这段事件被丢弃，<strong>从而不会干扰到新连接</strong> ） 后 CLOSE</li>
</ul>
<hr>
<h3 id="一条-URL-到页面渲染的过程"><a href="#一条-URL-到页面渲染的过程" class="headerlink" title="一条 URL 到页面渲染的过程"></a>一条 URL 到页面渲染的过程</h3><ol>
<li><p>应用层：</p>
<ul>
<li><p>DNS 解析，浏览器先检查本地 DNS 缓存，没有的话，向 DNS 服务器发起查询</p>
</li>
<li><p>浏览器根据 URL 生成 HTTP 请求报文</p>
</li>
</ul>
</li>
<li><p>传输层：</p>
<ul>
<li>通过 TCP 三次握手与服务器建立连接</li>
<li>建立连接后，将 HTTP 请求通过 TCP 连接发送到目标服务器</li>
</ul>
</li>
<li><p>网络层：</p>
<ul>
<li>将 TCP 段封装成 IP 数据包（ 添加源 IP 地址和目的 IP 地址 ）</li>
<li>路由转发</li>
</ul>
</li>
<li><p>数据链路层：</p>
<ul>
<li>封装成帧：添加源和目的 MAC 地址</li>
</ul>
</li>
<li><p>物理层：</p>
<ul>
<li>通过物理媒介（ 电缆、光纤 ）传输，涉及电信号到光信号的转换</li>
</ul>
</li>
<li><p>服务端处理：</p>
<ul>
<li>根据请求的 URL 找到相应的资源，生成 HTTP 响应（ 状态码，响应头，请求体）</li>
<li>通过 TCP 连接发送回浏览器</li>
</ul>
</li>
<li><p>浏览器解析响应：提取出 HTML 内容</p>
</li>
<li><p>页面渲染</p>
</li>
</ol>
<hr>
<h3 id="HTTP-和-HTTPS的区别是什么？"><a href="#HTTP-和-HTTPS的区别是什么？" class="headerlink" title="HTTP 和 HTTPS的区别是什么？"></a>HTTP 和 HTTPS的区别是什么？</h3><ul>
<li>HTTPS 在传输层和网络层之间加入了 SSL&#x2F;TLS 协议，使得报文能够加密传输</li>
<li>HTTP 80、HTTPS 443</li>
<li>HTTPS 协议需要向 CA（ 证书权威机构 ）申请数字证书，来保证服务器的身份是可信的</li>
</ul>
<hr>
<h3 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h3><p>轻量级（ 为低带宽、不可靠网络设计 ）消息传输协议，多用于物联网设备之间的通信</p>
<p>发布&#x2F;订阅模式</p>
<ul>
<li>发布：客户端通过MQTT代理（ Mosquitto ）向特定的主题发送消息</li>
<li>订阅：客户端向MQTT代理（ Mosquitto ）请求接受特定主题消息</li>
<li>MQTT 提供三种 QoS（服务质量）等级</li>
</ul>
<ol>
<li>QoS 0：至多一次，可能丢失</li>
<li>QoS 1：至少一次，确保消息被送达，但可能重复</li>
<li>QoS 2：只有一次，确保消息被唯一地送达</li>
</ol>
<p>Eclipse Paho：一个用于实现 MQTT 协议的开源项目</p>
<hr>
<h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><ul>
<li>连接：TCP 传输前需要连接，UDP 不需要连接</li>
<li>服务对象：TCP 是一对一，UDP支持一对一、一对多（ 广播 ）、多对多</li>
<li>可靠性：TCP 可靠交付数据，UDP 尽最大努力，不保证可靠交付数据，但是可以在其基础上设计一个可靠传输协议 QUIC</li>
</ul>
<blockquote>
<p>连接管理：三次握手</p>
<p>超时重传</p>
<p>流量控制：为了防止接收方溢出，实现方式：滑动窗口</p>
<p>拥塞控制：为了防止网络拥塞，实现方式：慢开始、拥塞避免、快重传、快恢复</p>
</blockquote>
<ul>
<li>使用场景：TCP（ Web浏览、远程登录 ）、UDP（ 视频会议 ）</li>
</ul>
<hr>
<h3 id="HTTP1-0到3-0的版本更新所带来的新特性"><a href="#HTTP1-0到3-0的版本更新所带来的新特性" class="headerlink" title="HTTP1.0到3.0的版本更新所带来的新特性"></a>HTTP1.0到3.0的版本更新所带来的新特性</h3><ul>
<li>HTTP&#x2F;1.1</li>
</ul>
<ol>
<li>持久连接：允许多个请求通过同一个 TCP 连接</li>
<li>管道化：允许在一个连接上并行发送多个请求（ 只要第一个请求发出，不必等待其回来就可以发送第二个请求 ），但响应必须按照<strong>请求的顺序返回</strong>。缺点：如果一个请求阻塞，多个请求统统阻塞</li>
</ol>
<ul>
<li>HTTP&#x2F;2</li>
</ul>
<ol>
<li>头部压缩：通过 HPACK 算法（ 在客户端和服务器同时维护一张头信息表，字段会对应索引号，以后发送时就发送个索引号 ）进行头部压缩，减少了请求和响应的头部的大小</li>
<li>二进制分帧：将数据分割成更小的二进制帧（ 而不是纯文本形式的报文 ）</li>
<li>优先级：允许客户端为请求设置优先级</li>
<li>多路复用：同一连接上并行处理多个请求和响应，响应可以在<strong>任意顺序返回</strong>，消除了队头阻塞问题（ HTTP&#x2F;1.1 的串行请求 ）</li>
</ol>
<blockquote>
<p>串行请求：一次处理一个，处理完这个再处理下一个</p>
<p>并行处理：处理 A，发现 A 很耗时，先把处理过的返回 A，去执行 B，B 处理完后再处理 A</p>
</blockquote>
<ol start="5">
<li>缺点：多个 HTTP 复用一个连接，下层 TCP 协议<strong>不知道有多少个 HTTP 请求</strong>，会导致一旦发生丢包现象，所有的 HTTP 请求都必须等待这个丢了的包被重传</li>
</ol>
<ul>
<li>HTTP&#x2F;3</li>
</ul>
<ol>
<li>使用 QUIC（ 基于 UDP ） 作为传输层协议，好处：UDP 不管顺序和丢包，所以不会出现 HTTP&#x2F;1.1 的对头阻塞和 HTTP&#x2F;2 的一个丢包全部重传问题</li>
</ol>
<hr>
<h3 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h3><p>对称加密：使用同一个密钥</p>
<p>非对称加密：使用密钥对（ 公钥和私钥 ），发送方<strong>使用接收方的密钥</strong>加密，然后发给接收方</p>
<hr>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="协程是什么？有什么好处？"><a href="#协程是什么？有什么好处？" class="headerlink" title="协程是什么？有什么好处？"></a><strong>协程是什么？有什么好处？</strong></h3><ul>
<li>极高的性能：切换开销非常小（ 无需进行内核级的上下文切换 ）</li>
</ul>
<hr>
<h3 id="介绍一下操作系统的虚拟内存？"><a href="#介绍一下操作系统的虚拟内存？" class="headerlink" title="介绍一下操作系统的虚拟内存？"></a>介绍一下操作系统的虚拟内存？</h3><hr>
<h3 id="进程通信方式你知道哪些？"><a href="#进程通信方式你知道哪些？" class="headerlink" title="进程通信方式你知道哪些？"></a>进程通信方式你知道哪些？</h3><ul>
<li>管道</li>
<li>消息队列</li>
<li>共享内存</li>
</ul>
<hr>
<h2 id="进程、线程、协程的区别"><a href="#进程、线程、协程的区别" class="headerlink" title="进程、线程、协程的区别"></a>进程、线程、协程的区别</h2><ul>
<li>进程：是正在执行的程序的一个实例，操作系统中资源分配的基本单位，每个进程有独立的内存，由操作系统调度。使用场景：CPU密集型任务</li>
<li>线程：进程中的一个执行单元，共享同一进程的资源和内存，由操作系统调度，并发执行的任务。</li>
</ul>
<ol>
<li>轻量级：线程的上下文切换涉及的状态信息较少（ 主要是 CPU 寄存器和栈指针等 ）</li>
<li>创建开销小：只需要在进程的内存空间中分配少量的栈空间</li>
</ol>
<ul>
<li>协程：是一种用户态的<strong>轻量级</strong>（ 无需进行内核级的上下文切换 ）线程，调度由<strong>程序自身控制</strong>，不需要内核参与。使用场景：I&#x2F;O密集型任务（ 单个线程可以运行多个协程 ）</li>
</ul>
<hr>
<h3 id="IO多路复用是什么"><a href="#IO多路复用是什么" class="headerlink" title="IO多路复用是什么"></a>IO多路复用是什么</h3><p>允许程序在单一线程中同时监控多个IO流</p>
<blockquote>
<p>IO 操作：计算机系统和外部设备进行数据交换的过程</p>
</blockquote>
<hr>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="如何查看进程号状态"><a href="#如何查看进程号状态" class="headerlink" title="如何查看进程号状态"></a>如何查看进程号状态</h3><p><code>ps aux</code> ：显示所有用户进程</p>
<p><code>ps -ef | grep</code>：查找特定进程</p>
<p><code>top</code></p>
<hr>
<h3 id="查看线程"><a href="#查看线程" class="headerlink" title="查看线程"></a>查看线程</h3><p><code>top -H</code></p>
<p><code>ps -T -p 1234</code></p>
<hr>
<h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><p><code>ls</code> ：列出目录内容</p>
<p><code>cd</code>：更改当前目录</p>
<p><code>mv</code>：移动文件</p>
<p><code>rm</code>：删除文件</p>
<p><code>mkdir</code>：创建信目录</p>
<p><code>touch</code>：创建空文件</p>
<p><code>grep &#39;example&#39; test.txt</code>：查找文件内容、<code>grep -r &#39;example&#39; .</code>：递归查找当前目录及子目录下所有文件中包含 example 的行</p>
<hr>
<h2 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h2><p>定义：一种策略，通过与业务需求紧密结合来<strong>提高软件质量</strong></p>
<p>将开发人员和领域专家（ 业务人员 ）联系的更紧密</p>
<p>分为战略设计（ 应用的更高层 ）和战术设计（ 应用的较低层 ）</p>
<hr>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>定义：一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议</p>
<hr>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li><p>单例模式：确保一个类只有一个实例，并提供一个全局访问点（ 在类里创建实例 ）</p>
</li>
<li><p>工厂模式：通过一个工厂（ 方法 ）来创建不同类型的对象，而不是 new。作用：隐藏创建的细节，提高扩展性</p>
</li>
</ul>
<hr>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>定义：一个 Vue 实例自创建到销毁的过程</p>
<p>钩子函数</p>
<ul>
<li>创建阶段</li>
</ul>
<p>beforeCreate：在Vue 实例刚刚被创建时触发。不能访问到 data</p>
<p>created：在实例创建后、数据初始化完成后被调用。可以访问到 data</p>
<ul>
<li>挂载阶段</li>
</ul>
<p>beforeMount：在 Vue 实例挂在之前调用。</p>
<blockquote>
<p>挂载：将虚拟 DOM （ Vue实例创建后，数据和模板没有直接出现在浏览器上，而是存在一个虚拟节点中 ）渲染并插入到我们指定的 DOM 节点</p>
</blockquote>
<p>mounted：在 Vue 实例挂载到 DOM 上并渲染完成后，调用</p>
<ul>
<li>更新阶段</li>
</ul>
<p>beforeUpdate：数据更新之前调用，虚拟 DOM 已经更新，实际 DOM 尚未改变</p>
<p>updated：数据更新并且 DOM 重新渲染后调用</p>
<ul>
<li>销毁阶段</li>
</ul>
<p>beforeDestroy：在 Vue 实例销毁之前调用</p>
<p>destroy：Vue实例销毁之后调用</p>
]]></content>
  </entry>
  <entry>
    <title>小程序项目</title>
    <url>/2025/04/07/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="小程序项目"><a href="#小程序项目" class="headerlink" title="小程序项目"></a>小程序项目</h1><h3 id="1-近期目标"><a href="#1-近期目标" class="headerlink" title="1. 近期目标"></a>1. 近期目标</h3><p>算法、面经＋牛肉去完善基础八股、项目的面试问题</p>
<p>学习消息队列：RabbitMQ</p>
<p>核心竞争力？开源项目、真实的商业项目（ 实习、汉中PDA应该算 ）</p>
<p>微信小程序上传照片，包括微信开发者工具和后端</p>
<p>使用 AI 编程工具（不懂原理，但是会用），了解大模型（懂原理）</p>
<p>在github或什么上留下几千星的clone，不也是留下了什么</p>
<p>目前云服务器域名在备案，等待备案完成后解决小程序无法通过url访问的问题，目前看到的解决方法是去小程序开发官网找到开发-开发设置-业务域名，去设置。pdf 已经实现了直接通过url访问</p>
<hr>
<h3 id="2-目前完成的工作"><a href="#2-目前完成的工作" class="headerlink" title="2. 目前完成的工作"></a>2. 目前完成的工作</h3><ol>
<li>售后服务的上传表单功能(没有上传照片)   </li>
<li>保养功能的上传照片功能，保存在云服务器的 <code>/var/www/html/images</code> 中, <code>url</code>也已经保存在数据库中</li>
</ol>
<hr>
<h3 id="3-注意"><a href="#3-注意" class="headerlink" title="3. 注意"></a>3. 注意</h3><ol>
<li>IDEA中删除东西时，小心<strong>默认点击</strong>的文件也被删除了</li>
</ol>
<hr>
<h3 id="4-后端（Backend）"><a href="#4-后端（Backend）" class="headerlink" title="4. 后端（Backend）"></a>4. 后端（Backend）</h3><h4 id="4-0-什么是后端？"><a href="#4-0-什么是后端？" class="headerlink" title="4.0 什么是后端？"></a>4.0 什么是后端？</h4><p><em><strong>用户请求处理、逻辑处理、数据处理</strong></em></p>
<h4 id="4-1-打包相关命令"><a href="#4-1-打包相关命令" class="headerlink" title="4.1  打包相关命令"></a>4.1  打包相关命令</h4><p>打 jar 包命令 <code>mvn package</code>  </p>
<p>我的 jar 包放在 <code>/home</code>中  </p>
<p>运行 jar 包命令 <code>java -jar 包名</code>  </p>
<h4 id="4-2-创建后端项目"><a href="#4-2-创建后端项目" class="headerlink" title="4.2 创建后端项目"></a>4.2 创建后端项目</h4><ol>
<li>创建新的空文件夹并在IDEA中打开</li>
<li><code>New module</code></li>
<li><code>Spring Initiallizr</code></li>
</ol>
<blockquote>
<p>取项目名 选择JDK版本 更改 GroupId（ 后续项目中 java 文件下的名字 ） </p>
<p>勾选依赖：Lombok、Spring Web、MySQL Driver  </p>
</blockquote>
<ol start="4">
<li>删掉项目里一些自动生成且不需要的文件  </li>
<li>加入<code>mybatis-plus</code>支持</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;  // 也可以去官网寻找,这个是springboot2版本</span><br></pre></td></tr></table></figure>

<p><a href="https://baomidou.com/">MyBatis-plus官网</a>  </p>
<ol start="6">
<li>新建一个 HelloController 测试一下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController  // 标识这个类是一个REST控制器，控制器返回的对象会自动化序列化为JSON格式，是		  					  @Controller 和 @ResponseBody 的组合简化形式</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @GetMapping // 处理客户端发送来的GET请求</span><br><span class="line">    public String hello()&#123;</span><br><span class="line">        return &quot;hello wms&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>REST控制器：用于处理和响应RESTful Web服务请求的组件，允许客户端通过HTTP协议与服务器进行通信</p>
</blockquote>
<ol start="7">
<li>创建数据库实例</li>
</ol>
<blockquote>
<p>数据库在很多情况下需要<em><strong>刷新</strong></em>才能显示</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE USER（表名）</span><br><span class="line">(</span><br><span class="line">    id INT AUTO_INCREMENT COMMENT &#x27;主键&#x27; </span><br><span class="line">    PRIMARY KEY,</span><br><span class="line">    NO VARCHAR(20) NULL COMMENT &#x27;账号&#x27;,</span><br><span class="line">    NAME VARCHAR(100) NOT NULL COMMENT &#x27;名字&#x27;,</span><br><span class="line">    PASSWORD VARCHAR(20) NOT NULL COMMENT &#x27;密码&#x27;,</span><br><span class="line">    age INT NULL,</span><br><span class="line">    sex INT NULL COMMENT &#x27;性别&#x27;,</span><br><span class="line">    phone VARCHAR(20) NULL COMMENT &#x27;电话&#x27;,</span><br><span class="line">    role_id INT NULL COMMENT &#x27;角色 0超级管理员, 1管理员，2普通账号&#x27;,</span><br><span class="line">    isValid VARCHAR(4) DEFAULT &#x27;Y&#x27; NULL COMMENT &#x27;是否有效，Y有效，其他无效&#x27;</span><br><span class="line">)</span><br><span class="line">    CHARSET = utf8;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：（）中的最后一行不要有逗号，这是语法错误</p>
</blockquote>
<ol start="8">
<li>配置 <code>yml</code>文件，将自带的 <code>properties</code> 配置文件改为 <code>yml</code></li>
</ol>
<blockquote>
<p>作用：连接数据库</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080  // 这个后端应用程序将运行在本地的 8080 端口上</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/wms02(数据库名)?serverTimezone=Asia/Shanghai</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3306 是 Mysql 数据库的默认端口</p>
</blockquote>
<ol start="9">
<li>编写测试代码</li>
</ol>
<ul>
<li>创建实体类</li>
</ul>
<blockquote>
<p>注意要对应数据库中的字段 </p>
<p>数据库和 JAVA 对应字段规则：JAVA中的大写对应数据库中的_</p>
<blockquote>
<p>数据库中有下划线，JAVA中用大写</p>
<p>数据库中是大写，JAVA中用小写</p>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Entity  // 表示其是JPA( java Persistence API )的实体类，该类的实例会被映射到数据库中的一张表</span><br><span class="line">@Table(name = &quot;xxx&quot;) // 选择表的名字，没有这个的话，会自动根据类名要求你有这个表。标记了name也可能报错，最好的办法就是听它的（创建一个它要的表名）</span><br><span class="line">@Data  // 是 Lombok 提供的一个注解，自动生成getter、setter、toString()等方法</span><br><span class="line">public class User &#123;</span><br><span class="line">	@Id  // 标记实体的主键</span><br><span class="line">    private int id;</span><br><span class="line">    private String no;</span><br><span class="line">    private String name;</span><br><span class="line">    private String password;</span><br><span class="line">    private int sex;</span><br><span class="line">    private int roleId;</span><br><span class="line">    private String isvalid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@Entity和Table需要新增 pom 依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></blockquote>
<ul>
<li>创建mapper接口</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>控制反转和依赖注入是什么？</p>
<blockquote>
<p>控制反转（IoC）：把对象的创建交给Spring容器来控制，称为Bean</p>
</blockquote>
<blockquote>
<p>依赖注入：将一个类依赖的对象（Bean）注入进去，而不是自己创建</p>
</blockquote>
<p>@Mapper：将这个接口注册为<strong>Bean</strong>，后续就可以在Service层中<strong>依赖注入</strong>这个Mapper接口</p>
<p>BaseMapper<User>：Mybatis-plus提供的一个通用Mapper接口，提供了许多常用的CRUD操作，作用：UserMapper可以直接使用与User实体相关的CRUD操作</p>
</blockquote>
<ul>
<li><p>创建service接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface UserService extends IService&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Iservice<User>：Mybatis-plus提供的通用接口，提供了一系列数据库的CRUD操作方法</p>
<p><strong>为什么需要接口和实现类？</strong></p>
<blockquote>
<p>接口定义了类所必须实现的一组方法，但不关心这些方法是如何具体实现的</p>
</blockquote>
<blockquote>
<p>实现类具体实现了接口中的方法，<strong>实现了特定业务</strong></p>
</blockquote>
<blockquote>
<p>好处：解耦</p>
</blockquote>
</blockquote>
</li>
<li><p>创建service实现类</p>
</li>
</ul>
<p>新建一个impl文件夹，创建UserServiceImpl</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@Service：将这个类注册为Spring容器中的一个Bean，之后可以依赖注入</p>
<p>ServiceImpl&lt;UserMapper,User&gt;：Mybatis-Plus提供的通用服务实现类，作用：UserServiceImpl（继承它的类）可以直接使用CRUD操作。</p>
<p>ServiceImpl通过UserMapper，提供对数据库的访问（特定业务）</p>
</blockquote>
<ul>
<li>在HelloCroller中测试</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @GetMapping</span><br><span class="line">    public String hello()&#123;</span><br><span class="line">        return &quot;hello wms&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	//新增测试代码</span><br><span class="line">    @Autowired  // 自动装配，自动注入UserService实例</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/list&quot;)</span><br><span class="line">    public List&lt;User&gt; list()&#123;</span><br><span class="line">        return userService.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以自己去创建一个UserService</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// HelloCtroller中</span><br><span class="line">@GetMapping(&quot;/list&quot;)</span><br><span class="line">    public List&lt;User&gt; list()&#123;</span><br><span class="line">        return userService.listAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">// UserService中去声明</span><br><span class="line">public interface UserService extends IService&lt;User&gt; &#123;</span><br><span class="line">    List&lt;User&gt; listAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UserServiceImpl 中去实现</span><br><span class="line">@Service</span><br><span class="line">public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123;</span><br><span class="line">    @Resource  // 也是用于依赖注入</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line">    @Override  // 表示其是对接口方法的重写</span><br><span class="line">    public List&lt;User&gt; listAll() &#123;</span><br><span class="line">        return userMapper.listAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//UserMapper 中</span><br><span class="line">@Mapper</span><br><span class="line">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line">    List&lt;User&gt; listAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步，去resource中新建文件夹Mapper并在其中新建文件UserMapper.xml  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.wms.mapper.UserMapper&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;listAll&quot; parameterType=&quot;com.wms.entity.User&quot;&gt;</span><br><span class="line">        select * from  user</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作用：为UserMapper接口提供了一个SQL查询操作 listAll</p>
<p>listAll 会执行 select * from  user 语句，从 user表中查询数据</p>
<p>查询结果会自动映射到 com.wms.entity.User 类型的对象并返回调用方</p>
<blockquote>
<p>映射：在Mybatis中，映射指的是将SQL查询的结果集转换成 Java 对象的过程</p>
</blockquote>
<p>namespace：作用：将 XML 中定义的 SQL 语句和 Java 接口中的方法绑定</p>
<p>parameterType：作用：指定了 SQL 操作所接收的参数类型</p>
</blockquote>
<p>运行测试。。。</p>
<h4 id="4-3-实现增删改查"><a href="#4-3-实现增删改查" class="headerlink" title="4.3 实现增删改查"></a>4.3 实现增删改查</h4><ol>
<li>新增</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/save&quot;)</span><br><span class="line">    public boolean save(@RequestBody User user)&#123;</span><br><span class="line">        return userService.save(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@RequestBody：将HTTP请求的主体（body）映射到方法的参数上，在这里是将去请求的的 JSON 数据转换为 User 类型的对象</p>
<p>GET：请求的数据通过 URL 传递</p>
<p>POST：请求的数据通过请求体（body）发送，而不是通过 URL ，请求体中可以包含表单数据、JSON数据等</p>
</blockquote>
<ol start="2">
<li>修改</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/mod&quot;)</span><br><span class="line">    public boolean mod(@RequestBody User user)&#123;</span><br><span class="line">        return userService.updateById(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>新增或修改</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/saveOrMod&quot;)</span><br><span class="line">   public boolean saveOrMod(@RequestBody User user)&#123;</span><br><span class="line">       return userService.saveOrUpdate(user);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>删除</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/delete&quot;)</span><br><span class="line">    public boolean delete(Integer id)&#123;</span><br><span class="line">        return userService.removeById(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>查询（模糊、匹配）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/listP&quot;)</span><br><span class="line">   public List&lt;User&gt; listP(@RequestBody User user)&#123;</span><br><span class="line">       LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper();</span><br><span class="line">       lambdaQueryWrapper.like(User::getName,user.getName());</span><br><span class="line">       return userService.list(lambdaQueryWrapper);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作用：查询数据库中与请求体的 User 对象的 name 属性匹配的所有对象</p>
<p>LambdaQueryWrapper是 Mybatis-Plus 提供的一个工具类，用于构建数据库查询条件，作用：就像是写了SQL查询语句一样</p>
<p>lambdaQueryWrapper.like：模糊匹配，.equal就是完全匹配</p>
<p>这里使用的是自带的 list 方法，可以直接传 lamdaQuerywrapper</p>
<p>如果自己新建一个方法传它需要多两步（mapper 和 xml 文件中），可以在Mybatis-Plus的官网的条件构造器中查到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IPage result = userService.pageCC(page,lambdaQueryWrapper); //Controller</span><br><span class="line"></span><br><span class="line">IPage pageCC(IPage&lt;User&gt; page, Wrapper wrapper); // Service</span><br><span class="line"></span><br><span class="line">public IPage pageCC(IPage&lt;User&gt; page, Wrapper wrapper) &#123;  //ServiceImpl</span><br><span class="line">   return userMapper.pageCC(page,wrapper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IPage pageCC(IPage&lt;User&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;User&gt; wrapper); </span><br><span class="line">// Mapper</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;pageCC&quot; resultType=&quot;com.wms.entity.User&quot;&gt;</span><br><span class="line"> select * from  user $&#123;ew.customSqlSegment&#125;</span><br><span class="line">&lt;/select&gt;  // xml</span><br></pre></td></tr></table></figure>

</blockquote>
<ol start="6">
<li>使用Postman时注意</li>
</ol>
<p><img src="D:\xmind\Typora\image\postman.png"></p>
<h4 id="4-4-分页的实现"><a href="#4-4-分页的实现" class="headerlink" title="4.4 分页的实现"></a>4.4 分页的实现</h4><ol>
<li>封装分页请求的参数：新建和 controller 平级的文件夹 common ，并创建 QueryPageParam 文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class QueryPageParam &#123;</span><br><span class="line">    private static int PAGE_SIZE = 20;</span><br><span class="line">    private static int PAGE_NUM = 1;</span><br><span class="line"></span><br><span class="line">    private int pageSize=PAGE_SIZE;</span><br><span class="line">    private int pageNum=PAGE_NUM;</span><br><span class="line"></span><br><span class="line">    private HashMap param =new HashMap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>静态方法（static）：不依赖于对象进行访问，方便在没有创建对象的情况下进行调用  </p>
<p>pageNum：页数</p>
<p>pafeSize：每页的数据量  </p>
<p><code>offset = (pageNum - 1) * pageSize</code>：表示从数据源中查询结果时，跳过了多少条数据</p>
</blockquote>
<p>再在 HelloController 中新增  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/listPage&quot;)</span><br><span class="line">public List&lt;User&gt; listPage(@RequestBody QueryPageParam query)&#123;</span><br><span class="line">    System.out.println(query);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;num===&quot; + query.getPageNum());</span><br><span class="line">    System.out.println(&quot;size===&quot; + query.getPageSize());</span><br><span class="line"></span><br><span class="line">    HashMap param = query.getParam();</span><br><span class="line">    System.out.println(&quot;name===&quot; + param.get(&quot;name&quot;));</span><br><span class="line">    System.out.println(&quot;no===&quot; + param.get(&quot;no&quot;));</span><br><span class="line"></span><br><span class="line">    return null;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>添加分页拦截器</li>
</ol>
<p>在 common 中创建 MybatisPlusConfig 文件  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MybatisPlusConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;</span><br><span class="line">        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</span><br><span class="line">        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));</span><br><span class="line">        return interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@Configuration：MybatisPlusConfig 是一个配置类，里面定义的 Bean 可以被 Spring 管理</p>
<p>作用：只需传入当前页码和每页显示的数量，MyBatis Plus 会<strong>自动生成</strong>适当的 SQL 查询来获取相应的数据。</p>
</blockquote>
<ol start="3">
<li>在HelloController中利用 MybatisPlus 提供的封装对象 <strong>Page</strong> 去分页</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> @PostMapping(&quot;/listPage&quot;)</span><br><span class="line">    public List&lt;User&gt; listPage(@RequestBody QueryPageParam query)&#123;</span><br><span class="line"></span><br><span class="line">        HashMap param = query.getParam();</span><br><span class="line">        String name = (String)param.get(&quot;name&quot;);</span><br><span class="line"></span><br><span class="line">        Page&lt;User&gt; page = new Page();  // Page&lt;User&gt;：MybatisPlus 提供的分页对象</span><br><span class="line">        page.setCurrent(query.getPageNum());</span><br><span class="line">        page.setSize(query.getPageSize());</span><br><span class="line"></span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper();</span><br><span class="line">        lambdaQueryWrapper.like(User::getName,name);</span><br><span class="line"></span><br><span class="line">        IPage result = userService.page(page,lambdaQueryWrapper);  // Ipage：MybatisPlus提供的接口，用于封装分页查询的结果</span><br><span class="line">        System.out.println(&quot;total===&quot; + result.getTotal());  // 打印总记录数</span><br><span class="line">        return result.getRecords();  // 返回当前页的用户记录</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将 page 作为对象传入会自动生成分页的 SQL </p>
</blockquote>
<ol start="4">
<li>也可以自己在 HelloController中去定义一个userService的方法，然后去UserService声明方法，UserServiceImpl去实现，再在UserMapper中声明方法，最后在xml中写SQL语句</li>
</ol>
<blockquote>
<p>注意： UserServiceImpl 中需要依赖注入UserMapper，使用它的方法</p>
</blockquote>
<h4 id="4-5-返给前端数据的封装"><a href="#4-5-返给前端数据的封装" class="headerlink" title="4.5 返给前端数据的封装"></a>4.5 返给前端数据的封装</h4><ol>
<li>在 common 中新建 Result 类</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Result &#123;</span><br><span class="line">    private int code;  // 编码200/400</span><br><span class="line">    private String msg;  // 成功/失败</span><br><span class="line">    private Long total;  // 总记录数</span><br><span class="line">    private Object data;  // 数据</span><br><span class="line"></span><br><span class="line">    public static Result fail()&#123;</span><br><span class="line">        return result(400, &quot;失败&quot;, 0L, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Result suc()&#123;</span><br><span class="line">        return result(200, &quot;成功&quot;, 0L, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Result suc(Object data)&#123;</span><br><span class="line">        return result(200, &quot;成功&quot;, 0L, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Result suc(Object data, Long total)&#123;</span><br><span class="line">        return result(200, &quot;成功&quot;, total, data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static Result result(int code,String msg,Long total,Object data)&#123;</span><br><span class="line">        Result res = new Result();</span><br><span class="line">        res.setCode(code);</span><br><span class="line">        res.setMsg(msg);</span><br><span class="line">        res.setTotal(total);</span><br><span class="line">        res.setData(data);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将 HelloController 中的返回值类型改为我自己创建的 Result 类</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/listPageC1&quot;)</span><br><span class="line">    public Result listPageC1(@RequestBody QueryPageParam query) &#123;</span><br><span class="line"></span><br><span class="line">        HashMap param = query.getParam();</span><br><span class="line">        String name = (String) param.get(&quot;name&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Page&lt;User&gt; page = new Page();  // Page&lt;User&gt;：MybatisPlus 提供的分页对象</span><br><span class="line">        page.setPages(query.getPageNum());</span><br><span class="line">        page.setSize(query.getPageSize());</span><br><span class="line"></span><br><span class="line">/*        LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper();</span><br><span class="line">        lambdaQueryWrapper.like(User::getName,name);*/</span><br><span class="line"></span><br><span class="line">        IPage result = userService.pageC(page);</span><br><span class="line">        System.out.println(&quot;total===&quot; + result.getTotal());  // 打印总记录数</span><br><span class="line">        return Result.suc(result.getRecords(),result.getTotal());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>利用框架提供的方法：<code>ResponseEntity </code>类</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/afterSale&quot;)</span><br><span class="line">public ResponseEntity&lt;Void&gt; save(@RequestBody AfterSale afterSale)&#123;</span><br><span class="line">    afterSaleService.save(afterSale);</span><br><span class="line">    return ResponseEntity.ok().build();  // 生成一个状态码 200 的响应，没有响应体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ResponseEntity：Spring Web中的一个类，处理 HTTP 响应的一个重要类</p>
</blockquote>
<hr>
<h3 id="5-微信开发者工具"><a href="#5-微信开发者工具" class="headerlink" title="5. 微信开发者工具"></a>5. 微信开发者工具</h3><blockquote>
<p>此节目的：知道这些配置在哪，然后去<a href="https://developers.weixin.qq.com/doc/">微信开发者文档</a>查看细节  </p>
<blockquote>
<p>前端<strong>界面设计</strong>方法论：要有<strong>块</strong>的概念，每一块都用 view <strong>包裹</strong>起来，作用：更好布局</p>
<blockquote>
<p>父组件看自己里面包含的东西就是看作一个块</p>
</blockquote>
<p>微信小程序的调试器的Wxml左边的按钮可以看到界面上<strong>DOM的布局</strong>，方便进行<strong>调试</strong>（网页上也可以通过这个按钮去看布局）</p>
</blockquote>
</blockquote>
<h4 id="5-1-全局配置"><a href="#5-1-全局配置" class="headerlink" title="5.1 全局配置"></a>5.1 <strong>全局配置</strong></h4><p><code>tabBar</code>：底部栏</p>
<blockquote>
<p>照片的路径 syntax</p>
<p>本地：&#x2F;images（自己创建的文件夹）&#x2F;xxx</p>
<p>远程服务器： <a href="http://47.109.96.127/images/hanji1.png">http://47.109.96.127/images/hanji1.png</a></p>
</blockquote>
<h4 id="5-2-页面配置"><a href="#5-2-页面配置" class="headerlink" title="5.2 页面配置"></a>5.2 <strong>页面配置</strong></h4><blockquote>
<p>在<strong>window</strong>属性里配置</p>
</blockquote>
<p><code>navigationBarTitleText</code>：页标题  </p>
<p><code>navigationBarBackgroundColor</code>：导航栏背景颜色</p>
<h4 id="5-3-组件"><a href="#5-3-组件" class="headerlink" title="5.3 组件"></a>5.3 组件</h4><p><code>swiper</code>：滑块视图容器  </p>
<p><code>image</code>：图片 </p>
<blockquote>
<p>mode：防止图片变形</p>
</blockquote>
<p><code>button</code>：按钮  </p>
<p><code>input</code>：输入框</p>
<blockquote>
<p>bindinput&#96;&#x3D;“xxx（自定义函数）”：作用：键盘输入时或内容改变时触发这个函数</p>
</blockquote>
<h4 id="5-4-重要属性"><a href="#5-4-重要属性" class="headerlink" title="5.4 重要属性"></a>5.4 重要属性</h4><p><code>width：100%  </code></p>
<p><code>height：100vh</code>：设置元素高度，1vh等于视口高度的1%   </p>
<p><code>text-align：center</code>：水平居中对齐文本  </p>
<p><code>border-bottom: darkgrey solid 1px</code>：边框颜色和厚度</p>
<h4 id="5-5-API"><a href="#5-5-API" class="headerlink" title="5.5 API"></a>5.5 API</h4><p><code>wx.navigateTo</code>：保存当前界面，跳转到应用内的某个界面，但是不能跳转到<code>tabbar</code>页面</p>
<blockquote>
<p>可以通过将父包裹元素设置上事件，来实现<strong>被包裹的元素的点击事件都为它</strong> </p>
</blockquote>
<p><code>wx.showToast</code>：在页面上显示一个提示框  </p>
<p><code>wx.request</code>：发送 HTTPS 网络请求</p>
<h4 id="5-6-使用-iconfont-的步骤"><a href="#5-6-使用-iconfont-的步骤" class="headerlink" title="5.6 使用 iconfont 的步骤"></a>5.6 使用 iconfont 的步骤</h4><ol>
<li>去官网选择图标加入项目</li>
<li>复制代码去浏览器打开  </li>
<li>创建一个和 page <strong>平级</strong>的文件夹 styles  </li>
<li>在 styles 里创建 iconfont.wxss 文件，将第二步复制的代码粘贴进去  </li>
<li>在 app.wxss 里导入</li>
</ol>
<p><code>@import &quot;/styles/iconfont.wxss&quot;;</code></p>
<h4 id="5-7-框架接口"><a href="#5-7-框架接口" class="headerlink" title="5.7 框架接口"></a>5.7 框架接口</h4><p><code>App</code>：在<code>app.js</code>中，作用：注册小程序，指定小程序的生命周期回调等  </p>
<p><code>Page</code>：在<code>页面.js</code>中，作用：注册页面，指定页面的初始数据、生周期回调、事件处理函数等  </p>
<blockquote>
<p><code>data</code>：是响应式的，作用：存储和管理数据 </p>
<blockquote>
<p>使用 <strong><code>setData</code></strong> 方法，可以将变化的数据自动渲染到前端页面</p>
</blockquote>
</blockquote>
<h4 id="5-8-实现上传表单功能"><a href="#5-8-实现上传表单功能" class="headerlink" title="5.8 实现上传表单功能"></a>5.8 实现上传表单功能</h4><ol>
<li>在<code>data</code>中定义变量</li>
<li>在<code>input</code>组件的属性<code>bindinput</code>绑定函数，在函数中编写<strong>更新页面数据的方法</strong>（<code>setData</code>），完成响应式</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onModelInput(event) &#123;</span><br><span class="line">  this.setData(&#123;</span><br><span class="line">    model: event.detail.value</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在<code>button</code>组件绑定的方法中实现<code>request</code></li>
</ol>
<blockquote>
<p>预处理：通过解构赋值取出变量，并检查是否表单都有输入，没有的话进行提示</p>
<blockquote>
<p>解构赋值：直接对多个变量同时赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">submitForm()&#123;</span><br><span class="line"> const &#123;model, serial,fault&#125; = this.data;</span><br><span class="line"> if(!model || !serial || !fault)&#123;</span><br><span class="line">   wx.showToast(&#123;</span><br><span class="line">     title: &#x27;请填写完整信息&#x27;,</span><br><span class="line">     icon: &#x27;none&#x27;</span><br><span class="line">   &#125;)</span><br><span class="line">   return;  // 如果满足条件，则退出，不执行后面的 request</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">      url:&#x27;http://localhost:8080/user/afterSale&#x27;,</span><br><span class="line">      method:&#x27;POST&#x27;,</span><br><span class="line">      header:&#123;</span><br><span class="line">        &#x27;Content-Type&#x27;:&#x27;application/json&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      data:&#123;</span><br><span class="line">        model:model,</span><br><span class="line">        serial:serial,</span><br><span class="line">        fault:fault</span><br><span class="line">      &#125;,</span><br><span class="line">      success:(res) =&gt;&#123;  // 这是一个成功回调函数</span><br><span class="line">        if(res.statusCode === 200)&#123;</span><br><span class="line">          wx.showToast(&#123;</span><br><span class="line">            title:&#x27;提交成功&#x27;,</span><br><span class="line">            icon:&#x27;success&#x27;  // 显示的图标</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          wx.showToast(&#123;</span><br><span class="line">            title:&#x27;提交失败&#x27;,</span><br><span class="line">            icon:&#x27;none&#x27;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="5-9-登录功能实现"><a href="#5-9-登录功能实现" class="headerlink" title="5.9 登录功能实现"></a>5.9 登录功能实现</h4><p>整体流程：小程序端调用wx.login()API获得code，code传递给后端，后端向微信接口服务发送HTTP请求，得到openId，返回给小程序</p>
<p>小程序端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    // 用于存储用户信息</span><br><span class="line">    userInfo: null,</span><br><span class="line">    logged: false</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  login: function() &#123;</span><br><span class="line">    // 调用 wx.login 获取用户的临时登录凭证 code</span><br><span class="line">    wx.login(&#123;</span><br><span class="line">      success: res =&gt; &#123;</span><br><span class="line">        if (res.code) &#123;</span><br><span class="line">          // 成功获取到 code 后，发送到后台进行处理</span><br><span class="line">          this.getOpenId(res.code);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          console.log(&#x27;登录失败！&#x27; + res.errMsg);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: err =&gt; &#123;</span><br><span class="line">        console.log(&#x27;wx.login调用失败&#x27;, err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 获取 openid 的函数</span><br><span class="line">  getOpenId: function(code) &#123;</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: &#x27;http://localhost:8080/api/getOpenId&#x27;,  // 你的后端接口 </span><br><span class="line">      method: &#x27;POST&#x27;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        code: code  // 将获取到的 code 传给后端</span><br><span class="line">      &#125;,</span><br><span class="line">      success: res =&gt; &#123;</span><br><span class="line">        if (res.data.openid) &#123;</span><br><span class="line">          // 登录成功，存储openid和其他信息</span><br><span class="line">          this.setData(&#123;</span><br><span class="line">            logged: true,</span><br><span class="line">            userInfo: res.data.userInfo</span><br><span class="line">          &#125;);</span><br><span class="line">          console.log(&#x27;openid:&#x27;, res.data.openid);  // 打印获取到的 openid</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          console.log(&#x27;获取 openid 失败&#x27;, res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: err =&gt; &#123;</span><br><span class="line">        console.log(&#x27;请求失败&#x27;, err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>后端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/api&quot;)</span><br><span class="line">public class LoginController &#123;</span><br><span class="line">    private static final String APP_ID = &quot;wx3900b2e394c85308&quot;;</span><br><span class="line">    private static final String APP_SECRET = &quot;b082113965056bf6713dbea4fda1a5cd&quot;;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/getOpenId&quot;)</span><br><span class="line">    public ResponseEntity&lt;?&gt; getOpenId(@RequestBody CodeRequest codeRequest)&#123;</span><br><span class="line">        String code = codeRequest.getCode();</span><br><span class="line">        String url = &quot;https://api.weixin.qq.com/sns/jscode2session&quot; +</span><br><span class="line">                &quot;?appid=&quot; + APP_ID +</span><br><span class="line">                &quot;&amp;secret=&quot; + APP_SECRET +</span><br><span class="line">                &quot;&amp;js_code=&quot; + code +</span><br><span class="line">                &quot;&amp;grant_type=authorization_code&quot;;</span><br><span class="line">        RestTemplate restTemplate = new RestTemplate();</span><br><span class="line">        String response = restTemplate.getForObject(url, String.class);  // 在后端中发送HTTP请求</span><br><span class="line">        return ResponseEntity.ok(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">实体类代码</span><br><span class="line">@Data</span><br><span class="line">public class CodeRequest &#123;</span><br><span class="line">    private String code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="6-后台管理系统（Vue）"><a href="#6-后台管理系统（Vue）" class="headerlink" title="6. 后台管理系统（Vue）"></a>6. 后台管理系统（Vue）</h3><h4 id="6-1-页面布局的搭建"><a href="#6-1-页面布局的搭建" class="headerlink" title="6.1 页面布局的搭建"></a>6.1 页面布局的搭建</h4><ol>
<li>在<code>components</code>里创建新的<code>.vue</code>文件，加入element-plus 提供的布局容器代码</li>
<li>在<code>App.vue</code>中导入，在<code>template</code>中使用这个标签</li>
</ol>
<h4 id="6-2-页面布局的拆分"><a href="#6-2-页面布局的拆分" class="headerlink" title="6.2 页面布局的拆分"></a>6.2 页面布局的拆分</h4><ul>
<li>将<code>elment-plus</code>给的代码分块，分别放进不同的<code>.vue</code>文件，再在剪切的地方引入（6.1中的两步）组件</li>
</ul>
<blockquote>
<p><code>element-plus</code>中的<strong>图标需要再次引入</strong></p>
</blockquote>
<h4 id="6-3-编写头部页面"><a href="#6-3-编写头部页面" class="headerlink" title="6.3 编写头部页面"></a>6.3 编写头部页面</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;  // 有 setup 表示这是组合式 API，相比选项式 API 有区别</span><br><span class="line"> const toUser = () =&gt; &#123;</span><br><span class="line">     console.log(&quot;sss&quot;); // 使用 console.log</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote>
<p>实际操作中学到的知识</p>
<blockquote>
<p>样式<code>css</code>可以直接在<code>HTML</code>标签的属性<code>style</code>中添加  </p>
<p><code>element-plus</code>里有很多现成的组件，这些组件中还有许多属性，方便开发</p>
</blockquote>
<h4 id="6-4-导航栏菜单的伸缩"><a href="#6-4-导航栏菜单的伸缩" class="headerlink" title="6.4 导航栏菜单的伸缩"></a>6.4 导航栏菜单的伸缩</h4><p>目标：一个子组件事件传到另外一个子组件，<strong>通过父组件去传递</strong></p>
<ol>
<li>$emit 触发自定义事件，作用：子组件事件传递到父组件事件</li>
</ol>
<blockquote>
<p>子组件：&lt;button @click&#x3D;”$emit(‘someEvent’)”&gt;Click Me</button></p>
<p>父组件：定义名为 someEvent 的事件</p>
</blockquote>
<ol start="2">
<li><p>父组件传递给子组件用<code>props</code></p>
</li>
<li><p>在父组件中，将从子组件传来的事件和传到另一个子组件属性关联起来，再在事件中做逻辑处理</p>
</li>
</ol>
<h4 id="6-5-安装axios与跨域处理"><a href="#6-5-安装axios与跨域处理" class="headerlink" title="6.5 安装axios与跨域处理"></a>6.5 安装axios与跨域处理</h4><ol>
<li>安装 <code>axios</code></li>
</ol>
<p><code>npm install axios --save</code></p>
<ol start="2">
<li><code>main.ts</code> 中引入</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">app.config.globalProperties.$axios = axios;  // (Vue2和Vue3有区别)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在<code>Main.vue</code>中使用<code>axios</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">    import &#123; onMounted, ref &#125; from &#x27;vue&#x27;</span><br><span class="line">    import axios from &#x27;axios&#x27;</span><br><span class="line">    const item = &#123;</span><br><span class="line">    date: &#x27;2016-05-02&#x27;,</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    address: &#x27;No. 189, Grove St, Los Angeles&#x27;,</span><br><span class="line">  &#125;</span><br><span class="line">    const tableData = ref(Array.from(&#123; length: 10 &#125;).fill(item))</span><br><span class="line">    const loadGet = () =&gt; &#123;</span><br><span class="line">        axios.get(&#x27;http://localhost:8080/user/list&#x27;).then(res =&gt; res.data).then(res=&gt;&#123;</span><br><span class="line">            console.log(res);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    const loadPost = () =&gt; &#123;</span><br><span class="line">        axios.post(&#x27;http://localhost:8080/user/listP&#x27;,&#123;&#125;).then(res =&gt; res.data).then(res=&gt;&#123;</span><br><span class="line">            console.log(res);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    onMounted(() =&gt; &#123;</span><br><span class="line">        //loadGet();</span><br><span class="line">        loadPost();</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>挂载：Vue将一个组件连接到DOM上的过程，从创建到显示在页面的过程</p>
<p>.then是请求成功时的回调函数</p>
</blockquote>
<ol start="4">
<li>在Common中新建一个跨域类</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.wms.common;</span><br><span class="line"> import org.springframework.context.annotation.Configuration;</span><br><span class="line"> import org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"> import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"> @Configuration</span><br><span class="line"> public class CorsConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">     public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class="line">         registry.addMapping(&quot;/**&quot;)</span><br><span class="line">                 //是否发送Cookie</span><br><span class="line">                 .allowCredentials(true)</span><br><span class="line">                 //放⾏哪些原始域</span><br><span class="line">                 .allowedOriginPatterns(&quot;*&quot;)</span><br><span class="line">                 .allowedMethods(new String[]&#123;&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;&#125;)</span><br><span class="line">                 .allowedHeaders(&quot;*&quot;)</span><br><span class="line">                 .exposedHeaders(&quot;*&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>修改了后端的<code>listP</code>方法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/listP&quot;)</span><br><span class="line">    public List&lt;User&gt; listP(@RequestBody User user) &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper();</span><br><span class="line">        if(StringUtils.isNotBlank(user.getName()))&#123;</span><br><span class="line">            lambdaQueryWrapper.like(User::getName, user.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        return userService.list(lambdaQueryWrapper);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多加了 if，如果不加 if 的话，当<code>user.getName()</code>的返回值为 null（前端没有传body），会导致查不到数据</p>
</blockquote>
<h4 id="6-6-列表的基本展示"><a href="#6-6-列表的基本展示" class="headerlink" title="6.6 列表的基本展示"></a>6.6 列表的基本展示</h4><ol>
<li>是如何展示出来的，用<code>element-plus</code>封装好的属性<code>prop</code></li>
</ol>
<ul>
<li><pre><code>&lt;el-table :data=&quot;tableData&quot;
            :header-cell-style=&quot;&#123; background:&#39;#f2f5fc&#39;, color:&#39;#555&#39;&#125;&quot;
            border
            &gt;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  `tableData`接收后端传来的数据</span><br><span class="line"></span><br><span class="line">- `&lt;el-table-column prop=&quot;id&quot; label=&quot;ID&quot; width=&quot;60&quot; /&gt;`</span><br><span class="line"></span><br><span class="line">&gt; 子组件el-table-column的 prop 属性对应对象（后端传来的）中的键名</span><br><span class="line"></span><br><span class="line">2. 实现UI界面上0 对应女，1 对应男的功能</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 本质是具名插槽，名字为 default</span><br><span class="line">&gt;</span><br><span class="line">&gt; scope：是父组件的对象，可以通过它来访问父组件的属性</span><br><span class="line">&gt;</span><br><span class="line">&gt; 父组件和子组件**有包含关系即可**，不是必须要在两个.vue文件中</span><br><span class="line"></span><br><span class="line">3. 改变列表第一行颜色`header-cell-style`，加上边框`border`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><el-table :data="tableData"
            :header-cell-style="{ background:'#f2f5fc', color:'#555'}"
            border
            ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. 加上按钮</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>        &lt;el-table-column prop=&quot;operate&quot; label=&quot;操作&quot;&gt;
            &lt;el-button type=&quot;success&quot;&gt;编辑&lt;/el-button&gt;
            &lt;el-button type=&quot;danger&quot;&gt;删除&lt;/el-button&gt;
        &lt;/el-table-column&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. 封装后端返回到前端的数据，修改后端接口代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>   @PostMapping(“&#x2F;listP”)<br>    public Result listP(@RequestBody User user) {<br>        LambdaQueryWrapper<User> lambdaQueryWrapper &#x3D; new LambdaQueryWrapper();<br>        if(StringUtils.isNotBlank(user.getName())){<br>            lambdaQueryWrapper.like(User::getName, user.getName());<br>        }<br>        return Result.suc(userService.list(lambdaQueryWrapper));<br>    }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6. 因为后端返回给前端的数据多封装了一层，所以前端拿数据时需要往下一层</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>const loadPost = () =&gt; &#123;
    axios.post(&#39;http://localhost:8080/user/listP&#39;,&#123;&#125;).then(res =&gt; res.data).then(res=&gt;&#123;
        console.log(res);
        if(res.code == 200)&#123;
            tableData.value = res.data;
        &#125;else&#123;
            alert(&#39;获取数据失败&#39;)
        &#125;
    &#125;)
&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 6.7  分页查询</span><br><span class="line"></span><br><span class="line">1. 使用 element-plus 中的分页组件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>template部分：<br>        &lt;el-pagination<br>            :current-page&#x3D;”pageNum”<br>            :page-size&#x3D;”pageSize”<br>            :page-sizes&#x3D;”[5, 10, 20, 30]”<br>            :size&#x3D;”size”<br>            layout&#x3D;”total, sizes, prev, pager, next, jumper”<br>            :total&#x3D;”total”<br>            @size-change&#x3D;”handleSizeChange”<br>            @current-change&#x3D;”handleCurrentChange”<br>        &#x2F;&gt;</p>
<p>script部分：<br>    <script lang="ts" setup><br>    import { onMounted, ref } from &#39;vue&#39;<br>    import axios from &#39;axios&#39;<br>    import type { ComponentSize } from &#39;element-plus&#39;</p>
<pre><code>const tableData = ref()
const pageSize = ref(10)
const pageNum = ref(1)
const total = ref(0)
const size = ref&lt;ComponentSize&gt;(&#39;default&#39;)
const loadGet = () =&gt; &#123;
    axios.get(&#39;http://localhost:8080/user/list&#39;).then(res =&gt; res.data).then(res=&gt;&#123;
        console.log(res);
    &#125;)
&#125;
const loadPost = () =&gt; &#123;
    axios.post(&#39;http://localhost:8080/user/listPageC1&#39;,&#123;pageSize:pageSize.value,pageNum:pageNum.value&#125;).then(res =&gt; res.data).then(res=&gt;&#123;
        console.log(res);
        if(res.code == 200)&#123;
            tableData.value = res.data;
            total.value = res.total;
        &#125;else&#123;
            alert(&#39;获取数据失败&#39;)
        &#125;
    &#125;)
&#125;
onMounted(() =&gt; &#123;
    //loadGet();
    loadPost();
&#125;)
const handleSizeChange = (val: number) =&gt; &#123;  // val是组件 el-pagination 自带的属性
    console.log(`$&#123;val&#125; items per page`)
    pageNum.value = 1
    pageSize.value = val;
    loadPost()
&#125;
const handleCurrentChange = (val: number) =&gt; &#123;
    console.log(`current page: $&#123;val&#125;`)
    pageNum.value = val;
    loadPost()
&#125;
</code></pre>
<p></script></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 总结: element-plus 已经将属性定义好了,我需要做的就是把后端传来的数据传给这个属性即可</span><br><span class="line"></span><br><span class="line">#### 6.8 查询处理</span><br><span class="line"></span><br><span class="line">1. 搜索栏：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div style="margin:5px;">
            <el-input v-model="name" placeholder="请输入名字" suffix-icon="el-icon-search" style="width: 200px;"  @keyup.enter="loadPost" ></el-input>
            <el-icon><Search /></el-icon>
            <el-button type="primary" style="margin-left: 5px;" @click="loadPost">查询</el-button>
            <el-button type="success">重置</el-button>
        </div>
        
<p>const name &#x3D; ref();<br>   const loadPost &#x3D; () &#x3D;&gt; {<br>        axios.post(‘<a href="http://localhost:8080/user/listPageC1',%7BpageSize:pageSize.value,pageNum:pageNum.value,param:%7Bname:name.value%7D%7D).then">http://localhost:8080/user/listPageC1&#39;,{pageSize:pageSize.value,pageNum:pageNum.value,param:{name:name.value}}).then</a>(res &#x3D;&gt; res.data).then(res&#x3D;&gt;{<br>            console.log(res);<br>            if(res.code &#x3D;&#x3D; 200){<br>                tableData.value &#x3D; res.data;<br>                total.value &#x3D; res.total;<br>            }else{<br>                alert(‘获取数据失败’)<br>            }<br>        })<br>    }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt; @keyup.enter=&quot;loadPost&quot;：回车事件</span><br><span class="line"></span><br><span class="line">实现流程：绑定响应式数据 name ，再将 name 传到后端去查询</span><br><span class="line"></span><br><span class="line">2. 下拉查询：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&lt;el-select<br>                v-model&#x3D;”sex”  &#x2F;&#x2F; 定义一个响应式属性 sex<br>                filterable<br>                placeholder&#x3D;”请选择性别”<br>                style&#x3D;”width: 240px; margin-left: 5px;”<br>            &gt;<br>            <el-option
            v-for="item in sexs"
            :key="item.value"
            :label="item.label"
            :value="item.value"
            /><br>            </el-select></p>
<p>const sex &#x3D; ref();<br>    const sexs &#x3D; [<br>  {<br>    value: ‘1’,<br>    label: ‘男’,<br>  },<br>  {<br>    value: ‘0’,<br>    label: ‘女’,<br>  }];<br>  axios.post(‘<a href="http://localhost:8080/user/listPageC1">http://localhost:8080/user/listPageC1</a>‘,<br>        {pageSize:pageSize.value,pageNum:pageNum.value,param:{name:name.value,sex:sex.value}}) &#x2F;&#x2F; 新加 sex，传到后端</p>
<p>后端新增：<br>String sex &#x3D; (String) param.get(“sex”);<br>if (StringUtils.isNotBlank(sex)){<br>            lambdaQueryWrapper.eq(User::getSex,sex);<br>        }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 重置</span><br><span class="line"></span><br><span class="line">实现流程：将 sex 和 name 属性清空</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&lt;el-button type&#x3D;”success” @click&#x3D;”resetParam”&gt;重置</el-button><br>   const resetParam &#x3D;() &#x3D;&gt; {<br>        name.value &#x3D; ‘’;<br>        sex.value &#x3D; ‘’;<br>    }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 6.9 新增</span><br><span class="line"></span><br><span class="line">1. 新增按钮</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&lt;el-button type&#x3D;”success” @click&#x3D;”add”&gt;新增</el-button></p>
<pre><code>const add = () =&gt; &#123;
    centerDialogVisible.value = true; // true 的时候就显示 dialog
&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. Element-Plus 组件 dialog</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><el-dialog
            v-model="centerDialogVisible"
            title="Warning"
            width="500"
            align-center
        ><br>            <span>Open the dialog from the center from the screen</span><br>            &lt;template #footer&gt;<br>            <div class="dialog-footer"><br>                &lt;el-button @click&#x3D;”centerDialogVisible &#x3D; false”&gt;Cancel</el-button><br>                &lt;el-button type&#x3D;”primary” @click&#x3D;”centerDialogVisible &#x3D; false”&gt;<br>                Confirm<br>                </el-button><br>            </div><br>            </template><br>        </el-dialog></p>
<p>const centerDialogVisible &#x3D; ref(false);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 编写表单</span><br><span class="line"></span><br><span class="line">把第二步中的 span 替换为</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<el-form :model="form" label-width="auto" style="max-width: 600px;">
            <el-form-item label="账号" >
                <el-col :span="10">
                    <el-input v-model="form.no"/>
                </el-col>
            </el-form-item>
            <el-form-item label="名字" >
                <el-col :span="10">
                    <el-input v-model="form.name"/>
                </el-col>
            </el-form-item>
            <el-form-item label="密码" >
                <el-col :span="10">
                    <el-input v-model="form.password"/>
                </el-col>
            </el-form-item>
            <el-form-item label="年龄" >
                <el-col :span="10">
                    <el-input v-model="form.age"/>
                </el-col>
            </el-form-item>

<pre><code>        &lt;el-form-item label=&quot;性别&quot;&gt;
        &lt;el-radio-group v-model=&quot;form.sex&quot;&gt;
            &lt;el-radio label=&quot;1&quot;&gt;男&lt;/el-radio&gt;
            &lt;el-radio label=&quot;0&quot;&gt;女&lt;/el-radio&gt;
            &lt;/el-radio-group&gt;
        &lt;/el-form-item&gt;

        &lt;el-form-item label=&quot;电话&quot; &gt;
            &lt;el-col :span=&quot;10&quot;&gt;
                &lt;el-input v-model=&quot;form.phone&quot;/&gt;
            &lt;/el-col&gt;
        &lt;/el-form-item&gt;
    &lt;/el-form&gt;
    
</code></pre>
<p>const form &#x3D; ref({<br>        no: ‘’,<br>        name: ‘’,<br>        password: ‘’,<br>        age: ‘’,<br>        phone: ‘’,<br>        sex: ‘0’<br>    })</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. 提交数据</span><br><span class="line"></span><br><span class="line">给提交绑定一个函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&lt;el-button type&#x3D;”primary” @click&#x3D;”save”&gt;<br> 确定<br></el-button></p>
<p>const save &#x3D; () &#x3D;&gt; {<br>        axios.post(‘<a href="http://localhost:8080/user/save',form.value">http://localhost:8080/user/save&#39;,form.value</a>)<br>        .then(res &#x3D;&gt; res.data).then(res&#x3D;&gt;{<br>            console.log(res);<br>            if(res.code &#x3D;&#x3D; 200){<br>                ElMessage({ &#x2F;&#x2F; elementplus 的 Message 消息提示组件<br>                            message: ‘操作成功’,<br>                            type: ‘success’,<br>                            plain: true,<br>                        })<br>                centerDialogVisible.value &#x3D; true<br>                loadPost() &#x2F;&#x2F; 重新加载一下页面（更新新添加的数据）<br>            }else{<br>                ElMessage({<br>                            message: ‘操作失败’,<br>                            type: ‘error’,<br>                            plain: true,<br>                        })<br>            }<br>        })<br>    }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">改造 save，return用 Result</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>   @PostMapping(“&#x2F;save”)<br>    public Result save(@RequestBody User user) {<br>        return userService.save(user) ? Result.suc(): Result.fail();<br>    }</p>
<pre><code>
5. 数据检查
</code></pre>
]]></content>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
</search>
