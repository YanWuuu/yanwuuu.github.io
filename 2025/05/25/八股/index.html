<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="八股Java 基础什么是面向对象的设计思想？OOP（ Object-Oriented Programming ），通过对象来组织和管理程序 四大特征  封装：将属性和方法绑定在一起，形成一个对象。并将对象内部隐藏起来，只暴露必要的接口供外部使用（数据保护） 继承：一个类继承另一个类的属性和方法（代码复用，已于扩展）。 多态：同一个方法可以接收不同类型的对象，产生不同的行为。允许将父类对象引用指向子">
<meta property="og:type" content="article">
<meta property="og:title" content="八股">
<meta property="og:url" content="http://example.com/2025/05/25/%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="Yan的博客">
<meta property="og:description" content="八股Java 基础什么是面向对象的设计思想？OOP（ Object-Oriented Programming ），通过对象来组织和管理程序 四大特征  封装：将属性和方法绑定在一起，形成一个对象。并将对象内部隐藏起来，只暴露必要的接口供外部使用（数据保护） 继承：一个类继承另一个类的属性和方法（代码复用，已于扩展）。 多态：同一个方法可以接收不同类型的对象，产生不同的行为。允许将父类对象引用指向子">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="d:\xmind\Typora\image\%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE 2025-05-12 164753.png">
<meta property="og:image" content="d:\xmind\Typora\image\%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE 2025-05-15 224105.png">
<meta property="og:image" content="d:\xmind\Typora\image\%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE 2025-05-19 202339.png">
<meta property="article:published_time" content="2025-05-25T01:14:09.000Z">
<meta property="article:modified_time" content="2025-05-26T10:37:34.194Z">
<meta property="article:author" content="Yan">
<meta property="article:tag" content="总结">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:\xmind\Typora\image\%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE 2025-05-12 164753.png">


<link rel="canonical" href="http://example.com/2025/05/25/%E5%85%AB%E8%82%A1/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/05/25/%E5%85%AB%E8%82%A1/","path":"2025/05/25/八股/","title":"八股"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>八股 | Yan的博客</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Yan的博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">奔赴山海，保持热爱</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E8%82%A1"><span class="nav-number">1.</span> <span class="nav-text">八股</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text">Java 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">什么是面向对象的设计思想？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.2.</span> <span class="nav-text">接口和抽象类的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">1.1.3.</span> <span class="nav-text">反射</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E9%9B%86%E5%90%88"><span class="nav-number">1.2.</span> <span class="nav-text">Java集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4List%E3%80%81Set%E3%80%81Queue%E3%80%81Map%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.2.1.</span> <span class="nav-text">说说List、Set、Queue、Map的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayLIst-%E5%92%8C-LinkedList-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.2.</span> <span class="nav-text">ArrayLIst 和 LinkedList 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83-HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">1.2.3.</span> <span class="nav-text">比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E3%80%81-StringBuffer-%E3%80%81StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.4.</span> <span class="nav-text">String、 StringBuffer 、StringBuilder 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFBlockingQueue"><span class="nav-number">1.2.5.</span> <span class="nav-text">什么是BlockingQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.6.</span> <span class="nav-text">HashMap 和 Hashtable 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E4%B8%8EConcurrentHashMap%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.7.</span> <span class="nav-text">HashMap与ConcurrentHashMap的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.8.</span> <span class="nav-text">HashMap 的底层原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashcode-%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-number">1.2.9.</span> <span class="nav-text">hashcode 冲突怎么解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E4%B8%AD%E6%80%8E%E4%B9%88%E6%8A%8A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC"><span class="nav-number">1.2.10.</span> <span class="nav-text">java中怎么把一个字符串反转</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%B9%B6%E5%8F%91"><span class="nav-number">1.3.</span> <span class="nav-text">Java 并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">怎么保证线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Synchronized"><span class="nav-number">1.3.2.</span> <span class="nav-text">Synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">基本原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">1.3.3.</span> <span class="nav-text">ReentrantLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reentrantlock%E5%92%8Csync%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.3.4.</span> <span class="nav-text">reentrantlock和sync区别是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.3.5.</span> <span class="nav-text">ThreadLocal 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.3.6.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">运行流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.3.7.</span> <span class="nav-text">读写锁和互斥锁的区别，使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E4%B8%AD%E5%AE%B9%E6%98%93%E5%87%BA%E7%8E%B0%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="nav-number">1.3.8.</span> <span class="nav-text">java中容易出现的异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ABA%E6%98%AF%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E4%B8%80%E8%88%AC%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-number">1.3.9.</span> <span class="nav-text">ABA是什么问题，一般可以怎么解决？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL"><span class="nav-number">1.4.</span> <span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.4.1.</span> <span class="nav-text">事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%8F%E8%AF%BB"><span class="nav-number">1.4.2.</span> <span class="nav-text">脏读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9"><span class="nav-number">1.4.3.</span> <span class="nav-text">丢失修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BB%E8%AF%BB"><span class="nav-number">1.4.4.</span> <span class="nav-text">幻读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="nav-number">1.4.5.</span> <span class="nav-text">不可重复读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.4.6.</span> <span class="nav-text">存储引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">1.4.7.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-number">1.4.7.1.</span> <span class="nav-text">索引失效的场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">1.4.8.</span> <span class="nav-text">MVCC( 多版本并发控制 )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.4.9.</span> <span class="nav-text">MySQL 隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E4%B8%AA%E6%97%A5%E5%BF%97"><span class="nav-number">1.4.10.</span> <span class="nav-text">三个日志</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">1.5.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.5.1.</span> <span class="nav-text">Java 内存模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B"><span class="nav-number">1.5.2.</span> <span class="nav-text">jvm内存模型介绍一下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="nav-number">1.5.3.</span> <span class="nav-text">怎么进行垃圾回收？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">1.5.4.</span> <span class="nav-text">双亲委派机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis"><span class="nav-number">1.6.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Redis-%E6%AF%94-MySQL-%E5%BF%AB%EF%BC%9F"><span class="nav-number">1.6.1.</span> <span class="nav-text">为什么 Redis 比 MySQL 快？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.6.2.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="nav-number">1.6.3.</span> <span class="nav-text">Redis持久化机制有哪些，底层原理是怎样的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81"><span class="nav-number">1.6.4.</span> <span class="nav-text">redis分布式锁读写一致性如何保证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ"><span class="nav-number">1.7.</span> <span class="nav-text">RabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RabbitMQ-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.7.1.</span> <span class="nav-text">RabbitMQ 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89%E6%80%A7"><span class="nav-number">1.7.2.</span> <span class="nav-text">消息幂等性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1"><span class="nav-number">1.7.3.</span> <span class="nav-text">消息丢失</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E5%A0%86%E7%A7%AF"><span class="nav-number">1.7.4.</span> <span class="nav-text">消费堆积</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84"><span class="nav-number">1.8.</span> <span class="nav-text">黑马点评</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8-Java-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Redis"><span class="nav-number">1.8.1.</span> <span class="nav-text">如何在 Java 项目中使用 Redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8Redis%E6%9B%BF%E4%BB%A3Session%EF%BC%9F%E8%BF%98%E6%9C%89%E5%85%B6%E4%BB%96%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E5%90%97%EF%BC%9F"><span class="nav-number">1.8.2.</span> <span class="nav-text">为什么用Redis替代Session？还有其他解决办法吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%82%A8%E8%83%BD%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Redis-%E5%AE%9E%E7%8E%B0-Session-%E5%85%B1%E4%BA%AB%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-number">1.8.3.</span> <span class="nav-text">您能详细解释一下如何使用 Redis 实现 Session 共享的吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-ThreadLocal-%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="nav-number">1.8.4.</span> <span class="nav-text">为什么使用 ThreadLocal 保存用户信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E6%80%8E%E4%B9%88%E5%88%B7%E6%96%B0"><span class="nav-number">1.8.5.</span> <span class="nav-text">权限怎么刷新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-number">1.8.6.</span> <span class="nav-text">拦截器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">1.8.7.</span> <span class="nav-text">数据一致性问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">1.8.8.</span> <span class="nav-text">缓存穿透、缓存雪崩、缓存击穿</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%82%A8%E8%83%BD%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E4%BD%BF%E7%94%A8-Redis-%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80-ID-%E7%9A%84%E8%BF%87%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="nav-number">1.8.9.</span> <span class="nav-text">您能详细描述一下使用 Redis 实现全局唯一 ID 的过程吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E8%A7%A3%E5%86%B3%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="nav-number">1.8.10.</span> <span class="nav-text">乐观锁解决超卖问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">1.8.11.</span> <span class="nav-text">为什么使用分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BC%98%E5%8C%96"><span class="nav-number">1.8.12.</span> <span class="nav-text">分布式锁优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8redisson%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8SETNX%EF%BC%8Credisson%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%E5%90%97%EF%BC%9F"><span class="nav-number">1.8.13.</span> <span class="nav-text">分布式锁为什么使用redisson而不是直接使用SETNX，redisson有什么优势吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-Stream-%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88-%E5%BC%82%E6%AD%A5%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96-%EF%BC%89"><span class="nav-number">1.8.14.</span> <span class="nav-text">基于 Stream 结构实现消息队列（ 异步秒杀优化 ）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95%E6%97%B6%EF%BC%8C%E6%82%A8%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="nav-number">1.8.15.</span> <span class="nav-text">在实现异步秒杀下单时，您是如何保证消息的可靠性和一致性的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%A8-redis-%E7%9A%84-Sortedset%E5%81%9A%E6%8E%92%E8%A1%8C%E6%A6%9C%EF%BC%9F"><span class="nav-number">1.8.16.</span> <span class="nav-text">如何用 redis 的 Sortedset做排行榜？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring"><span class="nav-number">1.9.</span> <span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.9.1.</span> <span class="nav-text">Spring 中的事务如何实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#springboot-%E7%9A%84-bean-%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">1.9.2.</span> <span class="nav-text">springboot 的 bean 创建方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.9.3.</span> <span class="nav-text">Bean 的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IoC%EF%BC%88-Inversion-of-Control-%EF%BC%89"><span class="nav-number">1.9.4.</span> <span class="nav-text">IoC（ Inversion of Control ）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IoC-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A-DI"><span class="nav-number">1.9.4.1.</span> <span class="nav-text">IoC 的实现方式： DI</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOP"><span class="nav-number">1.9.5.</span> <span class="nav-text">AOP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sprng-MVC"><span class="nav-number">1.9.6.</span> <span class="nav-text">Sprng MVC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">1.10.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="nav-number">1.10.1.</span> <span class="nav-text">TCP三次握手过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">1.10.2.</span> <span class="nav-text">TCP 四次挥手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">1.10.3.</span> <span class="nav-text">打开页面的全过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-%E5%92%8C-HTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.10.4.</span> <span class="nav-text">HTTP 和 HTTPS的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MQTT"><span class="nav-number">1.10.5.</span> <span class="nav-text">MQTT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E5%92%8C-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.10.6.</span> <span class="nav-text">TCP 和 UDP 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP1-0%E5%88%B03-0%E7%9A%84%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E6%89%80%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.10.7.</span> <span class="nav-text">HTTP1.0到3.0的版本更新所带来的新特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.11.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">1.11.1.</span> <span class="nav-text">协程是什么？有什么好处？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-number">1.11.2.</span> <span class="nav-text">介绍一下操作系统的虚拟内存？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.11.3.</span> <span class="nav-text">进程通信方式你知道哪些？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.12.</span> <span class="nav-text">进程、线程、协程的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.12.1.</span> <span class="nav-text">IO多路复用是什么</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux"><span class="nav-number">1.13.</span> <span class="nav-text">Linux</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%8F%B7%E7%8A%B6%E6%80%81"><span class="nav-number">1.13.1.</span> <span class="nav-text">如何查看进程号状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.13.2.</span> <span class="nav-text">查看线程</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yan</p>
  <div class="site-description" itemprop="description">心有所向，无问西东</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/25/%E5%85%AB%E8%82%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yan的博客">
      <meta itemprop="description" content="心有所向，无问西东">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="八股 | Yan的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          八股
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-05-25 09:14:09" itemprop="dateCreated datePublished" datetime="2025-05-25T09:14:09+08:00">2025-05-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-05-26 18:37:34" itemprop="dateModified" datetime="2025-05-26T18:37:34+08:00">2025-05-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h1><h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h3 id="什么是面向对象的设计思想？"><a href="#什么是面向对象的设计思想？" class="headerlink" title="什么是面向对象的设计思想？"></a>什么是面向对象的设计思想？</h3><p>OOP（ Object-Oriented Programming ），通过<strong>对象</strong>来组织和管理程序</p>
<p>四大特征</p>
<ul>
<li>封装：将属性和方法绑定在一起，形成一个对象。并将对象内部隐藏起来，只暴露必要的接口供外部使用（数据保护）</li>
<li>继承：一个类继承另一个类的属性和方法（代码复用，已于扩展）。</li>
<li>多态：同一个方法可以接收不同类型的对象，产生不同的行为。<strong>允许将父类对象引用指向子类对象</strong></li>
</ul>
<blockquote>
<p>def animal_sound(animal):  </p>
<p>print(animal.speak()) &#x2F;&#x2F; animal</p>
<p>animal_sound(dog)  # 输出: Bark</p>
<p>animal_sound(cat)  # 输出: Meow</p>
</blockquote>
<ul>
<li>抽象：隐藏复杂的实现细节，只保留重要的功能接口（程序员可以将注意力集中在高层次设计上）。</li>
</ul>
<hr>
<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul>
<li>接口：包含常量和方法签名（ 不包含方法的实现 ），多个类可以实现该接口，实现多态。多继承（ implements ）。适用于定义类的功能。方法是 public abstract，变量 public static final，被default 修饰的方法，允许在实现该接口的类中<strong>不必重写</strong>这个方法</li>
<li>抽象类：包含抽象方法和具体方法（ 可以有方法的具体实现 ）。单继承（ extends ）。适用于有明显继承关系的场景。</li>
</ul>
<hr>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>作用：允许程序在<strong>运行时</strong>动态地获取类的信息和操作类的方法</p>
<p>动态性：反射使得我们在运行时动态地创建对象、调用方法和访问属性，与编译时不同，运行时反射允许程序在<strong>不知道具体类</strong>的情况下，根据需要处理对象</p>
<p>使用场景：框架设计，动态代理（ 通过反射来创建对象 ）</p>
<p>原理：加载完类之后，在堆中生成了一个 Class 类型的对象，这个对象包含了类的完整结构，然后通过 class 实例获取 class 信息和方法</p>
<hr>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><p>由两大接口派生而来：<code>Collection</code> 和 <code>Map</code></p>
<p>![屏幕截图 2025-05-12 164335](D:\xmind\Typora\image\屏幕截图 2025-05-12 164335.png)</p>
<img src="D:\xmind\Typora\image\屏幕截图 2025-05-12 164753.png" alt="屏幕截图 2025-05-12 164753" style="zoom:80%;" />

<hr>
<h3 id="说说List、Set、Queue、Map的区别？"><a href="#说说List、Set、Queue、Map的区别？" class="headerlink" title="说说List、Set、Queue、Map的区别？"></a>说说List、Set、Queue、Map的区别？</h3><ul>
<li>List：存储的元素是<strong>有序</strong>的、可重复</li>
<li>Set：存储的元素<strong>不可重复</strong></li>
<li>Queue：特定的排序规则（先进先出），存储的元素和 List 性质一样</li>
<li>Map：使用 key-value 存储</li>
</ul>
<hr>
<h3 id="ArrayLIst-和-LinkedList-区别"><a href="#ArrayLIst-和-LinkedList-区别" class="headerlink" title="ArrayLIst 和 LinkedList 区别"></a>ArrayLIst 和 LinkedList 区别</h3><ul>
<li>都线程不安全</li>
<li>ArrayList 底层使用数组，LinkedList 底层使用双向链表</li>
<li>ArrayList 支持随机访问，LinkedList 不支持 随机访问</li>
<li>ArrayList 使用场景：根据索引快速访问，内存开销小。LinkedList使用场景：在中间位置插入或删除，不需要随机访问</li>
</ul>
<hr>
<h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><p>HashSet：底层是哈希表，不保证元素插入和取出顺序</p>
<p>LinkedHashSet：底层是链表和哈希表，FIFO</p>
<p>TreeSet：底层是红黑树，支持对元素自定义排序</p>
<hr>
<h3 id="String、-StringBuffer-、StringBuilder-的区别"><a href="#String、-StringBuffer-、StringBuilder-的区别" class="headerlink" title="String、 StringBuffer 、StringBuilder 的区别"></a>String、 StringBuffer 、StringBuilder 的区别</h3><p>可变性：String 不可变、Buffer 和 Builder 可变，因为它们继承自 AbstractStringBuilder 类（ 提供了很多修改字符串的方法，比如 append ）</p>
<p>线程安全性：String 中的对象不可变，可以理解为常量，线程安全。StringBuffer 在 AbstractStringBuilder 方法上加了同步锁，线程安全。StringBuilder 没有加锁，线程不安全</p>
<p>使用场景：String（ 操作少量数据 ）、StringBuilder（ 单线程下操作大量数据 ）、StringBuffer（ 多线程操作大量数据 ）</p>
<hr>
<h3 id="什么是BlockingQueue"><a href="#什么是BlockingQueue" class="headerlink" title="什么是BlockingQueue"></a>什么是BlockingQueue</h3><p>阻塞队列，继承自<code>Queue</code>，功能：当队列没有元素时一直阻塞，如果队列已满，一直等到队列可以放入新元素时再放入。</p>
<p>常用于生产者-消费者模型中，生产者线程向队列中添加元素，消费者线程从队列中取出数据</p>
<hr>
<h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><p>HashMap：线程不安全。可以存储 null 的 key 和 value。总是以 2 的幂作为容量大小。</p>
<p>Hashtable：线程安全，不能存储 null。 容量变为 2n + 1。底层基于 HashMap</p>
<hr>
<h3 id="HashMap与ConcurrentHashMap的区别是什么？"><a href="#HashMap与ConcurrentHashMap的区别是什么？" class="headerlink" title="HashMap与ConcurrentHashMap的区别是什么？"></a><strong>HashMap与ConcurrentHashMap的区别是什么？</strong></h3><p>内存结构：都是数组+链表+红黑树</p>
<p>线程安全：Hashmap 非线程安全，ConcurrentHashMap，java7及之前，采用将整个哈希表分成多个段，每个段有自己的锁。java8 之后，采用 CAS（实现并发编程的原子性操作） 和 synchronized 来保证线程安全</p>
<hr>
<h3 id="HashMap-的底层原理"><a href="#HashMap-的底层原理" class="headerlink" title="HashMap 的底层原理"></a>HashMap 的底层原理</h3><ul>
<li>将Key 的  <code>hashcode</code> 输入到扰动函数（ 优化哈希值的分布，减小碰撞 ）处理后得到 hash 值</li>
</ul>
<blockquote>
<p>扰动函数 hash</p>
<p> static final int hash(Object key) {<br>   int h;<br>   &#x2F;&#x2F; key.hashCode()：返回散列值也就是hashcode<br>   &#x2F;&#x2F; ^：按位异或<br>   &#x2F;&#x2F; &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐<br>   return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>}</p>
</blockquote>
<p>(n（数组长度） - 1) &amp; hash&#96; 判断元素存在的位置</p>
<p>如果存在元素，就判断两者的 hash 值和 key 是否相同，相同则直接覆盖，不同就通过拉链法解决冲突</p>
<blockquote>
<p>拉链法：若遇到哈希冲突，将冲突的值加到链表中</p>
</blockquote>
<p>当链表长度大于 8 时（ 当数组长度小于64，会先进性数组扩容 ），将链表转化为红黑树（ 减少搜索时间 ）</p>
<ul>
<li>怎么扩容 ？</li>
</ul>
<p>当元素数量达到 capacity * loadFactor（ 负载因子 ），就会触发扩容</p>
<p>创建一个扩大到当前容量的<strong>两倍</strong>的新数组，将旧数组映射到新数组中</p>
<blockquote>
<p>映射时，如果高位比特是 0，新数组中的索引和原数组相同，是 1 则加上旧数组的容量</p>
</blockquote>
<hr>
<h3 id="hashcode-冲突怎么解决"><a href="#hashcode-冲突怎么解决" class="headerlink" title="hashcode 冲突怎么解决"></a>hashcode 冲突怎么解决</h3><p>链地址法：在值中，使用链表才存储哈希值相同的对象</p>
<p>开放地址法：寻找哈希表下一个空的桶来存储冲突对象</p>
<p>再哈希法：使用另一个哈希函数再次计算键的哈希值</p>
<hr>
<h3 id="java中怎么把一个字符串反转"><a href="#java中怎么把一个字符串反转" class="headerlink" title="java中怎么把一个字符串反转"></a>java中怎么把一个字符串反转</h3><ul>
<li>使用 StringBuilder（ 非线程安全 ） 或 StringBuffer（ 线程安全 ） 的 reverse () 方法</li>
<li>手动反转字符串</li>
</ul>
<hr>
<h2 id="Java-并发"><a href="#Java-并发" class="headerlink" title="Java 并发"></a>Java 并发</h2><h3 id="怎么保证线程安全"><a href="#怎么保证线程安全" class="headerlink" title="怎么保证线程安全"></a>怎么保证线程安全</h3><ul>
<li>原子性：一个操作要么完全执行，要么完全不执行</li>
<li>可见性：一个线程对共享变量的修改，能够即时被其他线程看到（ volatile：用于修饰变量，确保在多线程环境下对该变量的写操作可以被其他线程及时看到 ）</li>
<li>有序性：保证程序中语句执行的顺序</li>
</ul>
<hr>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p>作用：保证被它修饰的方法或代码块在同一时刻只能由一个线程执行</p>
<p>非公平（ 多个线程竞争一把锁时，锁的获取顺序并不保证遵循请求的顺序 ）、可重入（ 同一线程可以多次获取同同一把锁 ）</p>
<p>重量级锁：因为监视器锁（ 内置的并且使用者看不到的锁称为监视器锁 ）依赖于操作系统，挂起或环形一个线程，需要从<strong>用户态转到内核态</strong>，时间成本相对较高</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><ul>
<li>使用 synchronized 之后，会在编译之后在代码块前后加上 <code>monitorenter</code> 和 <code>monitorexit</code> 字节码指令。执行monitorenter 指令会尝试获取对象锁，如果对象没有锁或者已经获得了锁，锁的<strong>计数器</strong> + 1。此时其他竞争锁的线程进入等待队列，执行 monitorexit 会把计数器 -1，当计数器为 0，锁释放。处于等待队列中的线程再继续竞争锁</li>
</ul>
<hr>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>非公平、可重入</p>
<p>实现了 <code>Lock</code> 接口，可重入锁，和 Synchronized 类似，但是<strong>多了</strong>公平锁、支持超时（ 超过等待时间就会获取锁失败 ）功能</p>
<hr>
<h3 id="reentrantlock和sync区别是什么"><a href="#reentrantlock和sync区别是什么" class="headerlink" title="reentrantlock和sync区别是什么"></a>reentrantlock和sync区别是什么</h3><p>用法不同：synchronized 可用来修饰普通方法、静态方法，而 reentrantLock 只能用在代码块上</p>
<p>获取锁和释放锁方式不同：sync 自动加锁和释放锁，reen 需要手动</p>
<p>锁类型不同：sync 非公平，reen 可以非公平也可以公平</p>
<p>响应中断：reen 可以响应中断（ 一个线程持有某个锁并且等待其他资源时被中断，可以及时释放持有的锁 ），解决死锁问题，sync 不能</p>
<hr>
<h3 id="ThreadLocal-是什么"><a href="#ThreadLocal-是什么" class="headerlink" title="ThreadLocal 是什么"></a>ThreadLocal 是什么</h3><ul>
<li><p>解决线程安全问题的一种机制，允许创建线程的局部变量</p>
</li>
<li><p>原理：ThreadLocalMap ，key 是 ThreadLocal 本身，value 是 线程特定的变量</p>
</li>
<li><p>内存泄漏原因：未调用ThreadLocal.remove方法（ ThreadLocalMap 继续持有对变量的引用 ）</p>
</li>
</ul>
<hr>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>一种用于管理和复用线程的技术</p>
<p>好处：</p>
<ul>
<li><p>降低因创建和销毁线程造成的消耗</p>
</li>
<li><p>提高响应速度。任务到达时，任务不需要等待线程创建就能立刻从池中分配一个空闲线程来执行任务</p>
</li>
<li><p>提高线程的可管理性</p>
</li>
</ul>
<p>核心参数：</p>
<ul>
<li>核心线程数( corePoolSize )：线程池中始终保持活动的线程数量</li>
<li>最大线程数( maximumPoolSize )：线程池允许的最大线程数量</li>
<li>线程空闲时间( keepAliveTime ) :当任务数量大于核心线程数，多余的线程会在空闲时间到达后被终止</li>
<li>任务队列( workQueue)：存放等待执行的任务</li>
<li>线程工厂( threadFactory )：可以为线程设置名称、优先级等属性</li>
<li>拒绝策略( handler )：当线程池和队列都满了，再有新任务提交时，线程池会采取拒绝策略</li>
</ul>
<blockquote>
<p>CallerRunsPolicy：使用线程池的调用者所在的线程去执行被拒绝的任务</p>
<p>AbortPolicy：直接抛出一个任务被线程池拒绝的异常</p>
<p>DiscardPolicy：不做任何处理</p>
<p>DiscardOldestPolicy：抛弃最小的任务，然后执行该任务</p>
</blockquote>
<h4 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h4><ol>
<li>创建线程池</li>
<li>提交任务</li>
<li>任务排队（任务首先进入 BlockingQueue ）</li>
<li>线程的创建与复用（ 一系列比较判断 ） </li>
<li>任务执行</li>
<li>任务完成（ 线程回到线程池 ）</li>
</ol>
<hr>
<h3 id="读写锁和互斥锁的区别，使用场景"><a href="#读写锁和互斥锁的区别，使用场景" class="headerlink" title="读写锁和互斥锁的区别，使用场景"></a>读写锁和互斥锁的区别，使用场景</h3><ul>
<li>互斥锁：同一时刻只允许一个线程或进程发访问共享资源（ 用于写操作频繁 ）</li>
<li>读写锁：将对共享资源的访问分为读操作和写操作。允许多个线程同时进行读操作，但在写操作时，会排斥其他的读操作和写操作（ 用于读操作多余写操作 ）</li>
</ul>
<hr>
<h3 id="java中容易出现的异常"><a href="#java中容易出现的异常" class="headerlink" title="java中容易出现的异常"></a>java中容易出现的异常</h3><ul>
<li>检查异常：必须在代码里处理或抛出</li>
</ul>
<p>SQLException：与数据库交互式发生错误时</p>
<p>IOException：输入输出操作失败会中断时</p>
<ul>
<li>运行时异常：不要求强制处理，但在运行时可能会出现</li>
</ul>
<p>NullPointerException：对一个 null 对象进行操作时</p>
<p>ArrayIndexOutOfBoundsException：访问数组时，索引超出了数组有效范围</p>
<hr>
<h3 id="ABA是什么问题，一般可以怎么解决？"><a href="#ABA是什么问题，一般可以怎么解决？" class="headerlink" title="ABA是什么问题，一般可以怎么解决？"></a>ABA是什么问题，一般可以怎么解决？</h3><p>线程对共享状态的错误理解，情景：线程 A 读取某个变量的值为 A，线程 B 将该值修改为 B 而后又将其恢复为 A ，当线程 A 执行 CAS 操作时，会发现值还是 A，误认为没有其他线程对该变量修改，最终成功修改该值</p>
<p>通过版本号解决</p>
<hr>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>定义：一系列命令的集合</p>
<p>作用：保证数据的一致性</p>
<p>ACID特性：</p>
<ul>
<li>原子性（ Atomicity ）：事务是最小的执行单位。要么全部完成，要么全部不起作用</li>
<li>一致性（Consistency）：执行事务前后，数据保持一致</li>
</ul>
<blockquote>
<p>转账业务中，无论事务是否成功， 转账这和收款人的总额应该是不变的</p>
</blockquote>
<ul>
<li><p>隔离性（ Isolation ）：各并发事务之间的数据库是独立的</p>
</li>
<li><p>持久性（ Durability ）：一个事务被提交后，数据库中的改变是持久的</p>
</li>
<li><p>保证了事务的原子性，隔离性和持久性之后，一致性才能保证，AID是手段，C是目的</p>
</li>
</ul>
<hr>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>一个事务读取了另一个事务未提交的修改数据，由于未提交的修改数据可能回滚，因此读取到的数据可能并不可靠</p>
<blockquote>
<p>回滚：数据库的状态恢复到事务开始之前的状态</p>
</blockquote>
<h3 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h3><p>一个事务读取一个数据时，另一个事务也访问了该数据，那么在第一个事务中修改了这个数据，第二个事务也修改了这个数据。这样第一个事务修改结果就被丢失，称为丢失修改</p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>相同的查询在同一个事务中返回的<strong>结果集</strong>不同，因为另一个事务插入( <strong>增删</strong> )了符合条件的新数据</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>相同的<strong>行</strong>数据在同一个事务中被多次读取，结果不同，因为另一个事务<strong>修改</strong>了该行数据</p>
<hr>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>作用：负责如何存储、检索和管理数据</p>
<ul>
<li>InnoDB（ 默认的存储引擎 ）</li>
</ul>
<ol>
<li><p>事务支持：提供了对事务的支持，可以进行 ACID 属性的操作</p>
</li>
<li><p>并发性能：采用了行级锁定的机制，可以提供更好的并发性能</p>
</li>
</ol>
<blockquote>
<p>行级锁定：数据库管理系统中对数据进行的锁定机制，与表级锁不同，行级锁只锁定被修改的特定行，允许多个事务同时访问不同的行，提高并发性能</p>
</blockquote>
<ol start="3">
<li>崩溃恢复：通过 redolog 日志实现了崩溃恢复，保证数据的持久性</li>
</ol>
<ul>
<li>MyISAM：具有较低的存储空间和内存消耗，适用于大量读操作中</li>
<li>Memory：将数据存储在内存中国，适用于对性能要求较高的读操作中</li>
</ul>
<hr>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>定义：用于加速数据检索的一种数据结构，可以显著提高查询性能（ MySQL能快速定位到数据，而不需要扫描整个表 ）</p>
<ul>
<li>B+ tree</li>
</ul>
<h4 id="索引失效的场景"><a href="#索引失效的场景" class="headerlink" title="索引失效的场景"></a>索引失效的场景</h4><ol>
<li><p>WHERE 语句中，OR 前的条件列是索引列，而 OR 后的条件列不是索引列</p>
</li>
<li><p>在索引列上使用了函数或表达式计算</p>
</li>
<li><p>使用 LIKE 且通配符 % 位于字符串的开头</p>
</li>
</ol>
<hr>
<h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC( 多版本并发控制 )"></a>MVCC( 多版本并发控制 )</h3><p>定义：一种用于数据库管理系统中的并发控制机制，确保数据的一致性和隔离性</p>
<ul>
<li>多版本：MVCC 通过为每个事务创建数据的多个版本（ <strong>快照</strong> ），允许不同的事务同时读取和写入数据，而不会相互阻塞</li>
<li>并发控制：在多个事务同时访问数据库时，MVCC 通过版本管理来控制事务之间的并发访问</li>
</ul>
<p>工作原理：</p>
<ul>
<li>版本管理：当对数据进行修改时，数据库并<strong>不会直接覆盖原有的数据</strong>，而是创建一个新的数据版本</li>
<li>读操作：MVCC 确保读取的是事务<strong>开始时可见的版本</strong>，实现快照读。由于每个事务有自己的快照，所以读操作不会阻塞写操作。</li>
</ul>
<blockquote>
<p>读取数据的过程：一个事务在读取数据时，其他事务提交了对该数据的修改，该事务会看到的是修<strong>改前的旧版本</strong>，而不是正在进行的修改，保证了读取操作的隔离性</p>
</blockquote>
<ul>
<li>写操作：当事务进行写操作时，创建一个新的版本，并将该版本标记为当前事务的版本。完成事务后，新的版本被提交，成为最新的可见版本。</li>
</ul>
<hr>
<h3 id="MySQL-隔离级别"><a href="#MySQL-隔离级别" class="headerlink" title="MySQL 隔离级别"></a>MySQL 隔离级别</h3><p>决定了多个事务并发执行时的行为</p>
<ol>
<li>读未提交：一个事务可以读取另一个事务未提交的数据。可能出现脏读</li>
<li>读已提交：一个事务只能读取已提交的数据。可能出现不可重复读</li>
<li>可重复读：一个事务在开始后，期间读取的数据在该事务内都是一致的。可能出现幻读，因为查询的结果可能因为其他事务的插入（ 增删 ）而变化</li>
<li>串行行：所有事务按顺序执行</li>
</ol>
<hr>
<h3 id="三个日志"><a href="#三个日志" class="headerlink" title="三个日志"></a>三个日志</h3><ul>
<li>错误日志：记录错误信息</li>
<li>二进制日志：记录所有更改数据库状态的操作</li>
<li>重做日志：记录事务对数据库的操作</li>
</ul>
<hr>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h3><p>JMM：用于解决<strong>多线程环境</strong>下的可见性、有序性和原子性问题，核心是通过定义主内存和工作内存的交互规则，确保进程间通信正确。</p>
<ul>
<li>原子性：同一时刻只能有一个线程对数据进行操作</li>
<li>可见性：一个线程对主内存的修改可以及时地被其他线程看到</li>
<li>有序性：使用 happens-before原则（ 第一个操作会在第二个操作之前执行 ）</li>
</ul>
<hr>
<h3 id="jvm内存模型介绍一下"><a href="#jvm内存模型介绍一下" class="headerlink" title="jvm内存模型介绍一下"></a><strong>jvm内存模型介绍一下</strong></h3><p>作用：定义了 Java 程序如何在内存中分配和管理数据</p>
<ul>
<li>方法区：存储类信息、常量、静态变量和 JIT 编译后的代码。Java 8 之后，成为<strong>元空间</strong>，不再使用堆内存而是本地内存（ JVM运行时从操作系统分配的内存 ）</li>
<li>堆区：存储对象实例，是 JVM 中最大的内存区域。也是所有<strong>线程共享</strong>的内存区域，垃圾回收的主要区域，</li>
</ul>
<p>有新生代（ 存放新创建的对象 ）、老年代（ 存放长期存活的对象）和元空间（ 存储类的元数据 ）</p>
<ul>
<li>栈区：每个线程都有自己的栈，存储局部变量、方法调用。局部变量在方法调用结束后立即被销毁</li>
<li>程序计数器：记录当前线程执行字节码的地址，该区域<strong>线程私有</strong></li>
<li>本地方法栈：执行本地方法（通过 JNI调用的、用其他编程语言编写的方法 ）的调用</li>
</ul>
<hr>
<h3 id="怎么进行垃圾回收？"><a href="#怎么进行垃圾回收？" class="headerlink" title="怎么进行垃圾回收？"></a>怎么进行垃圾回收？</h3><p>垃圾回收定义：回收不再用的对象，来释放内存空间</p>
<p>垃圾回收算法：</p>
<ul>
<li>引用计数法：每个对象维护引用计数器，每当有一个地方引用该对象时，计数器 +1，失效时，计数器 -1。当引用为 0 时回收</li>
<li>可达性分析：从被称为 GC Roots（ 线程、静态变量、栈中的局部变量、全局变量等 ）的对象作为起始点，开始向下搜索，搜索走过的路径叫引用链。当从 GC Roots 到该对象不可达，则证明该对象不可用，可被回收</li>
</ul>
<blockquote>
<p>本地变量：代码内部声明的</p>
</blockquote>
<hr>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>类加载器：负责在运行时将 Java 类加载到内存中，作用：将字节码文件（ .class 文件 ）转化为 JVM 可以使用的类对象</p>
<p>定义：Java 类加载器在加载类时，首先会将请求委派给<strong>父类加载器</strong>，只有当父类加载器无法找到该类时，子类加载器才会尝试自己加载</p>
<p>优点：</p>
<ul>
<li>避免重复加载（ 当父类加载了该类，就不需要子加载器再次加载 ）</li>
<li>防止核心 API 被篡改（ 无法编写一个自己的 java.lang.String 类来替换系统的 String 类，因为所有的 String 类都会有启动类加载器加载（ 父类 ））</li>
</ul>
<hr>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="为什么-Redis-比-MySQL-快？"><a href="#为什么-Redis-比-MySQL-快？" class="headerlink" title="为什么 Redis 比 MySQL 快？"></a>为什么 Redis 比 MySQL 快？</h3><ul>
<li><p>Redis 数据主要存储在内存中，MySQL数据存储在磁盘上，内存的读写速度远远快于磁盘。</p>
</li>
<li><p>采用了简单的数据结构，MySQL 的数据结构相对发杂，以表的形式存储</p>
</li>
</ul>
<hr>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>String：值是字符串，用于缓存</li>
<li>Hash：键值对的集合，存储对象</li>
<li>List：有序字符串集合，可以在两端快速推入或弹出元素，类似于链表，用于消息队列</li>
<li>Set：无序字符串集合，支持<strong>唯一性</strong>，方法除了添加获取删除还有<strong>交集并集</strong>，用于共同关注</li>
<li>Zset：与 Set 类似，但是多了每个元素有与之关联的<strong>分数</strong>，用于排行榜</li>
</ul>
<hr>
<h3 id="Redis持久化机制有哪些，底层原理是怎样的"><a href="#Redis持久化机制有哪些，底层原理是怎样的" class="headerlink" title="Redis持久化机制有哪些，底层原理是怎样的"></a>Redis持久化机制有哪些，底层原理是怎样的</h3><ul>
<li><p>AOF 日志</p>
<p>每执行一条写操作命令，就把该命令以追加的方式写入到一个日志文件里</p>
</li>
</ul>
<p>​	同步策略：1.Always：每次写操作后同步、2.Everysec：每秒同步、3.No：从不同不（依赖操作系统）</p>
<p>​	重写策略：根据数据库状态所需的最小命令集来生成一个新的 AOF 文件</p>
<p>​	数据恢复：Redis重启时，可以通过 AOF 文件重放其中的命令来啊恢复数据</p>
<ul>
<li><p>RDB 快照</p>
<p>为什么有RDB快照？AOF记录的时操作命令而不是实际的数据，若AOF日志非常多，会造成Redis恢复操作缓慢</p>
</li>
</ul>
<p>​	定义：记录某一个瞬间的内存数据</p>
<p>​	生成 RDB 文件的命令：save：在主线程中生成RDB文件，会阻塞主线程、bgsave：创建一个子进程生成RDB，避免阻塞</p>
<hr>
<h3 id="redis分布式锁读写一致性如何保证"><a href="#redis分布式锁读写一致性如何保证" class="headerlink" title="redis分布式锁读写一致性如何保证"></a>redis分布式锁读写一致性如何保证</h3><p>锁过期导致读写不一致，使用 Redisson 的自动续期机制（ 锁被持有期间，Redisson会自动延长锁的过期时间 ）</p>
<hr>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="RabbitMQ-是什么"><a href="#RabbitMQ-是什么" class="headerlink" title="RabbitMQ 是什么"></a>RabbitMQ 是什么</h3><p>消息队列，特性如下</p>
<ul>
<li>核心组件：生产者发送消息给 RabbitMQ、消费者从 RabbitMQ 接收并处理消息、RabbitMQ 本身负责存储和转发消息</li>
<li>交换机：接收来自生产者的消息，并根据 Routing key 和绑定规则将消息路由到一个或多个队列</li>
</ul>
<blockquote>
<p>Routing key：消息发送时附加的一个字符串，交换机根据这个字符串来决定将消息路由到哪些队列</p>
<p>绑定规则：</p>
<ul>
<li>Direct Binding：队列与交换机通过一个具体的路由键连接</li>
<li>Topic Binding：使用匹配模式（ * 代表一个单词， # 代表多个单词 ）</li>
<li>Fanout Binding：所有绑定到该交换机的队列都会收到消息</li>
</ul>
</blockquote>
<ul>
<li>持久化：可以将消息保存在磁盘上</li>
<li>确认机制：消费者处理完消息后发送确认给 RabbitMQ，未确认的消息会重新入队</li>
<li>高可用性：可以将多个 RabbitMQ 实例组成一个集群</li>
</ul>
<hr>
<h3 id="消息幂等性"><a href="#消息幂等性" class="headerlink" title="消息幂等性"></a>消息幂等性</h3><p>定义：同一条消息被处理多次时，结果是相同的，不会产生副作用（ 重复扣款、重复创建订单 ）</p>
<p>为什么需要幂等性：1. 生产者消息重发、2. 消费者重复处理</p>
<p>实现方法</p>
<ul>
<li>唯一标识符：为每条消息分配一个唯一的标识符，消费者在处理消息时，首先检查（ 判断 Set 集合中有没有这个唯一标识符 ）该标识符是否已经处理过（ 背景：每次处理完后都会把唯一识别符记录到一个 Set 集合中 ）</li>
<li>数据库约束：在数据库中使用唯一约束（ 防止在指定的列中插入重复数据 ），确保同一条消息不会导致重复插入</li>
</ul>
<hr>
<h3 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h3><p>定义：消息传递过程中，消息未能成功到达目标消费者的情况。</p>
<p>解决方案：</p>
<ul>
<li>持久化消息（ 队列崩溃 ）：确保消息在发送到队列时进行持久化。实现：将消息标记为 persistent 来确保其被写入磁盘</li>
<li>确认机制（ 消费者崩溃 ）：消费者在成功处理消息后，必须向消息队列发送确认信号，确保只有在消息成功处理后，才会从队列中删除</li>
<li>重试机制 （ 消费者处理消息失败 ）：将处理失败的消息重新放回队列中</li>
<li>死信队列（ 消费者处理消息失败 ）：将无法处理的消息发送到死信队列。实现：配置一个死信交换机，将处理失败的消息路由到特定的死信队列</li>
</ul>
<hr>
<h3 id="消费堆积"><a href="#消费堆积" class="headerlink" title="消费堆积"></a>消费堆积</h3><p>定义：消息队列中未消费的消息数量不断增加</p>
<p>解决方法：</p>
<ul>
<li>增加消费者实例（ 加快消费速率 ）</li>
<li>优化消息处理逻辑（ 减少处理时间 ）</li>
<li>使用延迟队列：将不那么紧急的消息放入延迟队列</li>
</ul>
<hr>
<h2 id="黑马点评"><a href="#黑马点评" class="headerlink" title="黑马点评"></a>黑马点评</h2><h3 id="如何在-Java-项目中使用-Redis"><a href="#如何在-Java-项目中使用-Redis" class="headerlink" title="如何在 Java 项目中使用 Redis"></a>如何在 Java 项目中使用 Redis</h3><p>添加 Redis 客户端 Jedis 依赖</p>
<hr>
<h3 id="为什么用Redis替代Session？还有其他解决办法吗？"><a href="#为什么用Redis替代Session？还有其他解决办法吗？" class="headerlink" title="为什么用Redis替代Session？还有其他解决办法吗？"></a>为什么用Redis替代Session？还有其他解决办法吗？</h3><p>Session 有集群共享问题：默认情况下，Session 保存在单个服务器上，当有多个服务器时，Session 信息不能共享，而 Redis 数据共享</p>
<p>Redis 的优点</p>
<ul>
<li>读写速度块（ 基于内存的数据库 ）</li>
<li>保证数据的持久性</li>
<li>丰富的数据结构（ 选用 Hash，因为可以对单个字段进行CRUD，更加灵活 ）</li>
</ul>
<p>其他解决办法：Session拷贝，会导致增加服务器的额外内存开销和数据一致性问题</p>
<hr>
<h3 id="您能详细解释一下如何使用-Redis-实现-Session-共享的吗？"><a href="#您能详细解释一下如何使用-Redis-实现-Session-共享的吗？" class="headerlink" title="您能详细解释一下如何使用 Redis 实现 Session 共享的吗？"></a>您能详细解释一下如何使用 Redis 实现 Session 共享的吗？</h3><p>注册用户时，会生成一个随机的 Token 作为 Key 值存放用户到 Redis 中</p>
<hr>
<h3 id="为什么使用-ThreadLocal-保存用户信息"><a href="#为什么使用-ThreadLocal-保存用户信息" class="headerlink" title="为什么使用 ThreadLocal 保存用户信息"></a>为什么使用 ThreadLocal 保存用户信息</h3><p>线程安全：<strong>避免多线程并发修改问题</strong>，将信息保存到线程内部，保证用户信息一致性</p>
<p>提高性能：第一层拦截器已经将用户信息保存到 ThreadLocal 中，第二层拦截器可以直接使用这些数据，而<strong>不需要重复查询 Redis</strong></p>
<hr>
<h3 id="权限怎么刷新"><a href="#权限怎么刷新" class="headerlink" title="权限怎么刷新"></a>权限怎么刷新</h3><p>也就是如何刷新 Redis 中的 token：EXPIRE、SETEX 命令</p>
<blockquote>
<p>Token：用于身份验证，是后端生成的，要发送给前端。以后每次请求前端要携带 Token </p>
</blockquote>
<hr>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><img src="D:\xmind\Typora\image\屏幕截图 2025-05-15 224105.png" alt="屏幕截图 2025-05-15 224105" style="zoom: 80%;" />

<p>实现复用登录校验和权限刷新的<strong>复用</strong></p>
<hr>
<h3 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h3><p>定义：缓存和数据库中的数据不同步</p>
<p>缓存更新策略</p>
<ul>
<li>内存淘汰：利用 Redis 的内存淘汰机制，当内存不足时自动淘汰部分数据</li>
<li>超时剔除：给缓存增加 TTL 时间，到期后自动删除缓存</li>
<li>主动更新：编写业务逻辑，在修改数据库的同时，更新缓存</li>
</ul>
<p>对于读数据：如果缓存未命中，会从数据库中加载数据到缓存</p>
<p>对于写数据，使用删除缓存模式：更新数据时更新数据库并删除缓存，查询时更新缓存（ 无效写操作较少 ）</p>
<ul>
<li>先删缓存再更新数据库，存在缓存击穿问题</li>
<li>先更新数据库再删缓存，存在脏读现象。</li>
</ul>
<p>将缓存和数据库操作放到同一个事务（ 实现方法：消息队列（ 更新数据库后，将更新缓存的请求发送到消息队列，这样可以异步地更新缓存））来保证原子性</p>
<hr>
<h3 id="缓存穿透、缓存雪崩、缓存击穿"><a href="#缓存穿透、缓存雪崩、缓存击穿" class="headerlink" title="缓存穿透、缓存雪崩、缓存击穿"></a>缓存穿透、缓存雪崩、缓存击穿</h3><p>缓存穿透</p>
<ul>
<li>客户端请求的数据在缓存和数据库中都不存在</li>
<li>解决方法</li>
</ul>
<ol>
<li><p>缓存空对象（ 当查询一个不存在的数据时，可以将这个空结果缓存一段时间 ）</p>
</li>
<li><p>布隆过滤器（ 用于测试一个元素是否存在一个集合中的概率数据结构（ 哈希函数和位数组 ））</p>
</li>
</ol>
<blockquote>
<p>工作原理：使用 N 个哈希函数对数据作哈希运算，得到 N 个哈希值，对位图数组长度取模，得到对应位置并置为 1</p>
<p>它说存在不一定数据库中有（ 哈希冲突 ），它说不存在数据库一定没有</p>
</blockquote>
<p>缓存雪崩</p>
<ul>
<li>同一段时间内，大量的缓存 key 同时失效或 Redis 服务宕机</li>
<li>解决方法</li>
</ul>
<ol>
<li>给不同的 Key 的 TTL 添加随机值（ 固定时间 + 一个范围的随机时间 ）</li>
<li>利用多级缓存 （ 本地缓存 ConcurrentHashMap 和 分布式缓存 Redis ）</li>
</ol>
<p>缓存击穿（ 热点 Key 问题 ）</p>
<ul>
<li>高并发访问的 Key 突然消失</li>
<li>解决方法</li>
</ul>
<ol>
<li>使用互斥锁：控制只有一个请求可以查询数据库并更新缓存，其他请求需要等待（ 避免了大量请求同时访问 ）</li>
<li>合理设置缓存过期时</li>
</ol>
<hr>
<h3 id="您能详细描述一下使用-Redis-实现全局唯一-ID-的过程吗？"><a href="#您能详细描述一下使用-Redis-实现全局唯一-ID-的过程吗？" class="headerlink" title="您能详细描述一下使用 Redis 实现全局唯一 ID 的过程吗？"></a>您能详细描述一下使用 Redis 实现全局唯一 ID 的过程吗？</h3><p>自增 ID 的问题</p>
<ul>
<li>id 的规律过于明显：容易出现信息泄漏</li>
<li>受表单数据量的限制：MySQL 中表能够存储的数据有限，会出现分库分表的情况，<strong>id 不能一直自增</strong></li>
</ul>
<p>时间戳 + 序列号（ 秒内计数器 ） +数据库自增</p>
<p>其他方法：雪花算法</p>
<hr>
<h3 id="乐观锁解决超卖问题"><a href="#乐观锁解决超卖问题" class="headerlink" title="乐观锁解决超卖问题"></a>乐观锁解决超卖问题</h3><ul>
<li>悲观锁：认为线程安全一定会发生，因此操作数据库之前需要先获取锁（ synchronized、lock ）</li>
<li>乐观锁：认为线程安全不一定会发生，不加锁，在更新数据库的时候判断判断有没有其它线程对数据进行修改实现方法：（ 版本号、 CAS ），不安全则抛出异常或中断</li>
</ul>
<ol>
<li>版本号法：新增一个版本号字段，线程 1 在进行库存扣减的同时将版本号 +1，线程 2 在进行扣减操作时，要先判断此时的版本号和查询库存时的版本号是否一致</li>
<li>CAS（ Compare-And-Swap ） 法：使用库存代替版本</li>
</ol>
<blockquote>
<p>读取内存地址 V 的当前值，将当前值与预期值（ 查询时的库存数 ） A 比较，如果当前值等于预期值则将 V 更新为新值 B，否则不进行更新，返回当前值</p>
</blockquote>
<hr>
<h3 id="为什么使用分布式锁"><a href="#为什么使用分布式锁" class="headerlink" title="为什么使用分布式锁"></a>为什么使用分布式锁</h3><p><strong>乐观锁</strong>用于低并发、简单的更新操作中，在涉及多个步骤（ 检查库存、扣减库存 ）时，使用分布式锁来确保这些操作的<strong>互斥性和原子性</strong></p>
<p>分布式锁定义：用于<strong>分布式环境下</strong>并发控制的一种机制，用于控制某个资源在同一时刻只能被一个应用使用</p>
<p>JVM 之间是相互独立的，每个 JVM 中的 synchronized 锁都是局部的、独立的锁。在集群环境中，两个运行在不同 JVM 上的程序无法共享同一个 synchronized 锁，锁失效。</p>
<p>所以需要分布式锁（ 在集群模式下多进程可见并且互斥的锁 ）</p>
<hr>
<h3 id="分布式锁优化"><a href="#分布式锁优化" class="headerlink" title="分布式锁优化"></a>分布式锁优化</h3><p>产生的问题：业务阻塞导致锁的超时释放，而后业务又完成了，释放锁的时候就出现了问题</p>
<p>分布式锁优化 1：产生原因：释放了别人的锁，解决方法：判断这个锁是不是自己的锁</p>
<p>分布式锁优化 2：产生原因：判断是否是锁之后阻塞了，又释放了别人的锁（ 误判 ），解决方法：Lua 脚本（ 保障判断锁和释放锁这段代码的原子性 ）</p>
<p>为什么需要 Lua：解锁有两个操作，先判断该锁是否是加锁客户端，是的话，再将锁删除</p>
<p>Lua 保证原子性的原理：单线程执行，Redis 的事务支持（ Lua 脚本执行期间，Redis 不允许执行其他命令 ）</p>
<hr>
<h3 id="分布式锁为什么使用redisson而不是直接使用SETNX，redisson有什么优势吗？"><a href="#分布式锁为什么使用redisson而不是直接使用SETNX，redisson有什么优势吗？" class="headerlink" title="分布式锁为什么使用redisson而不是直接使用SETNX，redisson有什么优势吗？"></a>分布式锁为什么使用redisson而不是直接使用SETNX，redisson有什么优势吗？</h3><ul>
<li>功能丰富性：Redisson提供可重入锁（ 锁以 hash 结构存储在 Redis 中，每次获取锁 value 值 +1，释放锁 value 值 -1，当 value 值为 0 时才真正释放锁）、公平锁等，SETNX 不可重入（ 同一线程不能重复获取<strong>同一把锁</strong> ）</li>
</ul>
<blockquote>
<p>不可重入导致死锁：方法 A 中调用方法 B，方法 A、B 都要获取分布式锁（ 同一把锁 ），线程 1 进入方法 A 获取了一次锁，进入方法 B 又获取一次锁，由于锁不可重入，所以会导致死锁</p>
<p>SETNX：键不存在时才插入</p>
</blockquote>
<ul>
<li>自动解锁机制：可以设置锁的过期时间，SETNX需要额外的逻辑（ EX&#x2F;PX，Lua 脚本 ）</li>
<li>SETNX 不可重试，失败了就返回 false，Redisson 的 tryLock方法有<strong>超时释放机制和等待机制</strong></li>
<li>简洁 API：提供了简洁易用的 API，无需关心底层的 Redis 命令</li>
</ul>
<hr>
<h3 id="基于-Stream-结构实现消息队列（-异步秒杀优化-）"><a href="#基于-Stream-结构实现消息队列（-异步秒杀优化-）" class="headerlink" title="基于 Stream 结构实现消息队列（ 异步秒杀优化 ）"></a>基于 Stream 结构实现消息队列（ 异步秒杀优化 ）</h3><p>为什么要消息队列？将一个同步的程序变成两个异步的程序，其中一个程序读取另一个程序中放到消息队列中的数据，实现了效率提高</p>
<p>将判断秒杀库存和校验一人一单放进 Redis 里查询，并将优惠卷、用户id、订单 id 保存到阻塞队列，而后查询优惠卷、查询订单等操作可以异步去从队列中读取，实现了优化</p>
<img src="D:\xmind\Typora\image\屏幕截图 2025-05-19 202339.png" alt="屏幕截图 2025-05-19 202339" style="zoom: 67%;" />

<hr>
<h3 id="在实现异步秒杀下单时，您是如何保证消息的可靠性和一致性的？"><a href="#在实现异步秒杀下单时，您是如何保证消息的可靠性和一致性的？" class="headerlink" title="在实现异步秒杀下单时，您是如何保证消息的可靠性和一致性的？"></a>在实现异步秒杀下单时，您是如何保证消息的可靠性和一致性的？</h3><hr>
<h3 id="如何用-redis-的-Sortedset做排行榜？"><a href="#如何用-redis-的-Sortedset做排行榜？" class="headerlink" title="如何用 redis 的 Sortedset做排行榜？"></a>如何用 redis 的 Sortedset做排行榜？</h3><p>它能够存储唯一的元素，并且每个元素都有一个分数，可以根据这个分数进行排序</p>
<ul>
<li><strong>ZADD</strong> leaderboard 用户ID 得分：将用户得分添加到 SortedSet 中</li>
<li><strong>ZRANGE</strong> leaderboard 0 N-1 WITHSCORES：升序返回前 N 名，<strong>ZREVRANK</strong> 降序</li>
<li><strong>ZREM</strong> leaderboard 用户ID：移除某个用户</li>
</ul>
<hr>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring-中的事务如何实现"><a href="#Spring-中的事务如何实现" class="headerlink" title="Spring 中的事务如何实现"></a>Spring 中的事务如何实现</h3><p>事务管理的两种方式</p>
<ol>
<li><p>编程式事务管理：手动控制事务的开始、提交和回滚</p>
</li>
<li><p>声明式事务管理：通过注解，Spring 会为目标类创建一个代理对象，通过 JDK 动态代理：程序运行时生成一个新的对象，作用：对这个新的对象操作的时候就可以把操作传给被注释的对象</p>
</li>
<li><p>事务管理的<strong>原理</strong></p>
<p>AOP（ 面向切面编程 ），切面包括切入点和通知</p>
<p>切入点：程序执行的一个特定位置，例如：方法的调用或异常的抛出</p>
<p>通知：在切入点上执行的动作或逻辑，在目标方法的不同阶段插入自定义行为</p>
</li>
</ol>
<hr>
<h3 id="springboot-的-bean-创建方式"><a href="#springboot-的-bean-创建方式" class="headerlink" title="springboot 的 bean 创建方式"></a>springboot 的 bean 创建方式</h3><ul>
<li><p>Bean 的定义：由 Spring IoC 容器管理的对象，可以是任何一个类的实例</p>
</li>
<li><p>基于注解：</p>
<ol>
<li>@Component（ 标记一个类为 Spring 管理的 Bean）</li>
<li>@Service、@Reposity、@Controller 是 Component 的变种，标识服务层、数据访问层、控制层的 Bean</li>
</ol>
</li>
<li><p>基于 Java 配置类声明：@Configuration（ 类可以定义 Bean ） + @Bean（ 显示定义 Bean ）</p>
</li>
<li><p>基于 XML 配置</p>
</li>
</ul>
<hr>
<h3 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h3><ul>
<li>实例化（ @Component ）</li>
<li>属性注入（ @Autowired ）</li>
<li>初始化（ @PostConstruct ）</li>
<li>销毁（ @PreDestroy ）</li>
</ul>
<hr>
<h3 id="IoC（-Inversion-of-Control-）"><a href="#IoC（-Inversion-of-Control-）" class="headerlink" title="IoC（ Inversion of Control ）"></a>IoC（ Inversion of Control ）</h3><p>控制反转：将对象的控制权交给外部容器（ IoC 容器 ），是一种设计思想</p>
<p>好处：减少组件之间的耦合，提高可测试性（ 可以轻松模拟对象来代替真实对象 ）</p>
<h4 id="IoC-的实现方式：-DI"><a href="#IoC-的实现方式：-DI" class="headerlink" title="IoC 的实现方式： DI"></a>IoC 的实现方式： DI</h4><p>依赖注入（ Dependency Injection ）：通过将目标对象依赖的其他对象（ 依赖对象 ）在运行时注入到对象中</p>
<p>实现方法：</p>
<ul>
<li>构造函数注入：通过构造函数将依赖对象传递给目标对象</li>
<li>方法注入：调用方法时传递依赖项</li>
<li>字段注入：通过直接在字段上使用 @Autowired 注解进行注入（ 自动装配：Spring 框架提供的一个功能，旨在简化依赖注入的过程，允许Spring 自动解决和注入对象之间的依赖关系，无需手动配置 ）</li>
</ul>
<hr>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>面向切面编程（ Aspect-Oriented Programming ）：是一种编程范式，用于将跨越多个模块的关注点（ 如日志、事务管理、安全等 ）从业务逻辑中分离出来，以提高代码的模块化和可维护性</p>
<ul>
<li>横切关注点：多个类或对象中的公共行为（ 如日志记录、事务管理等 ）</li>
<li>切面：对横切关注点进行封装的类，用来实现具体的功能</li>
<li>连接点：程序执行中的一个点（ 如方法调用、对象创建 ）</li>
<li>通知：切面在某个连接点要执行的操作（ 前置、后置、环绕 ）</li>
<li>切点：定义了哪些连接点上应用切面</li>
<li>织入：将切面代码与业务逻辑代码结合的过程</li>
</ul>
<p><strong>原理</strong>：动态代理（ 在运行时创建代理对象的技术，代理对象可以拦截对目标方法的调用，并在调用之前或之后执行一些额外的操作 ）</p>
<ul>
<li><p>基于 JDK 的动态代理：是基于<strong>接口</strong>的代理方式，利用<strong>反射</strong>机制，在运行时创建一个实现了目标队形所实现的所有接口的代理对象，当调用代理对象的方法时，会触发 <code>InvocationHandler</code> 的 <code>invoke</code> 方法，在这个方法中可以添加额外的逻辑，从而实现对目标方法的增强</p>
</li>
<li><p>基于 CGLIB( Code Genertion Library ) 的动态代理：使用 CGLIB 库来创建代理对象，代理对象<strong>继承</strong>了目标对象，通过方法拦截来实现代码逻辑。</p>
</li>
</ul>
<hr>
<h3 id="Sprng-MVC"><a href="#Sprng-MVC" class="headerlink" title="Sprng MVC"></a>Sprng MVC</h3><p>是一个基于 Java 的框架，是 Spring 框架的一部分，用于构建 Web 应用程序，它遵循 MVC（ Model-View-Controller ）设计模式，旨在分离应用程序的不同关注点。与 SpringBoot 的区别是配置较麻烦，需要手动添加依赖，且没有内置的 Tomcat 服务器</p>
<ul>
<li>Model（ 模型 ）：代表应用程序的数据和业务逻辑，对应于数据库中的实体类</li>
<li>View（ 视图 ）：负责呈现数据给用户</li>
<li>Controller（ 控制器 ）：用于处理用户请求，调用相应的服务处进行业务处理，并返回视图</li>
</ul>
<hr>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a>TCP三次握手过程</h3><ul>
<li>一开始，客户端和服务端都处于 CLOSE 状态，先是服务端主动监听某个端口，处于 LISEN 状态</li>
<li>第一次握手：客户端向服务器发送一个 <strong>SYN</strong> 报文，报文中包含客户端的初始序列号，表示客户端请求连接，之后客户端处于 SYN-SENT 状态</li>
<li>第二次握手：服务端向客户端发送一个 <strong>SYN-ACK</strong> 报文。报文中包含服务器的初始序列号，确认应答号中是<code>客户端序列号 + 1</code>。之后服务端处于 *YN-RCVD 状态</li>
<li>第三次握手：客户端向服务端发送 <strong>ACK</strong> 报文，报文中的确认应答号为<code>服务端序列号 + 1</code>，可以携带客户端数据到服务端，之后客户端处于 ESTABLISHED 状态</li>
<li>服务端就受到客户端的应答报文后，也进入 ESTABLISHED 状态</li>
</ul>
<hr>
<h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><ul>
<li>第一次挥手：客户端发送一个 <strong>FIN</strong>（ 表示它已经没有数据要发送 ）报文给服务器，，但仍可以接收数据</li>
<li>第二次挥手：服务器发送一个 <strong>ACK</strong> 报文给客户端（ 表示收到了客户端的关闭请求 ），此时服务器可能还有数据需要发送，所以不会立刻关闭</li>
<li>第三次挥手：服务器数据全部发送完成，发送 FIN 报文给客户端，表示它也没有数据需要发送了，准备关闭连接</li>
<li>第四次挥手：客户端发送 ACK 报文给服务器。服务器收到 ACK 后就 CLOSE，客户端经过 2MSL（ 报文最大生存时间 ） 后 CLOSE</li>
</ul>
<hr>
<h3 id="打开页面的全过程"><a href="#打开页面的全过程" class="headerlink" title="打开页面的全过程"></a>打开页面的全过程</h3><hr>
<h3 id="HTTP-和-HTTPS的区别是什么？"><a href="#HTTP-和-HTTPS的区别是什么？" class="headerlink" title="HTTP 和 HTTPS的区别是什么？"></a>HTTP 和 HTTPS的区别是什么？</h3><ul>
<li>HTTPS 在传输层和网络层之间加入了 SSL&#x2F;TLS 协议，使得报文能够加密传输</li>
<li>HTTP 80、HTTPS 443</li>
<li>HTTPS 协议需要向 CA（ 证书权威机构 ）申请数字证书，来保证服务器的身份是可信的</li>
</ul>
<hr>
<h3 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h3><p>轻量级（ 为低带宽、不可靠网络设计 ）消息传输协议，多用于物联网设备之间的通信</p>
<p>发布&#x2F;订阅模式</p>
<ul>
<li>发布：客户端通过MQTT代理（ Mosquitto ）向特定的主题发送消息</li>
<li>订阅：客户端向MQTT代理（ Mosquitto ）请求接受特定主题消息</li>
<li>MQTT 提供三种 QoS（服务质量）等级</li>
</ul>
<ol>
<li>QoS 0：至多一次，可能丢失</li>
<li>QoS 1：至少一次，确保消息被送达，但可能重复</li>
<li>QoS 2：只有一次，确保消息被唯一地送达</li>
</ol>
<p>Eclipse Paho：一个用于实现 MQTT 协议的开源项目</p>
<hr>
<h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><ul>
<li>连接：TCP 传输前需要连接，UDP 不需要连接</li>
<li>服务对象：TCP 是一对一，UDP支持一对一、一对多（ 广播 ）、多对多</li>
<li>可靠性：TCP 可靠交付数据，UDP 尽最大努力，不保证可靠交付数据，但是可以在其基础上设计一个可靠传输协议 QUIC</li>
</ul>
<blockquote>
<p>连接管理：三次握手</p>
<p>超时重传</p>
<p>流量控制：为了防止接收方溢出，实现方式：滑动窗口</p>
<p>拥塞控制：为了防止网络拥塞，实现方式：慢开始、拥塞避免、快重传、快恢复</p>
</blockquote>
<ul>
<li>使用场景：TCP（ Web浏览、远程登录 ）、UDP（ 视频会议 ）</li>
</ul>
<hr>
<h3 id="HTTP1-0到3-0的版本更新所带来的新特性"><a href="#HTTP1-0到3-0的版本更新所带来的新特性" class="headerlink" title="HTTP1.0到3.0的版本更新所带来的新特性"></a>HTTP1.0到3.0的版本更新所带来的新特性</h3><ul>
<li>HTTP&#x2F;1.1</li>
</ul>
<ol>
<li>持久连接：允许多个请求通过同一个 TCP 连接</li>
<li>管道化：允许在一个连接上并行发送多个请求（ 只要第一个请求发出，不必等待其回来就可以发送第二个请求 ），缺点：如果一个请求阻塞，多个请求统统阻塞</li>
</ol>
<ul>
<li>HTTP&#x2F;2</li>
</ul>
<ol>
<li>头部压缩：通过 HPACK 算法（ 在客户端和服务器同时维护一张头信息表，字段会对应索引号，以后发送时就发送个索引号 ）进行头部压缩，减少了请求和响应的头部的大小</li>
<li>二进制分帧：将数据分割成更小的二进制帧（ 而不是纯文本形式的报文 ）</li>
<li>优先级：允许客户端为请求设置优先级</li>
<li>多路复用：同一连接上并行处理多个请求和响应，消除了对头阻塞问题（ HTTP&#x2F;1.1 的串行请求 ）</li>
</ol>
<blockquote>
<p>串行请求：一次处理一个，处理完这个再处理下一个</p>
<p>并行处理：处理 A，发现 A 很耗时，先把处理过的返回 A，去执行 B，B 处理完后再处理 A</p>
</blockquote>
<ol start="5">
<li>缺点：多个 HTTP 复用一个连接，下层 TCP 协议不知道有多少个 HTTP 请求，会导致一旦发生丢包现象，所有的 HTTP 请求都必须等待这个丢了的包被重传</li>
</ol>
<ul>
<li>HTTP&#x2F;3</li>
</ul>
<ol>
<li>使用 QUIC（ 基于 UDP ） 作为传输层协议，好处：UDP 不管顺序和丢包，所以不会出现 HTTP&#x2F;1.1 的对头阻塞和 HTTP&#x2F;2 的一个丢包全部重传问题</li>
</ol>
<hr>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="协程是什么？有什么好处？"><a href="#协程是什么？有什么好处？" class="headerlink" title="协程是什么？有什么好处？"></a><strong>协程是什么？有什么好处？</strong></h3><ul>
<li>极高的性能：切换开销非常小（ 无需进行内核级的上下文切换 ）</li>
</ul>
<hr>
<h3 id="介绍一下操作系统的虚拟内存？"><a href="#介绍一下操作系统的虚拟内存？" class="headerlink" title="介绍一下操作系统的虚拟内存？"></a>介绍一下操作系统的虚拟内存？</h3><hr>
<h3 id="进程通信方式你知道哪些？"><a href="#进程通信方式你知道哪些？" class="headerlink" title="进程通信方式你知道哪些？"></a>进程通信方式你知道哪些？</h3><ul>
<li>管道</li>
<li>消息队列</li>
<li>共享内存</li>
</ul>
<hr>
<h2 id="进程、线程、协程的区别"><a href="#进程、线程、协程的区别" class="headerlink" title="进程、线程、协程的区别"></a>进程、线程、协程的区别</h2><ul>
<li>进程：操作系统中资源分配的基本单位，每个进程有独立的内存，由操作系统调度。CPU密集型任务</li>
<li>线程：进程中的一个执行单元，共享同一进程的资源和内存，由操作系统调度。并发执行的任务</li>
<li>协程：是一种用户态的<strong>轻量级</strong>（ 无需进行内核级的上下文切换 ）线程，调度由<strong>程序自身控制</strong>，不需要内核参与。I&#x2F;O密集型任务（ 单个线程可以运行多个协程 ）</li>
</ul>
<hr>
<h3 id="IO多路复用是什么"><a href="#IO多路复用是什么" class="headerlink" title="IO多路复用是什么"></a>IO多路复用是什么</h3><p>允许程序在单一线程中同时监控多个IO流</p>
<blockquote>
<p>IO 操作：计算机系统和外部设备进行数据交换的过程</p>
</blockquote>
<hr>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="如何查看进程号状态"><a href="#如何查看进程号状态" class="headerlink" title="如何查看进程号状态"></a>如何查看进程号状态</h3><p><code>ps aux</code> ：显示所有用户进程</p>
<p><code>ps -ef | grep</code>：查找特定进程</p>
<p><code>top</code></p>
<h3 id="查看线程"><a href="#查看线程" class="headerlink" title="查看线程"></a>查看线程</h3><p><code>top -H</code></p>
<p><code>ps -T -p 1234</code></p>
<hr>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/04/07/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE/" rel="prev" title="小程序项目">
                  <i class="fa fa-angle-left"></i> 小程序项目
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Yan</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
